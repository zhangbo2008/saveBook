[1mdiff --git "a/javaee\345\274\200\345\217\221\347\232\204\351\242\240\350\246\206\350\200\205springboot\345\256\236\346\210\230.pdf" "b/javaee\345\274\200\345\217\221\347\232\204\351\242\240\350\246\206\350\200\205springboot\345\256\236\346\210\230.pdf"[m
[1mdeleted file mode 100644[m
[1mindex 7ed7cf6..0000000[m
[1m--- "a/javaee\345\274\200\345\217\221\347\232\204\351\242\240\350\246\206\350\200\205springboot\345\256\236\346\210\230.pdf"[m
[1m+++ /dev/null[m
[36m@@ -1,18300 +0,0 @@[m
[31m-                   版权信息[m
[31m-[m
[31m-书名：Java EE开发的颠覆者：Spring Boot实战[m
[31m-作者：汪云飞[m
[31m-出版社：电子工业出版社[m
[31m-ISBN：978-7-121-28208-9[m
[31m-定价：89.00[m
[31m-[m
[31m-版权所有·侵权必究[m
[31m-                      前言[m
[31m-[m
[31m-     我有将平时工作所悟写成博客以记录的习惯，随着逐渐的[m
[31m-积累，终于可以形成目前这样一本实战性的手册。我平时在阅[m
[31m-读大量的Spring相关书籍的时候发现：很多书籍对知识的讲解[m
[31m-一味求全求深，导致读者很难快速掌握某一项技术，且因为求[m
[31m-全求深而忽略了最佳实践，让读者云里雾里，甚至半途而废。[m
[31m-[m
[31m-     所以本书的每个章节的基本架构都是：点睛+实战。[m
[31m-[m
[31m-     点睛：用最简练的语言去描述当前的技术；[m
[31m-[m
[31m-     实战：对当前技术进行实战意义的代码演示。[m
[31m-[m
[31m-     本书代码的另一个特点是：技术相关，业务不相关。在本[m
[31m-书的实战例子中不会假设一个业务需求，然后让读者既要理解[m
[31m-技术，又要理解假设的业务，本书的目标是让读者“学习时只[m
[31m-关注技术，开发时只关注业务”。[m
[31m-[m
[31m-     本书涉及的技术比较广，尤其是第三部分：实战Spring[m
[31m-Boot，这让我很难在一本书中对每一项技术细节都详细说明；[m
[31m-我希望本书能为读者在相关技术应用上抛砖引玉，读者在遇到[m
[31m-特定技术的问题时可以去学习特定技术的相关书籍。[m
[31m-[m
[31m-     Spring在Java EE开发中是实际意义上的标准，但我们在开[m
[31m-发Spring的时候可能会遇到以下让人头疼的问题：[m
[31m-[m
[31m-     （1）大量配置文件的定义；[m
[31m-     （2）与第三方软件整合的技术问题。[m
[31m-[m
[31m-     Spring每个新版本的推出都以减少配置作为自己的主要目[m
[31m-标，例如：[m
[31m-[m
[31m-     （1）推出@Component、@Service、@Repository、[m
[31m-@Controller注解在类上声明Bean；[m
[31m-[m
[31m-     （2）推出@Configuration、@Bean的Java配置来替代xml配[m
[31m-置。[m
[31m-[m
[31m-     在脚本语言和敏捷开发大行其道的时代，Java EE的开发显[m
[31m-得尤为笨重，让人误解Java EE开发就该如此。Spring在提升[m
[31m-Java EE开发效率的脚步上从未停止过，而Spring Boot的推出是[m
[31m-具有颠覆和划时代意义的。Spring Boot具有以下特征：[m
[31m-[m
[31m-     （1）遵循“习惯优于配置”原则，使用Spring Boot只需很少[m
[31m-的配置，大部分时候可以使用默认配置；[m
[31m-[m
[31m-     （2）项目快速搭建，可无配置整合第三方框架；[m
[31m-[m
[31m-     （3）可完全不使用xml配置，只使用自动配置和Java[m
[31m-Config；[m
[31m-[m
[31m-     （4）内嵌Servlet（如Tomcat）容器，应用可用jar包运行[m
[31m-（java–jar）；[m
[31m-[m
[31m-     （5）运行中应用状态的监控。[m
[31m-[m
[31m-     虽然Spring Boot给我们带来了类似于脚本语言开发的效[m
[31m-率，但Spring Boot里没有使用任何让你意外的技术，完全是一[m
[31m-个单纯的基于Spring的应用。如Spring Boot的自动配置是通过[m
[31m-Spring 4.x的@Conditional注解来实现的，所以在学习Spring[m
[31m-Boot之前，我们需要快速学习Spring与Spring MVC的基础知[m
[31m-识。[m
[31m-[m
[31m-     第一部分：点睛Spring 4.x[m
[31m-[m
[31m-     快速学习Spring 4.x的各个知识点，包括基础配置、常用配[m
[31m-置以及高级配置，以便熟悉常用配置，并体会使用Java语法配[m
[31m-置所带来的便捷。[m
[31m-[m
[31m-     第二部分：点睛Spring MVC 4.x[m
[31m-[m
[31m-     快速学习Spring MVC 4.1的各个知识点，MVC的开发是我[m
[31m-们日常开发工作中最常打交道的，所以学习Spring MVC对[m
[31m-Spring Boot的使用极有帮助。[m
[31m-[m
[31m-     第三部分：实战Spring Boot[m
[31m-[m
[31m-     这部分是整本书的核心部分，每个章节都会通过讲解和实[m
[31m-战的例子来演示Spring Boot在实际项目中遇到的方方面面的情[m
[31m-况，真正达到让Spring Boot成为Java EE开发的实际解决方案。[m
[31m-[m
[31m-     Spring Boot发布于2014年4月，根据知名博主Baeldung的调[m
[31m-查，截至2014年年底，使用Spring Boot作为Spring开发方案的[m
[31m-已有34.1%，这是多么惊人的速度。[m
[31m-[m
[31m-     希望读者在阅读完本书后，能够快速替代现有的开发方[m
[31m-式，使用Spring Boot进行重构，和大量配置与整合开发说再[m
[31m-见！[m
[31m-[m
[31m-     本书是我的第一本技术书籍，主要目的是让读者快速上手[m
[31m-Spring Boot这项颠覆性的Java EE开发技术，由于作者水平有[m
[31m-限，书中纰漏之处在所难免，敬请读者批评指正。[m
[31m-        第一部分　点睛Spring 4.x[m
[31m-[m
[31m-第1章　Spring基础[m
[31m-[m
[31m-     做Java开发的程序员都知道Spring的大名，市面上关于[m
[31m-Spring的书籍也是汗牛充栋。本书介绍的Spring 4.x不是对[m
[31m-Spring知识点的全面讲解，而是将工作中常用的Spring相关的[m
[31m-知识点罗列出来，以点睛的形式（快速讲解+示例）让读者快[m
[31m-速掌握Spring在开发中的常用知识。[m
[31m-1.1　Spring概述[m
[31m-[m
[31m-1.1.1　Spring的简史[m
[31m-[m
[31m-     Spring的历史网上有很多介绍，下面讲下我亲历的Spring发[m
[31m-展的过程。[m
[31m-[m
[31m-     第一阶段：xml配置[m
[31m-[m
[31m-     在Spring 1.x时代，使用Spring开发满眼都是xml配置的[m
[31m-Bean，随着项目的扩大，我们需要把xml配置文件分放到不同[m
[31m-的配置文件里，那时候需要频繁地在开发的类和配置文件之间[m
[31m-切换。[m
[31m-[m
[31m-     第二阶段：注解配置[m
[31m-[m
[31m-     在Spring 2.x时代，随着JDK 1.5带来的注解支持，Spring提[m
[31m-供了声明Bean的注解（如@Component、@Service），大大减[m
[31m-少了配置量。这时Spring圈子里存在着一种争论：注解配置和[m
[31m-xml配置究竟哪个更好？我们最终的选择是应用的基本配置[m
[31m-（如数据库配置）用xml，业务配置用注解。[m
[31m-[m
[31m-     第三阶段：Java配置[m
[31m-[m
[31m-     从Spring 3.x到现在，Spring提供了Java配置的能力，使用[m
[31m-Java配置可以让你更理解你配置的Bean。我们目前刚好处于这[m
[31m-个时代，Spring 4.x和Spring Boot都推荐使用Java配置，所以我[m
[31m-们在本书通篇将使用Java配置。[m
[31m-1.1.2　Spring概述[m
[31m-[m
[31m-     Spring框架是一个轻量级的企业级开发的一站式解决方[m
[31m-案。所谓解决方案就是可以基于Spring解决Java EE开发的所有[m
[31m-问题。Spring框架主要提供了IoC容器、AOP、数据访问、Web[m
[31m-开发、消息、测试等相关技术的支持。[m
[31m-[m
[31m-     Spring使用简单的POJO（Plain Old Java Object，即无任何[m
[31m-限制的普通Java对象）来进行企业级开发。每一个被Spring管[m
[31m-理的Java对象都称之为Bean；而Spring提供了一个IoC容器用来[m
[31m-初始化对象，解决对象间的依赖管理和对象的使用。[m
[31m-[m
[31m-     1.Spring的模块[m
[31m-     Spring是模块化的，这意味着你可以只使用你需要的Spring[m
[31m-的模块。如图1-1所示。[m
[31m-[m
[31m-                                 图1-1　Spring的模块[m
[31m-[m
[31m-     图1-1中的每一个最小单元，Spring都至少有一个对应的jar[m
[31m-包。[m
[31m-[m
[31m-     （1）核心容器（Core Container）[m
[31m-[m
[31m-     Spring-Core：核心工具类，Spring其他模块大量使用[m
[31m-Spring-Core；[m
[31m-[m
[31m-     Spring-Beans：Spring定义Bean的支持；[m
[31m-[m
[31m-     Spring-Context：运行时Spring容器；[m
[31m-[m
[31m-     Spring-Context-Support：Spring容器对第三方包的集成支[m
[31m-持；[m
[31m-[m
[31m-     Spring-Expression：使用表达式语言在运行时查询和操作[m
[31m-对象。[m
[31m-[m
[31m-     （2）AOP[m
[31m-[m
[31m-     Spring-AOP：基于代理的AOP支持；[m
[31m-[m
[31m-     Spring-Aspects：基于AspectJ的AOP支持。[m
[31m-[m
[31m-     （3）消息（Messaging）[m
[31m-[m
[31m-     Spring-Messaging：对消息架构和协议的支持。[m
[31m-[m
[31m-     （4）Web[m
[31m-[m
[31m-     Spring-Web：提供基础的Web集成的功能，在Web项目中[m
[31m-提供Spring的容器；[m
[31m-[m
[31m-     Spring-Webmvc：提供基于Servlet的Spring MVC；[m
[31m-[m
[31m-     Spring-WebSocket：提供WebSocket功能；[m
[31m-     Spring-Webmvc-Portlet：提供Portlet环境支持。[m
[31m-[m
[31m-     （5）数据访问/集成（Data Access/Integration）[m
[31m-[m
[31m-     Spring-JDBC：提供以JDBC访问数据库的支持；[m
[31m-[m
[31m-     Spring-TX：提供编程式和声明式的事务支持；[m
[31m-[m
[31m-     Spring-ORM：提供对对象/关系映射技术的支持；[m
[31m-[m
[31m-     Spring-OXM：提供对对象/xml映射技术的支持；[m
[31m-[m
[31m-     Spring-JMS：提供对JMS的支持。[m
[31m-[m
[31m-     2.Spring的生态[m
[31m-[m
[31m-     Spring发展到现在已经不仅仅是Spring框架本身的内容，[m
[31m-Spring目前提供了大量的基于Spring的项目，可以用来更深入[m
[31m-地降低我们的开发难度，提高开发效率。[m
[31m-[m
[31m-     目前Spring的生态里主要有以下项目，我们可以根据自己[m
[31m-项目的需要来选择使用相应的项目。[m
[31m-[m
[31m-     Spring Boot：使用默认开发配置来实现快速开发。[m
[31m-[m
[31m-     Spring XD：用来简化大数据应用开发。[m
[31m-[m
[31m-     Spring Cloud：为分布式系统开发提供工具集。[m
[31m-[m
[31m-     Spring Data：对主流的关系型和NoSQL数据库的支持。[m
[31m-[m
[31m-     Spring Integration：通过消息机制对企业集成模式（EIP）[m
[31m-的支持。[m
[31m-[m
[31m-     Spring Batch：简化及优化大量数据的批处理操作。[m
[31m-Spring Security：通过认证和授权保护应用。[m
[31m-[m
[31m-     Spring HATEOAS：基于HATEOAS原则简化REST服务开[m
[31m-发。[m
[31m-[m
[31m-     Spring Social：与社交网络API（如Facebook、新浪微博[m
[31m-等）的集成。[m
[31m-[m
[31m-Spring AMQP：对基于AMQP的消息的支持。[m
[31m-[m
[31m-     Spring Mobile：提供对手机设备检测的功能，给不同的设[m
[31m-备返回不同的页面的支持。[m
[31m-[m
[31m-     Spring for Android：主要提供在Android上消费RESTful[m
[31m-API的功能。[m
[31m-[m
[31m-     Spring Web Flow：基于Spring MVC提供基于向导流程式的[m
[31m-Web应用开发。[m
[31m-[m
[31m-     Spring Web Services：提供了基于协议有限的SOAP/Web服[m
[31m-务。[m
[31m-[m
[31m-Spring LDAP：简化使用LDAP开发。[m
[31m-[m
[31m-     Spring  Session：提供一个API及实现来管理用户会话信[m
[31m-息。[m
[31m-1.2　Spring项目快速搭建[m
[31m-[m
[31m-     讲到项目的搭建，也许有些读者使用的是通过开发工具新[m
[31m-建项目，然后将项目所要依赖的第三方jar包复制到下面的类路[m
[31m-径下。[m
[31m-[m
[31m-     我们现在要和这种项目搭建的方式说拜拜了，因为上述搭[m
[31m-建方式没有第三方类库的依赖关系，在导入一个特定的jar包[m
[31m-时，可能此jar包还依赖于其他的jar包，其他的jar包又依赖于[m
[31m-更多的jar包，这也是我们平常遇到的ClassNotFound错误的主[m
[31m-要原因。[m
[31m-[m
[31m-     为了解决上述问题，我们急需引入一个项目构建工具。目[m
[31m-前主流的项目构建工具有：Ant、Maven、Gradle等。本书中我[m
[31m-们使用Maven作为项目构建工具。[m
[31m-[m
[31m-1.2.1　Maven简介[m
[31m-[m
[31m-     Apache Maven是一个软件项目管理工具。基于项目对象模[m
[31m-型（Project Object Model，POM）的概念，Maven可用来管理[m
[31m-项目的依赖、编译、文档等信息。[m
[31m-[m
[31m-     使用Maven管理项目时，项目依赖的jar包将不在包含在项[m
[31m-目内，而是集中放置在用户目录下的.m2文件夹下。[m
[31m-[m
[31m-1.2.2　Maven安装[m
[31m-     1.下载Maven[m
[31m-     根据操作系统下载正确的Maven版本，并解压到任意目[m
[31m-录。[m
[31m-     Maven下载地址：https://maven.apache.org/download.cgi。[m
[31m-     2.配置Maven[m
[31m-     在系统属性→高级→环境变量中分别配置M2_HOME和[m
[31m-Path，如图1-2所示。[m
[31m-[m
[31m-                           图1-2　配置M2_HOME和Path[m
[31m-[m
[31m-     3.测试安装[m
[31m-     在控制台输入“mvn–v”，获得如图1-3所示信息表示安装成[m
[31m-功。[m
[31m-[m
[31m-                                    图1-3　安装成功[m
[31m-1.2.3　Maven的pom.xml[m
[31m-[m
[31m-     Maven是基于项目对象模型的概念运作的，所以Maven的[m
[31m-项目都有一个pom.xml用来管理项目的依赖以及项目的编译等[m
[31m-功能。[m
[31m-[m
[31m-     在我们的项目中，我们主要关注下面的元素。[m
[31m-[m
[31m-     1.dependencies元素[m
[31m-     <dependencies></dependencies>，此元素包含多个项目依赖[m
[31m-需要使用的<dependency></dependency>。[m
[31m-     2.dependency元素[m
[31m-     <dependency></dependency>内部通过groupId、artifactId以[m
[31m-及version确定唯一的依赖，有人称这三个为坐标，代码如下。[m
[31m-     groupId：组织的唯一标识。[m
[31m-     artifactId：项目的唯一标识。[m
[31m-     version：项目的版本。[m
[31m-[m
[31m-       <dependency>[m
[31m-              <groupId>org.springframework</groupId>[m
[31m-              <artifactId>spring-webmvc</artifactId>[m
[31m-              <version>4.1.5.RELEASE</version>[m
[31m-[m
[31m-       </dependency>[m
[31m-[m
[31m-     3.变量定义[m
[31m-     变量定义：<properties></properties>可定义变量在[m
[31m-dependency中引用，代码如下。[m
[31m-[m
[31m-<properties>                                           <spring-[m
[31m-[m
[31m-framework.version>4.1.5.RELEASE</spring-framework.version>[m
[31m-[m
[31m-</properties>[m
[31m-[m
[31m-<dependency>[m
[31m-       <groupId>org.springframework</groupId>[m
[31m-       <artifactId>spring-webmvc</artifactId>[m
[31m-       <version>${spring-framework.version}</version>[m
[31m-[m
[31m-</dependency>[m
[31m-[m
[31m-     4.编译插件[m
[31m-[m
[31m-     Maven提供了编译插件，可在编译插件中涉及Java的编译[m
[31m-级别，代码如下。[m
[31m-[m
[31m-       <build>[m
[31m-                      <plugins>[m
[31m-                             <plugin>[m
[31m-                                    <groupId>org.apache.maven.plugins</groupId>[m
[31m-                                                                     <artifactId>maven-compiler-[m
[31m-[m
[31m-       plugin</artifactId>[m
[31m-                                    <version>2.3.2</version>[m
[31m-                                    <configuration>[m
[31m-                                           <source>1.7</source>[m
[31m-                                           <target>1.7</target>[m
[31m-                                    </configuration>[m
[31m-[m
[31m-                             </plugin>[m
[31m-                      </plugins>[m
[31m-       </build>[m
[31m-[m
[31m-     5.Maven运作方式[m
[31m-[m
[31m-     Maven会自动根据dependency中的依赖配置，直接通过互[m
[31m-联网在Maven中心库下载相关依赖包到.m2目录下，.m2目录下[m
[31m-是你本地Maven库。[m
[31m-[m
[31m-     如果你不知道你所依赖jar包的dependency怎么写的话，推[m
[31m-荐到http://mvnrepository.com网站检索。[m
[31m-[m
[31m-     若Maven中心库中没有你需要的jar包（如Oracle），你需[m
[31m-要通过下面的Maven命令打到本地Maven库后应用即可，如安[m
[31m-装Oracle驱动到本地库：[m
[31m-[m
[31m-mvn install:install-file    -DgroupId=com.oracle  "-[m
[31m-DartifactId=ojdbc14"      "-Dpackaging=jar"       "-[m
[31m-"-Dversion=10.2.0.2.0"[m
[31m-Dfile=D:\ojdbc14.jar"[m
[31m-[m
[31m-1.2.4　Spring项目的搭建[m
[31m-[m
[31m-     1.基于Spring Tool Suite搭建[m
[31m-[m
[31m-     Spring Tool Suite（简称STS）是Spring官方推出的基于[m
[31m-Eclipse的开发工具，集成了M2E（Maven Integration for[m
[31m-Eclipse）、Spring IDE等插件。若习惯于用Eclipse开发项目的[m
[31m-话，STS则是开发Spring项目的不二之选。若你当前使用的是[m
[31m-常规的Eclipse，请安装M2E插件。STS下载地址：[m
[31m-https://spring.io/tools/sts/all。[m
[31m-[m
[31m-     （1）新建Maven项目，如图1-4所示。[m
[31m-                         图1-4　新建Maven项目[m
[31m-[m
[31m-（2）输出本Maven项目的坐标值，如图1-5所示。[m
[31m-（3）在STS中生成如图1-6所示结构的项目。[m
[31m-                            图1-5　输出坐标值[m
[31m-[m
[31m-                            图1-6　项目的结构[m
[31m-[m
[31m-（4）修改pom.xml。增加Spring的依赖，添加编译插件，[m
[31m-将编译级别设置为1.7。[m
[31m-[m
[31m-       <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://ww[m
[31m-       instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://[m
[31m-       4.0.0.xsd">[m
[31m-[m
[31m-           <modelVersion>4.0.0</modelVersion>[m
[31m-           <groupId>com.wisely</groupId>[m
[31m-           <artifactId>highlight_spring4</artifactId>[m
[31m-           <version>0.0.1-SNAPSHOT</version>[m
[31m-           <properties>[m
[31m-[m
[31m-              <java.version>1.7</java.version>[m
[31m-           </properties>[m
[31m-           <dependencies>[m
[31m-[m
[31m-              <dependency>[m
[31m-                      <groupId>org.springframework</groupId>[m
[31m-                      <artifactId>spring-context</artifactId>[m
[31m-                      <version>4.1.6.RELEASE</version>[m
[31m-[m
[31m-              </dependency>[m
[31m-           </dependencies>[m
[31m-           <build>[m
[31m-[m
[31m-                      <plugins>[m
[31m-                             <plugin>[m
[31m-                                    <groupId>org.apache.maven.plugins</groupId>[m
[31m-                                                                     <artifactId>maven-compiler-[m
[31m-[m
[31m-       plugin</artifactId>[m
[31m-                                    <version>2.3.2</version>[m
[31m-                                    <configuration>[m
[31m-                                           <source>${java.version}</source>[m
[31m-                                           <target>${java.version}</target>[m
[31m-                                    </configuration>[m
[31m-[m
[31m-                             </plugin>[m
[31m-                      </plugins>[m
[31m-              </build>[m
[31m-       </project>[m
[31m-[m
[31m-     （5）更新项目。单击项目右键→Maven→Update[m
[31m-Project→highlight-spring4→Maven[m
[31m-Dependencies→Spring→expression-4.1.6RELEASE.jar，如图1-7[m
[31m-所示。[m
[31m-                              图1-7　更新项目[m
[31m-[m
[31m-（6）依赖树查看，如图1-8所示。[m
[31m-[m
[31m-                            图1-8　依赖树查看[m
[31m-2.基于IntelliJ IDEA搭建[m
[31m-[m
[31m-     IntelliJ IDEA是Java最优秀的开发工具：功能全面、提示智[m
[31m-能、开发不卡顿、新技术支持快。[m
[31m-[m
[31m-     IntelliJ IDEA分为社区版和商业版，社区版免费，商业版[m
[31m-功能强大。商业版提供30天的试用。[m
[31m-[m
[31m-IntelliJ                                   IDEA下载地址：[m
[31m-[m
[31m-https://www.jetbrains.com/idea/download/。[m
[31m-[m
[31m-     （1）新建Maven项目。单击File→New→Project→Maven，[m
[31m-如图1-9所示。[m
[31m-[m
[31m-（2）输入Maven项目坐标值，如图1-10所示。[m
[31m-[m
[31m-（3）选择存储路径，如图1-11所示。[m
[31m-[m
[31m-          图1-9　新建Maven项目[m
[31m-                                 图1-10　输入坐标值[m
[31m-[m
[31m-                                图1-11　选择存储路径[m
[31m-[m
[31m-     （4）修改pom.xml文件，使用上例的pom.xml文件内容，[m
[31m-IDEA会开启自动导入Maven依赖包功能，如图1-12所示。[m
[31m-                   图1-12　开启自动导入Maven功能[m
[31m-[m
[31m-（5）依赖树查看，如图1-13所示。[m
[31m-                                 图1-13　依赖树查看[m
[31m-[m
[31m-     3.基于NetBeans搭建[m
[31m-[m
[31m-     NetBeans是Oracle官方推出的Java开发工具，下载地址如[m
[31m-下：https://netbeans.org/downloads/。[m
[31m-[m
[31m-     （1）新建Maven项目，如图1-14所示。[m
[31m-                         图1-14　新建Maven项目[m
[31m-[m
[31m-（2）输入Maven坐标，如图1-15所示。[m
[31m-[m
[31m-                         图1-15　输入Maven坐标[m
[31m-[m
[31m-（3）更新pom.xml，如图1-16所示。[m
[31m-                          图1-16　更新pom.xml[m
[31m-[m
[31m-（4）依赖树查看，如图1-17所示。[m
[31m-图1-17　依赖树查看[m
[31m-1.3　Spring基础配置[m
[31m-[m
[31m-     Spring框架本身有四大原则：[m
[31m-[m
[31m-     1）使用POJO进行轻量级和最小侵入式开发。[m
[31m-[m
[31m-     2）通过依赖注入和基于接口编程实现松耦合。[m
[31m-[m
[31m-     3）通过AOP和默认习惯进行声明式编程。[m
[31m-[m
[31m-     4）使用AOP和模板（template）减少模式化代码。[m
[31m-[m
[31m-     Spring所有功能的设计和实现都是基于此四大原则的。[m
[31m-[m
[31m-1.3.1　依赖注入[m
[31m-[m
[31m-     1.点睛[m
[31m-[m
[31m-     我们经常说的控制翻转（Inversion of Control-IOC）和依赖[m
[31m-注入（dependency injection-DI）在Spring环境下是等同的概[m
[31m-念，控制翻转是通过依赖注入实现的。所谓依赖注入指的是容[m
[31m-器负责创建对象和维护对象间的依赖关系，而不是通过对象本[m
[31m-身负责自己的创建和解决自己的依赖。[m
[31m-[m
[31m-     依赖注入的主要目的是为了解耦，体现了一种“组合”的理[m
[31m-念。如果你希望你的类具备某项功能的时候，是继承自一个具[m
[31m-有此功能的父类好呢？还是组合另外一个具有这个功能的类好[m
[31m-呢？答案是不言而喻的，继承一个父类，子类将与父类耦合，[m
[31m-组合另外一个类则使耦合度大大降低。[m
[31m-     Spring IoC容器（ApplicationContext）负责创建Bean，并通[m
[31m-过容器将功能类Bean注入到你需要的Bean中。Spring提供使用[m
[31m-xml、注解、Java配置、groovy配置实现Bean的创建和注入。[m
[31m-[m
[31m-     无论是xml配置、注解配置还是Java配置，都被称为配置元[m
[31m-数据，所谓元数据即描述数据的数据。元数据本身不具备任何[m
[31m-可执行的能力，只能通过外界代码来对这些元数据行解析后进[m
[31m-行一些有意义操作。Spring容器解析这些配置元数据进行Bean[m
[31m-初始化、配置和管理依赖。[m
[31m-[m
[31m-     声明Bean的注解：[m
[31m-[m
[31m-     @Component组件，没有明确的角色。[m
[31m-     @Service在业务逻辑层（service层）使用。[m
[31m-     @Repository在数据访问层（dao层）使用。[m
[31m-     @Controller在展现层（MVC→Spring MVC）使用。[m
[31m-[m
[31m-     注入Bean的注解，一般情况下通用。[m
[31m-[m
[31m-     @Autowired：Spring提供的注解。[m
[31m-     @Inject：JSR-330提供的注解。[m
[31m-     @Resource：JSR-250提供的注解。[m
[31m-[m
[31m-     @Autowired、@Inject、@Resource可注解在set方法上或者[m
[31m-属性上，笔者习惯注解在属性上，优点是代码更少、层次更清[m
[31m-晰。[m
[31m-[m
[31m-     在本节演示基于注解的Bean的初始化和依赖注入，Spring[m
[31m-容器类选用AnnotationConfigApplicationContext。[m
[31m-[m
[31m-     2.示例[m
[31m-     （1）编写功能类的Bean。[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch1.di;[m
[31m-       import org.springframework.stereotype.Service;[m
[31m-       @Service //1[m
[31m-       public class FunctionService {[m
[31m-[m
[31m-              public String sayHello(String word){[m
[31m-                      return "Hello " + word +" !";[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①使用@Service注解声明当前FunctionService类是Spring管[m
[31m-理的一个Bean。其中，使用@Component、@Service、[m
[31m-@Repository和@Controller是等效的，可根据需要选用。[m
[31m-[m
[31m-     （2）使用功能类的Bean。[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch1.di;[m
[31m-[m
[31m-       import org.springframework.beans.factory.annotation.Autowired;[m
[31m-       import org.springframework.stereotype.Service;[m
[31m-       @Service //1[m
[31m-       public class UseFunctionService {[m
[31m-[m
[31m-              @Autowired //2[m
[31m-              FunctionService functionService;[m
[31m-[m
[31m-              public String SayHello(String word){[m
[31m-                      return functionService.sayHello(word);[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-     ①使用@Service注解声明当前UseFunctionService类是[m
[31m-Spring管理的一个Bean。[m
[31m-[m
[31m-     ②使用@Autowired将FunctionService的实体Bean注入到[m
[31m-UseFunctionService中，让UseFunctionService具备[m
[31m-FunctionService的功能，此处使用JSR-330的@Inject注解或者[m
[31m-JSR-250的@Resource注解是等效的。[m
[31m-[m
[31m-     （3）配置类。[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch1.di;[m
[31m-       import org.springframework.context.annotation.ComponentScan;[m
[31m-       import org.springframework.context.annotation.Configuration;[m
[31m-       @Configuration //1[m
[31m-       @ComponentScan("com.wisely.highlight_spring4.ch1.di") //2[m
[31m-       public class DiConfig {[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①@Configuration声明当前类是一个配置类，在后面1.3.2[m
[31m-节的Java配置中有更详细的说明；[m
[31m-[m
[31m-     ②使用@ComponentScan，自动扫描包名下所有使用[m
[31m-@Service、@Component、@Repository和@Controller的类，并[m
[31m-注册为Bean。[m
[31m-[m
[31m-     （4）运行。[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch1.di;[m
[31m-       import org.springframework.context.annotation.AnnotationConfigApplicati[m
[31m-       public class Main {[m
[31m-[m
[31m-              public static void main(String[] args) {[m
[31m-                       AnnotationConfigApplicationContext context =[m
[31m-                                          new AnnotationConfigApplicationContext(DiConfig.clas[m
[31m-       UseFunctionService useFunctionService = context.getBean(UseFunctionServ[m
[31m-[m
[31m-                       System.out.println(useFunctionService.SayHello("di"));[m
[31m-                      context.close();[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-     ①使用AnnotationConfigApplicationContext作为Spring容[m
[31m-器，接受输入一个配置类作为参数；[m
[31m-     ②获得声明配置的UseFunctionService的Bean。[m
[31m-     结果如图1-18所示。[m
[31m-[m
[31m-                                   图1-18　运行结果[m
[31m-[m
[31m-1.3.2　Java配置[m
[31m-[m
[31m-     1.点睛[m
[31m-     Java配置是Spring 4.x推荐的配置方式，可以完全替代xml[m
[31m-配置；Java配置也是Spring Boot推荐的配置方式。[m
[31m-[m
[31m-     Java配置是通过@Configuration和@Bean来实现的。[m
[31m-[m
[31m-     @Configuration声明当前类是一个配置类，相当于一个[m
[31m-     Spring配置的xml文件。[m
[31m-     @Bean注解在方法上，声明当前方法的返回值为一个[m
[31m-     Bean。[m
[31m-[m
[31m-     本书通篇使用Java配置和注解混合配置。何时使用Java配[m
[31m-置或者注解配置呢？我们主要的原则是：全局配置使用Java配[m
[31m-置（如数据库相关配置、MVC相关配置），业务Bean的配置[m
[31m-使用注解配置（@Service、@Component、@Repository、[m
[31m-@Controlle）。[m
[31m-[m
[31m-     本节只演示简单的Java配置，全书各个章节都会有大量的[m
[31m-Java配置的内容。[m
[31m-[m
[31m-     2.示例[m
[31m-[m
[31m-     （1）编写功能类的Bean。[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch1.javaconfig;[m
[31m-       //1[m
[31m-       public class FunctionService {[m
[31m-[m
[31m-              public String sayHello(String word){[m
[31m-                      return "Hello " + word +" !";[m
[31m-[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①此处没有使用@Service声明Bean。[m
[31m-（2）使用功能类的Bean。[m
[31m-[m
[31m-package com.wisely.highlight_spring4.ch1.javaconfig;[m
[31m-[m
[31m-import com.wisely.highlight_spring4.ch1.javaconfig.FunctionService;[m
[31m-//1[m
[31m-public class UseFunctionService {[m
[31m-[m
[31m-       //2[m
[31m-       FunctionService functionService;[m
[31m-[m
[31m-       public void setFunctionService(FunctionService functionService) {[m
[31m-              this.functionService = functionService;[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-       public String SayHello(String word){[m
[31m-              return functionService.sayHello(word);[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-}[m
[31m-[m
[31m-代码解释[m
[31m-[m
[31m-①此处没有使用@Service声明Bean。[m
[31m-[m
[31m-②此处没有使用@Autowired注解注入Bean。[m
[31m-[m
[31m-（3）配置类。[m
[31m-[m
[31m-package com.wisely.highlight_spring4.ch1.javaconfig;[m
[31m-[m
[31m-import org.springframework.context.annotation.Bean;[m
[31m-import org.springframework.context.annotation.Configuration;[m
[31m-[m
[31m-@Configuration //1[m
[31m-public class JavaConfig {[m
[31m-[m
[31m-       @Bean //2[m
[31m-       public FunctionService functionService(){[m
[31m-[m
[31m-              return new FunctionService();[m
[31m-       }[m
[31m-              @Bean[m
[31m-              public UseFunctionService useFunctionService(){[m
[31m-[m
[31m-                      UseFunctionService useFunctionService = new UseFunctionService([m
[31m-                      useFunctionService.setFunctionService(functionService());//3[m
[31m-                      return useFunctionService;[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-       // @Bean[m
[31m-       // public UseFunctionService useFunctionService(FunctionService functi[m
[31m-       { //4[m
[31m-       // UseFunctionService useFunctionService = new UseFunctionService([m
[31m-       // useFunctionService.setFunctionService(functionService);[m
[31m-       // return useFunctionService;[m
[31m-       // }[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①使用@Configuration注解表明当前类是一个配置类，这[m
[31m-意味着这个类里可能有0个或者多个@Bean注解，此处没有使[m
[31m-用包扫描，是因为所有的Bean都在此类中定义了。[m
[31m-[m
[31m-     ②使用@Bean注解声明当前方法FunctionService的返回值[m
[31m-是一个Bean，Bean的名称是方法名。[m
[31m-[m
[31m-     ③注入FunctionService的Bean时候直接调用[m
[31m-functionService（）。[m
[31m-[m
[31m-     ④另外一种注入的方式，直接将FunctionService作为参数[m
[31m-给useFunctionService（），这也是Spring容器提供的极好的功[m
[31m-能。在Spring容器中，只要容器中存在某个Bean，就可以在另[m
[31m-外一个Bean的声明方法的参数中写入。[m
[31m-[m
[31m-     （4）运行。[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch1.javaconfig;[m
[31m-       import org.springframework.context.annotation.AnnotationConfigApplicati[m
[31m-       public class Main {[m
[31m-[m
[31m-              public static void main(String[] args) {[m
[31m-                       AnnotationConfigApplicationContext context =[m
[31m-                                           new AnnotationConfigApplicationContext(JavaConfig.c[m
[31m-                       UseFunctionService useFunctionService = context.getBean(UseFun[m
[31m-                       System.out.println(useFunctionService.SayHello("java config"))[m
[31m-                       context.close();[m
[31m-[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     结果如图1-19所示。[m
[31m-[m
[31m-                                   图1-19　运行结果[m
[31m-[m
[31m-1.3.3　AOP[m
[31m-[m
[31m-     1.点睛[m
[31m-     AOP：面向切面编程，相对于OOP面向对象编程。[m
[31m-     Spring的AOP的存在目的是为了解耦。AOP可以让一组类[m
[31m-共享相同的行为。在OOP中只能通过继承类和实现接口，来使[m
[31m-代码的耦合度增强，且类继承只能为单继承，阻碍更多行为添[m
[31m-加到一组类上，AOP弥补了OOP的不足。[m
[31m-[m
[31m-     Spring支持AspectJ的注解式切面编程。[m
[31m-[m
[31m-     （1）使用@Aspect声明是一个切面。[m
[31m-[m
[31m-     （2）使用@After、@Before、@Around定义建言[m
[31m-（advice），可直接将拦截规则（切点）作为参数。[m
[31m-[m
[31m-     （3）其中@After、@Before、@Around参数的拦截规则为[m
[31m-切点（PointCut），为了使切点复用，可使用@PointCut专门定[m
[31m-义拦截规则，然后在@After、@Before、@Around的参数中调[m
[31m-用。[m
[31m-[m
[31m-     （4）其中符合条件的每一个被拦截处为连接点[m
[31m-（JoinPoint）。[m
[31m-[m
[31m-     本节示例将演示基于注解拦截和基于方法规则拦截两种方[m
[31m-式，演示一种模拟记录操作的日志系统的实现。其中注解式拦[m
[31m-截能够很好地控制要拦截的粒度和获得更丰富的信息，Spring[m
[31m-本身在事务处理（@Transcational）和数据缓存（@Cacheable[m
[31m-等）上面都使用此种形式的拦截。[m
[31m-[m
[31m-     2.示例[m
[31m-[m
[31m-     （1）添加spring aop支持及AspectJ依赖。[m
[31m-[m
[31m-                      <!-- spring aop[m
[31m-[m
[31m-       支持 -->[m
[31m-                      <dependency>[m
[31m-                     <groupId>org.springframework</groupId>[m
[31m-                     <artifactId>spring-aop[m
[31m-[m
[31m-</artifactId>[m
[31m-                     <version>4.1.6.RELEASE</version>[m
[31m-[m
[31m-              </dependency>[m
[31m-              <!-- aspectj[m
[31m-[m
[31m-支持 -->[m
[31m-              <dependency>[m
[31m-                     <groupId>org.aspectj</groupId>[m
[31m-                     <artifactId>aspectjrt</artifactId>[m
[31m-                     <version>1.8.5</version>[m
[31m-              </dependency>[m
[31m-              <dependency>[m
[31m-                     <groupId>org.aspectj</groupId>[m
[31m-                     <artifactId>aspectjweaver[m
[31m-[m
[31m-</artifactId>[m
[31m-                     <version>1.8.5</version>[m
[31m-[m
[31m-              </dependency>[m
[31m-[m
[31m-（2）编写拦截规则的注解。[m
[31m-[m
[31m-package com.wisely.highlight_spring4.ch1.aop;[m
[31m-import java.lang.annotation.Documented;[m
[31m-import java.lang.annotation.ElementType;[m
[31m-import java.lang.annotation.Retention;[m
[31m-import java.lang.annotation.RetentionPolicy;[m
[31m-import java.lang.annotation.Target;[m
[31m-       @Target(ElementType.METHOD)[m
[31m-       @Retention(RetentionPolicy.RUNTIME)[m
[31m-       @Documented[m
[31m-       public @interface Action {[m
[31m-[m
[31m-              String name();[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     这里讲下注解，注解本身是没有功能的，就和xml一样。[m
[31m-注解和xml都是一种元数据，元数据即解释数据的数据，这就[m
[31m-是所谓配置。[m
[31m-[m
[31m-     注解的功能来自用这个注解的地方。[m
[31m-[m
[31m-     （3）编写使用注解的被拦截类。[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch1.aop;[m
[31m-[m
[31m-       import org.springframework.stereotype.Service;[m
[31m-[m
[31m-       @Service[m
[31m-       public class DemoAnnotationService {[m
[31m-[m
[31m-              @Action(name="注解式拦截的add操作")[m
[31m-              public void add(){}[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     （4）编写使用方法规则被拦截类。[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch1.aop;[m
[31m-       import org.springframework.stereotype.Service;[m
[31m-       @Service[m
[31m-       public class DemoMethodService {[m
[31m-[m
[31m-              public void add(){}[m
[31m-}[m
[31m-[m
[31m-（5）编写切面。[m
[31m-[m
[31m-package com.wisely.highlight_spring4.ch1.aop;[m
[31m-[m
[31m-import java.lang.reflect.Method;[m
[31m-[m
[31m-import org.aspectj.lang.JoinPoint;[m
[31m-import org.aspectj.lang.annotation.After;[m
[31m-import org.aspectj.lang.annotation.Aspect;[m
[31m-import org.aspectj.lang.annotation.Before;[m
[31m-import org.aspectj.lang.annotation.Pointcut;[m
[31m-import org.aspectj.lang.reflect.MethodSignature;[m
[31m-import org.springframework.stereotype.Component;[m
[31m-[m
[31m-@Aspect //1[m
[31m-@Component //2[m
[31m-public class LogAspect {[m
[31m-[m
[31m-       @Pointcut("@annotation(com.wisely.highlight_spring4.ch1.aop.Action)[m
[31m-       public void annotationPointCut(){};[m
[31m-[m
[31m-          @After("annotationPointCut()") //4[m
[31m-              public void after(JoinPoint joinPoint) {[m
[31m-                     MethodSignature signature = (MethodSignature) joinPoint.get[m
[31m-                     Method method = signature.getMethod();[m
[31m-                     Action action = method.getAnnotation(Action.class);[m
[31m-                                                              System.out.println("注解式拦[m
[31m-[m
[31m-截 " + action.name()); //5[m
[31m-              }[m
[31m-[m
[31m-            @Before("execution(* com.wisely.highlight_spring4.ch1.aop.DemoMe[m
[31m-(..))") //6[m
[31m-[m
[31m-              public void before(JoinPoint joinPoint){[m
[31m-                     MethodSignature signature = (MethodSignature) joinPoint.get[m
[31m-                     Method method = signature.getMethod();[m
[31m-                                                        System.out.println("方法规则式拦[m
[31m-[m
[31m-截,"+method.getName());[m
[31m-              }[m
[31m-[m
[31m-}[m
[31m-     代码解释[m
[31m-[m
[31m-     ①通过@Aspect注解声明一个切面。[m
[31m-[m
[31m-     ②通过@Component让此切面成为Spring容器管理的Bean。[m
[31m-[m
[31m-     ③通过@PointCut注解声明切点。[m
[31m-[m
[31m-     ④通过@After注解声明一个建言，并使用@PointCut定义[m
[31m-的切点。[m
[31m-[m
[31m-     ⑤通过反射可获得注解上的属性，然后做日志记录相关的[m
[31m-操作，下面的相同。[m
[31m-[m
[31m-     ⑥通过@Before注解声明一个建言，此建言直接使用拦截[m
[31m-规则作为参数。[m
[31m-[m
[31m-     （6）配置类。[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch1.aop;[m
[31m-[m
[31m-       import org.springframework.context.annotation.ComponentScan;[m
[31m-       import org.springframework.context.annotation.Configuration;[m
[31m-       import org.springframework.context.annotation.EnableAspectJAutoProxy;[m
[31m-[m
[31m-       @Configuration[m
[31m-       @ComponentScan("com.wisely.highlight_spring4.ch1.aop")[m
[31m-       @EnableAspectJAutoProxy //1[m
[31m-       public class AopConfig {[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①使用@EnableAspectJAutoProxy注解开启Spring对AspectJ[m
[31m-代理的支持。[m
[31m-（7）运行。[m
[31m-[m
[31m-package com.wisely.highlight_spring4.ch1.aop;[m
[31m-import org.springframework.context.annotation.AnnotationConfigApplicati[m
[31m-public class Main {[m
[31m-[m
[31m-       public static void main(String[] args) {[m
[31m-                AnnotationConfigApplicationContext context =[m
[31m-                                    new AnnotationConfigApplicationContext(AopConfig.cl[m
[31m-                DemoAnnotationService demoAnnotationService = context.getBean([m
[31m-                DemoMethodService demoMethodService = context.getBean(DemoMeth[m
[31m-                demoAnnotationService.add();[m
[31m-                demoMethodService.add();[m
[31m-                context.close();[m
[31m-[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-结果如图1-20所示。[m
[31m-[m
[31m-                             图1-20　运行结果[m
[31m-第2章　Spring常用配置[m
[31m-[m
[31m-2.1　Bean的Scope[m
[31m-[m
[31m-2.1.1　点睛[m
[31m-[m
[31m-     Scope描述的是Spring容器如何新建Bean的实例的。Spring[m
[31m-的Scope有以下几种，通过@Scope注解来实现。[m
[31m-[m
[31m-     （1）Singleton：一个Spring容器中只有一个Bean的实例，[m
[31m-此为Spring的默认配置，全容器共享一个实例。[m
[31m-[m
[31m-（2）Prototype：每次调用新建一个Bean的实例。[m
[31m-[m
[31m-     （3）Request：Web项目中，给每一个http request新建一个[m
[31m-Bean实例。[m
[31m-[m
[31m-     （4）Session：Web项目中，给每一个http session新建一个[m
[31m-Bean实例。[m
[31m-[m
[31m-     （5）GlobalSession：这个只在portal应用中有用，给每一[m
[31m-个global http session新建一个Bean实例。[m
[31m-[m
[31m-另外，在Spring      Batch中还有一个Scope是使用[m
[31m-[m
[31m-@StepScope，我们将在批处理一节介绍这个Scope。[m
[31m-[m
[31m-     本例简单演示默认的singleton和Prototype，分别从Spring容[m
[31m-器中获得2次Bean，判断Bean的实例是否相等。[m
[31m-2.1.2　示例[m
[31m-[m
[31m-     （1）编写Singleton的Bean。[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch2.scope;[m
[31m-       import org.springframework.stereotype.Service;[m
[31m-       @Service //1[m
[31m-       public class DemoSingletonService {[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-     ①默认为Singleton，相当于@Scope（“singleton”）。[m
[31m-     （2）编写Prototype的Bean。[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch2.scope;[m
[31m-       import org.springframework.context.annotation.Scope;[m
[31m-       import org.springframework.stereotype.Service;[m
[31m-       @Service[m
[31m-       @Scope("prototype")//1[m
[31m-       public class DemoPrototypeService {[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-     ①声明Scope为Prototype。[m
[31m-（3）配置类。[m
[31m-[m
[31m-package com.wisely.highlight_spring4.ch2.scope;[m
[31m-import org.springframework.context.annotation.ComponentScan;[m
[31m-import org.springframework.context.annotation.Configuration;[m
[31m-@Configuration[m
[31m-@ComponentScan("com.wisely.highlight_spring4.ch2.scope")[m
[31m-public class ScopeConfig {[m
[31m-}[m
[31m-[m
[31m-（4）运行。[m
[31m-[m
[31m-package com.wisely.highlight_spring4.ch2.scope;[m
[31m-import org.springframework.context.annotation.AnnotationConfigApplicati[m
[31m-public class Main {[m
[31m-[m
[31m-       public static void main(String[] args) {[m
[31m-              AnnotationConfigApplicationContext context =[m
[31m-                             new AnnotationConfigApplicationContext(ScopeConfig.clas[m
[31m-[m
[31m-DemoSingletonService s1 = context.getBean(DemoSingletonService.class);[m
[31m-              DemoSingletonService s2 = context.getBean(DemoSingletonService.[m
[31m-              DemoPrototypeService p1 = context.getBean(DemoPrototypeService.[m
[31m-              DemoPrototypeService p2 = context.getBean(DemoPrototypeService.[m
[31m-              System.out.println("s1与s2是否相等："+s1.equals(s2));[m
[31m-              System.out.println("p1与p2是否相等："+p1.equals(p2));[m
[31m-              context.close();[m
[31m-[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-结果如图2-1所示。[m
[31m-图2-1　运行结果[m
[31m-2.2　Spring EL和资源调用[m
[31m-[m
[31m-2.2.1　点睛[m
[31m-[m
[31m-     Spring EL-Spring表达式语言，支持在xml和注解中使用表[m
[31m-达式，类似于JSP的EL表达式语言。[m
[31m-[m
[31m-     Spring开发中经常涉及调用各种资源的情况，包含普通文[m
[31m-件、网址、配置文件、系统环境变量等，我们可以使用Spring[m
[31m-的表达式语言实现资源的注入。[m
[31m-[m
[31m-     Spring主要在注解@Value的参数中使用表达式。[m
[31m-     本节演示实现以下几种情况：[m
[31m-     （1）注入普通字符；[m
[31m-     （2）注入操作系统属性；[m
[31m-     （3）注入表达式运算结果；[m
[31m-     （4）注入其他Bean的属性；[m
[31m-     （5）注入文件内容；[m
[31m-     （6）注入网址内容；[m
[31m-     （7）注入属性文件。[m
[31m-[m
[31m-2.2.2　示例[m
[31m-     （1）准备，增加commons-io可简化文件相关操作，本例[m
[31m-中使用commons-io将file转换成字符串：[m
[31m-[m
[31m-       <dependency>[m
[31m-                             <groupId>commons-io</groupId>[m
[31m-                             <artifactId>commons-io</artifactId>[m
[31m-                             <version>2.3</version>[m
[31m-[m
[31m-                      </dependency>[m
[31m-[m
[31m-     在com.wisely.highlight_spring4.ch2.el包下新建test.txt，内容[m
[31m-随意。[m
[31m-[m
[31m-     在com.wisely.highlight_spring4.ch2.el包下新建[m
[31m-test.properties，内容如下：[m
[31m-[m
[31m-       book.author=wangyunfei[m
[31m-       book.name=spring boot[m
[31m-[m
[31m-     （2）需被注入的Bean。[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch2.el;[m
[31m-[m
[31m-       import org.springframework.beans.factory.annotation.Value;[m
[31m-       import org.springframework.stereotype.Service;[m
[31m-[m
[31m-       @Service[m
[31m-       public class DemoService {[m
[31m-[m
[31m-              @Value("其他类的属性") //1[m
[31m-              private String another;[m
[31m-[m
[31m-              public String getAnother() {[m
[31m-                      return another;[m
[31m-[m
[31m-              }[m
[31m-              public void setAnother(String another) {[m
[31m-[m
[31m-                      this.another = another;[m
[31m-              }[m
[31m-}[m
[31m-[m
[31m-代码解释[m
[31m-[m
[31m-①此处为注入普通字符串[m
[31m-[m
[31m-（3）演示配置类。[m
[31m-[m
[31m-package com.wisely.highlight_spring4.ch2.el;[m
[31m-[m
[31m-import org.apache.commons.io.IOUtils;[m
[31m-import org.springframework.beans.factory.annotation.Autowired;[m
[31m-import org.springframework.beans.factory.annotation.Value;[m
[31m-import org.springframework.context.annotation.Bean;[m
[31m-import org.springframework.context.annotation.ComponentScan;[m
[31m-import org.springframework.context.annotation.Configuration;[m
[31m-import org.springframework.context.annotation.PropertySource;[m
[31m-import org.springframework.context.support.PropertySourcesPlaceholderCo[m
[31m-import org.springframework.core.env.Environment;[m
[31m-import org.springframework.core.io.Resource;[m
[31m-[m
[31m-@Configuration[m
[31m-@ComponentScan("com.wisely.highlight_spring4.ch2.el")[m
[31m-@PropertySource("classpath:com/wisely/highlight_spring4/ch2/el/test.pro[m
[31m-public class ElConfig {[m
[31m-[m
[31m-       @Value("I Love You!") //1[m
[31m-       private String normal;[m
[31m-[m
[31m-       @Value("#{systemProperties['os.name']}") //2[m
[31m-       private String osName;[m
[31m-[m
[31m-       @Value("#{ T(java.lang.Math).random() * 100.0 }") //3[m
[31m-       private double randomNumber;[m
[31m-[m
[31m-       @Value("#{demoService.another}") //4[m
[31m-       private String fromAnother;[m
[31m-[m
[31m-       @Value("classpath:com/wisely/highlight_spring4/ch2/el/test.txt") //[m
[31m-       private Resource testFile;[m
[31m-[m
[31m-       @Value("http://www.baidu.com") //6[m
[31m-       private Resource testUrl;[m
[31m-[m
[31m-       @Value("${book.name}") //7[m
[31m-       private String bookName;[m
[31m-[m
[31m-       @Autowired[m
[31m-       private Environment environment; //7[m
[31m-[m
[31m-       @Bean //7[m
[31m-       public static PropertySourcesPlaceholderConfigurer propertyConfigur[m
[31m-[m
[31m-              return new PropertySourcesPlaceholderConfigurer();[m
[31m-       }[m
[31m-[m
[31m-       public void outputResource() {[m
[31m-              try {[m
[31m-                     System.out.println(normal);[m
[31m-                     System.out.println(osName);[m
[31m-                     System.out.println(randomNumber);[m
[31m-                     System.out.println(fromAnother);[m
[31m-[m
[31m-                     System.out.println(IOUtils.toString(testFile.getInputStream[m
[31m-                     System.out.println(IOUtils.toString(testUrl.getInputStream([m
[31m-                     System.out.println(bookName);[m
[31m-                     System.out.println(environment.getProperty("book.author"));[m
[31m-              } catch (Exception e) {[m
[31m-                     e.printStackTrace();[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-}[m
[31m-[m
[31m-代码解释[m
[31m-[m
[31m-①注入普通字符串。[m
[31m-[m
[31m-②注入操作系统属性。[m
[31m-[m
[31m-③注入表达式结果。[m
[31m-[m
[31m-④注入其他Bean属性。[m
[31m-     ⑤注入文件资源。[m
[31m-[m
[31m-     ⑥注入网址资源。[m
[31m-[m
[31m-     ⑦注入配置文件。[m
[31m-[m
[31m-     注入配置配件需使用@PropertySource指定文件地址，若使[m
[31m-用@Value注入，则要配置一个[m
[31m-PropertySourcesPlaceholderConfigurer的Bean。注意，[m
[31m-@Value（"${book.name}"）使用的是“$”，而不是“#”。[m
[31m-[m
[31m-     注入Properties还可从Environment中获得。[m
[31m-[m
[31m-     （4）运行。[m
[31m-[m
[31m-package com.wisely.highlight_spring4.ch2.el;[m
[31m-[m
[31m-import org.springframework.context.annotation.AnnotationConfigApplicati[m
[31m-[m
[31m-public class Main {[m
[31m-[m
[31m-public static void main(String[] args) {[m
[31m-         AnnotationConfigApplicationContext context =[m
[31m-                             new AnnotationConfigApplicationContext(ResourceConf[m
[31m-[m
[31m-          ElConfig resourceService = context.getBean(ElConfig.class);[m
[31m-[m
[31m-          resourceService.outputResource();[m
[31m-[m
[31m-          context.close();[m
[31m-[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-结果如图2-2所示。[m
[31m-图2-2　运行结果[m
[31m-2.3　Bean的初始化和销毁[m
[31m-[m
[31m-2.3.1　点睛[m
[31m-[m
[31m-     在我们实际开发的时候，经常会遇到在Bean在使用之前或[m
[31m-者之后做些必要的操作，Spring对Bean的生命周期的操作提供[m
[31m-了支持。在使用Java配置和注解配置下提供如下两种方式：[m
[31m-[m
[31m-     （1）Java配置方式：使用@Bean的initMethod和[m
[31m-destroyMethod（相当于xml配置的init-method和destory-[m
[31m-method）。[m
[31m-[m
[31m-     （2）注解方式：利用JSR-250的@PostConstruct和[m
[31m-@PreDestroy。[m
[31m-[m
[31m-2.3.2　演示[m
[31m-[m
[31m-     （1）增加JSR250支持。[m
[31m-[m
[31m-       <dependency>[m
[31m-                             <groupId>javax.annotation</groupId>[m
[31m-                             <artifactId>jsr250-api[m
[31m-[m
[31m-       </artifactId>[m
[31m-                             <version>1.0</version>[m
[31m-[m
[31m-                      </dependency>[m
[31m-（2）使用@Bean形式的Bean。[m
[31m-[m
[31m-package com.wisely.highlight_spring4.ch2.prepost;[m
[31m-[m
[31m-public class BeanWayService {[m
[31m-[m
[31m-   public void init(){[m
[31m-[m
[31m-      System.out.println("@Bean-init-method");[m
[31m-[m
[31m-   }[m
[31m-[m
[31m-   public BeanWayService() {[m
[31m-[m
[31m-      super();[m
[31m-[m
[31m-                        System.out.println("初始化构造函数-[m
[31m-[m
[31m-BeanWayService");[m
[31m-[m
[31m-   }[m
[31m-[m
[31m-   public void destroy(){[m
[31m-[m
[31m-      System.out.println("@Bean-destory-method");[m
[31m-[m
[31m-   }[m
[31m-[m
[31m-}[m
[31m-[m
[31m-（3）使用JSR250形式的Bean。[m
[31m-[m
[31m-package com.wisely.highlight_spring4.ch2.prepost;[m
[31m-[m
[31m-import javax.annotation.PostConstruct;[m
[31m-import javax.annotation.PreDestroy;[m
[31m-[m
[31m-public class JSR250WayService {[m
[31m-       @PostConstruct //1[m
[31m-       public void init(){[m
[31m-              System.out.println("jsr250-init-method");[m
[31m-       }[m
[31m-       public JSR250WayService() {[m
[31m-              super();[m
[31m-              System.out.println("初始化构造函数-JSR250WayService");[m
[31m-       }[m
[31m-       @PreDestroy //2[m
[31m-       public void destroy(){[m
[31m-              System.out.println("jsr250-destory-method");[m
[31m-       }[m
[31m-[m
[31m-}[m
[31m-     代码解释[m
[31m-[m
[31m-     ①@PostConstruct，在构造函数执行完之后执行。[m
[31m-[m
[31m-     ②@PreDestroy，在Bean销毁之前执行。[m
[31m-[m
[31m-     （4）配置类。[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch2.prepost;[m
[31m-[m
[31m-       import org.springframework.context.annotation.Bean;[m
[31m-       import org.springframework.context.annotation.ComponentScan;[m
[31m-       import org.springframework.context.annotation.Configuration;[m
[31m-[m
[31m-       @Configuration[m
[31m-       @ComponentScan("com.wisely.highlight_spring4.ch2.prepost")[m
[31m-       public class PrePostConfig {[m
[31m-[m
[31m-              @Bean(initMethod="init",destroyMethod="destroy") //1[m
[31m-              BeanWayService beanWayService(){[m
[31m-[m
[31m-                      return new BeanWayService();[m
[31m-              }[m
[31m-[m
[31m-              @Bean[m
[31m-              JSR250WayService jsr250WayService(){[m
[31m-[m
[31m-                      return new JSR250WayService();[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①initMethod和destroyMethod指定BeanWayService类的init[m
[31m-和destroy方法在构造之后、Bean销毁之前执行。[m
[31m-[m
[31m-     （5）运行。[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch2.prepost;[m
[31m-import org.springframework.context.annotation.AnnotationConfigApplicati[m
[31m-public class Main {[m
[31m-[m
[31m-       public static void main(String[] args) {[m
[31m-              AnnotationConfigApplicationContext context =[m
[31m-                             new AnnotationConfigApplicationContext(PrePostConfig.cl[m
[31m-              BeanWayService beanWayService = context.getBean(BeanWayService.[m
[31m-              JSR250WayService jsr250WayService = context.getBean(JSR250WaySe[m
[31m-              context.close();[m
[31m-[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-结果如图2-3所示。[m
[31m-[m
[31m-                              图2-3　运行结果[m
[31m-2.4　Profile[m
[31m-[m
[31m-2.4.1　点睛[m
[31m-[m
[31m-     Profile为在不同环境下使用不同的配置提供了支持（开发[m
[31m-环境下的配置和生产环境下的配置肯定是不同的，例如，数据[m
[31m-库的配置）。[m
[31m-[m
[31m-     （1）通过设定Environment的ActiveProfiles来设定当前[m
[31m-context需要使用的配置环境。在开发中使用@Profile注解类或[m
[31m-者方法，达到在不同情况下选择实例化不同的Bean。[m
[31m-[m
[31m-     （2）通过设定jvm的spring.profiles.active参数来设置配置[m
[31m-环境。[m
[31m-[m
[31m-     （3）Web项目设置在Servlet的context parameter中。[m
[31m-[m
[31m-     Servlet 2.5及以下：[m
[31m-[m
[31m-       <servlet>[m
[31m-                       <servlet-name>dispatcher</servlet-name> <servlet-[m
[31m-[m
[31m-       class>org.springframework.web.servlet.DispatcherServlet</servlet-[m
[31m-       class>[m
[31m-[m
[31m-              <init-param>[m
[31m-                      <param-name>spring.profiles.active</param-name>[m
[31m-                      <param-value>production</param-value>[m
[31m-[m
[31m-              </init-param>[m
[31m-       </servlet>[m
[31m-[m
[31m-     Servlet 3.0及以上：[m
[31m-       public class WebInit implements WebApplicationInitializer {[m
[31m-              @Override[m
[31m-              public void onStartup(ServletContext container) throws ServletExcep[m
[31m-                      container.setInitParameter("spring.profiles.default", "dev");[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-2.4.2　演示[m
[31m-[m
[31m-     （1）示例Bean。[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch2.profile;[m
[31m-[m
[31m-       public class DemoBean {[m
[31m-              private String content;[m
[31m-              public DemoBean(String content) {[m
[31m-                      super();[m
[31m-                      this.content = content;[m
[31m-              }[m
[31m-              public String getContent() {[m
[31m-                      return content;[m
[31m-              }[m
[31m-              public void setContent(String content) {[m
[31m-                      this.content = content;[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     （2）Profile配置。[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch2.profile;[m
[31m-import org.springframework.context.annotation.Bean;[m
[31m-import org.springframework.context.annotation.Configuration;[m
[31m-import org.springframework.context.annotation.Profile;[m
[31m-[m
[31m-@Configuration[m
[31m-public class ProfileConfig {[m
[31m-[m
[31m-       @Bean[m
[31m-       @Profile("dev") //1[m
[31m-       public DemoBean devDemoBean() {[m
[31m-[m
[31m-              return new DemoBean("from development profile");[m
[31m-       }[m
[31m-[m
[31m-       @Bean[m
[31m-       @Profile("prod") //2[m
[31m-       public DemoBean prodDemoBean() {[m
[31m-[m
[31m-              return new DemoBean("from production profile");[m
[31m-       }[m
[31m-[m
[31m-}[m
[31m-[m
[31m-代码解释[m
[31m-[m
[31m-①Profile为dev时实例化devDemoBean。[m
[31m-[m
[31m-②Profile为prod时实例化prodDemoBean。[m
[31m-[m
[31m-（3）运行。[m
[31m-[m
[31m-package com.wisely.highlight_spring4.ch2.profile;[m
[31m-[m
[31m-import org.springframework.context.annotation.AnnotationConfigApplicati[m
[31m-[m
[31m-public class Main {[m
[31m-[m
[31m-       public static void main(String[] args) {[m
[31m-                  AnnotationConfigApplicationContext context =[m
[31m-                                new AnnotationConfigApplicationContext();[m
[31m-[m
[31m-                  context.getEnvironment().setActiveProfiles("prod"); //1[m
[31m-                  context.register(ProfileConfig.class);//2[m
[31m-                  context.refresh(); //3[m
[31m-          DemoBean demoBean = context.getBean(DemoBean.class);[m
[31m-          System.out.println(demoBean.getContent());[m
[31m-          context.close();[m
[31m-[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-代码解释[m
[31m-①先将活动的Profile设置为prod。[m
[31m-②后置注册Bean配置类，不然会报Bean未定义的错误。[m
[31m-③刷新容器。[m
[31m-结果如图2-4所示。[m
[31m-[m
[31m-                                    图2-4　运行结果[m
[31m-[m
[31m-     将context.getEnvironment（）.setActiveProfiles（“prod”）[m
[31m-修改为context.getEnvironment（）.setActiveProfiles（”dev”），[m
[31m-效果如图2-5所示。[m
[31m-图2-5　修改的效果[m
[31m-2.5　事件（Application Event）[m
[31m-[m
[31m-2.5.1　点睛[m
[31m-[m
[31m-     Spring的事件（Application Event）为Bean与Bean之间的消[m
[31m-息通信提供了支持。当一个Bean处理完一个任务之后，希望另[m
[31m-外一个Bean知道并能做相应的处理，这时我们就需要让另外一[m
[31m-个Bean监听当前Bean所发送的事件。[m
[31m-[m
[31m-     Spring的事件需要遵循如下流程：[m
[31m-     （1）自定义事件，集成ApplicationEvent。[m
[31m-     （2）定义事件监听器，实现ApplicationListener。[m
[31m-     （3）使用容器发布事件。[m
[31m-[m
[31m-2.5.2　示例[m
[31m-[m
[31m-     （1）自定义事件。[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch2.event;[m
[31m-       import org.springframework.context.ApplicationEvent;[m
[31m-       public class DemoEvent extends ApplicationEvent{[m
[31m-[m
[31m-              private static final long serialVersionUID = 1L;[m
[31m-              private String msg;[m
[31m-              public DemoEvent(Object source,String msg) {[m
[31m-              super(source);[m
[31m-              this.msg = msg;[m
[31m-       }[m
[31m-       public String getMsg() {[m
[31m-              return msg;[m
[31m-       }[m
[31m-       public void setMsg(String msg) {[m
[31m-              this.msg = msg;[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-（2）事件监听器。[m
[31m-[m
[31m-package com.wisely.highlight_spring4.ch2.event;[m
[31m-import org.springframework.context.ApplicationListener;[m
[31m-import org.springframework.stereotype.Component;[m
[31m-@Component[m
[31m-public class DemoListener implements ApplicationListener<DemoEvent> {//[m
[31m-[m
[31m-       public void onApplicationEvent(DemoEvent event) {//2[m
[31m-              String msg = event.getMsg();[m
[31m-               System.out.println("我(bean-demoListener)接收到了bean-[m
[31m-[m
[31m-demoPublisher发布的消息:"+ msg);[m
[31m-       }[m
[31m-[m
[31m-}[m
[31m-[m
[31m-代码解释[m
[31m-①实现ApplicationListener接口，并指定监听的事件类型。[m
[31m-②使用onApplicationEvent方法对消息进行接受处理。[m
[31m-（3）事件发布类。[m
[31m-[m
[31m-package com.wisely.highlight_spring4.ch2.event;[m
[31m-[m
[31m-import org.springframework.beans.factory.annotation.Autowired;[m
[31m-import org.springframework.context.ApplicationContext;[m
[31m-import org.springframework.stereotype.Component;[m
[31m-[m
[31m-@Component[m
[31m-public class DemoPublisher {[m
[31m-[m
[31m-       @Autowired[m
[31m-       ApplicationContext applicationContext; //1[m
[31m-[m
[31m-       public void publish(String msg){[m
[31m-              applicationContext.publishEvent(new DemoEvent(this, msg)); //2[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-}[m
[31m-[m
[31m-代码解释[m
[31m-[m
[31m-①注入ApplicationContext用来发布事件。[m
[31m-②使用ApplicationContext的publishEvent方法来发布。[m
[31m-（4）配置类。[m
[31m-[m
[31m-package com.wisely.highlight_spring4.ch2.event;[m
[31m-[m
[31m-import org.springframework.context.annotation.ComponentScan;[m
[31m-import org.springframework.context.annotation.Configuration;[m
[31m-[m
[31m-@Configuration[m
[31m-@ComponentScan("com.wisely.highlight_spring4.ch2.event")[m
[31m-public class EventConfig {[m
[31m-[m
[31m-}[m
[31m-（5）运行。[m
[31m-[m
[31m-package com.wisely.highlight_spring4.ch2.event;[m
[31m-[m
[31m-import org.springframework.context.annotation.AnnotationConfigApplicati[m
[31m-[m
[31m-public class Main {[m
[31m-[m
[31m-public static void main(String[] args) {[m
[31m-         AnnotationConfigApplicationContext context =[m
[31m-                             new AnnotationConfigApplicationContext(EventConfig.[m
[31m-[m
[31m-          DemoPublisher demoPublisher = context.getBean(DemoPublisher.cl[m
[31m-[m
[31m-          demoPublisher.publish("hello application event");[m
[31m-[m
[31m-          context.close();[m
[31m-[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-结果如图2-6所示。[m
[31m-[m
[31m-                     图2-6　运行结果[m
[31m-第3章　Spring高级话题[m
[31m-[m
[31m-3.1　Spring Aware[m
[31m-[m
[31m-3.1.1　点睛[m
[31m-[m
[31m-     Spring的依赖注入的最大亮点就是你所有的Bean对Spring容[m
[31m-器的存在是没有意识的。即你可以将你的容器替换成别的容[m
[31m-器，如Google Guice，这时Bean之间的耦合度很低。[m
[31m-[m
[31m-     但是在实际项目中，你不可避免的要用到Spring容器本身[m
[31m-的功能资源，这时你的Bean必须要意识到Spring容器的存在，[m
[31m-才能调用Spring所提供的资源，这就是所谓的Spring Aware。[m
[31m-其实Spring Aware本来就是Spring设计用来框架内部使用的，[m
[31m-若使用了Spring Aware，你的Bean将会和Spring框架耦合。[m
[31m-[m
[31m-     Spring提供的Aware接口如表3-1所示。[m
[31m-[m
[31m-                          表3-1　Spring提供的Aware接口[m
[31m-[m
[31m-     Spring Aware的目的是为了让Bean获得Spring容器的服务。[m
[31m-因为ApplicationContext接口集成了MessageSource接口、[m
[31m-ApplicationEventPublisher接口和ResourceLoader接口，所以[m
[31m-Bean继承ApplicationContextAware可以获得Spring容器的所有[m
[31m-服务，但原则上我们还是用到什么接口，就实现什么接口。[m
[31m-[m
[31m-3.1.2　示例[m
[31m-[m
[31m-     （1）准备。在com.wisely.highlight_spring4.ch3.aware包下[m
[31m-新建一个test.txt，内容随意，给下面的外部资源加载使用。[m
[31m-[m
[31m-     （2）Spring Aware演示Bean。[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch3.aware;[m
[31m-[m
[31m-       import java.io.IOException;[m
[31m-[m
[31m-       import org.apache.commons.io.IOUtils;[m
[31m-       import org.springframework.beans.factory.BeanNameAware;[m
[31m-       import org.springframework.context.ResourceLoaderAware;[m
[31m-       import org.springframework.core.io.Resource;[m
[31m-       import org.springframework.core.io.ResourceLoader;[m
[31m-       import org.springframework.stereotype.Service;[m
[31m-[m
[31m-       @Service[m
[31m-       public class AwareService implements BeanNameAware,ResourceLoaderAware{[m
[31m-[m
[31m-              private String beanName;[m
[31m-              private ResourceLoader loader;[m
[31m-[m
[31m-              @Override[m
[31m-              public void setResourceLoader(ResourceLoader resourceLoader) {//2[m
[31m-[m
[31m-                      this.loader = resourceLoader;[m
[31m-              }[m
[31m-[m
[31m-              @Override[m
[31m-              public void setBeanName(String name) {//3[m
[31m-[m
[31m-                      this.beanName = name;[m
[31m-              }[m
[31m-[m
[31m-              public void outputResult(){[m
[31m-                      System.out.println("Bean的名称为：" + beanName);[m
[31m-                      Resource resource =[m
[31m-                                    loader.getResource("classpath:com/wisely/highlight_spri[m
[31m-[m
[31m-                      try{[m
[31m-                                   System.out.println("ResourceLoader加载的文件内容[m
[31m-[m
[31m-       为: " + IOUtils.toString(resource.getInputStream()));[m
[31m-[m
[31m-                           }catch(IOException e){[m
[31m-                             e.printStackTrace();[m
[31m-[m
[31m-                           }[m
[31m-                      }[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①实现BeanNameAware、ResourceLoaderAware接口，获得[m
[31m-Bean名称和资源加载的服务。[m
[31m-[m
[31m-     ②实现ResourceLoaderAware需重写setResourceLoader。[m
[31m-[m
[31m-     ③实现BeanNameAware需重写setBeanName方法。[m
[31m-[m
[31m-     （3）配置类。[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch3.aware;[m
[31m-[m
[31m-       import org.springframework.context.annotation.ComponentScan;[m
[31m-       import org.springframework.context.annotation.Configuration;[m
[31m-       @Configuration[m
[31m-       @ComponentScan("com.wisely.highlight_spring4.ch3.aware")[m
[31m-       public class AwareConfig {[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     （4）运行。[m
[31m-package com.wisely.highlight_spring4.ch3.aware;[m
[31m-import org.springframework.context.annotation.AnnotationConfigApplicati[m
[31m-public class Main {[m
[31m-[m
[31m-       public static void main(String[] args) {[m
[31m-              AnnotationConfigApplicationContext context =[m
[31m-                             new AnnotationConfigApplicationContext(AwareConfig.clas[m
[31m-              AwareService awareService = context.getBean(AwareService.class)[m
[31m-              awareService.outputResult();[m
[31m-              context.close();[m
[31m-[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-结果如图3-1所示。[m
[31m-[m
[31m-                              图3-1　运行结果[m
[31m-3.2　多线程[m
[31m-[m
[31m-3.2.1　点睛[m
[31m-[m
[31m-     Spring通过任务执行器（TaskExecutor）来实现多线程和并[m
[31m-发编程。使用ThreadPoolTaskExecutor可实现一个基于线程池[m
[31m-的TaskExecutor。而实际开发中任务一般是非阻碍的，即异步[m
[31m-的，所以我们要在配置类中通过@EnableAsync开启对异步任[m
[31m-务的支持，并通过在实际执行的Bean的方法中使用@Async注[m
[31m-解来声明其是一个异步任务。[m
[31m-[m
[31m-3.2.2　示例[m
[31m-[m
[31m-     （1）配置类。[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch3.taskexecutor;[m
[31m-[m
[31m-       import java.util.concurrent.Executor;[m
[31m-[m
[31m-       import org.springframework.aop.interceptor.AsyncUncaughtExceptionHandle[m
[31m-       import org.springframework.context.annotation.ComponentScan;[m
[31m-       import org.springframework.context.annotation.Configuration;[m
[31m-       import org.springframework.scheduling.annotation.AsyncConfigurer;[m
[31m-       import org.springframework.scheduling.annotation.EnableAsync;[m
[31m-       import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor[m
[31m-       @Configuration[m
[31m-       @ComponentScan("com.wisely.highlight_spring4.ch3.taskexecutor")[m
[31m-       @EnableAsync //1[m
[31m-       public class TaskExecutorConfig implements AsyncConfigurer{//2[m
[31m-[m
[31m-              @Override[m
[31m-              public Executor getAsyncExecutor() {//2[m
[31m-                       ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecut[m
[31m-                             taskExecutor.setCorePoolSize(5);[m
[31m-                             taskExecutor.setMaxPoolSize(10);[m
[31m-                             taskExecutor.setQueueCapacity(25);[m
[31m-                             taskExecutor.initialize();[m
[31m-                             return taskExecutor;[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              @Override[m
[31m-              public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandl[m
[31m-[m
[31m-                      return null;[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①利用@EnableAsync注解开启异步任务支持。[m
[31m-[m
[31m-     ②配置类实现AsyncConfigurer接口并重写getAsyncExecutor[m
[31m-方法，并返回一个ThreadPoolTaskExecutor，这样我们就获得[m
[31m-了一个基于线程池TaskExecutor。[m
[31m-[m
[31m-     （2）任务执行类。[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch3.taskexecutor;[m
[31m-[m
[31m-       import org.springframework.scheduling.annotation.Async;[m
[31m-       import org.springframework.stereotype.Service;[m
[31m-       @Service[m
[31m-       public class AsyncTaskService {[m
[31m-[m
[31m-              @Async //1[m
[31m-              public void executeAsyncTask(Integer i){[m
[31m-[m
[31m-                      System.out.println("执行异步任务: "+i);[m
[31m-              }[m
[31m-[m
[31m-              @Async[m
[31m-              public void executeAsyncTaskPlus(Integer i){[m
[31m-[m
[31m-                      System.out.println("执行异步任务+1: "+(i+1));[m
[31m-              }[m
[31m-}[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①通过@Async注解表明该方法是个异步方法，如果注解[m
[31m-在类级别，则表明该类所有的方法都是异步方法，而这里的方[m
[31m-法自动被注入使用ThreadPoolTaskExecutor作为TaskExecutor。[m
[31m-[m
[31m-     （3）运行。[m
[31m-[m
[31m-package com.wisely.highlight_spring4.ch3.taskexecutor;[m
[31m-[m
[31m-import org.springframework.context.annotation.AnnotationConfigApplicati[m
[31m-[m
[31m-public class Main {[m
[31m-[m
[31m-   public static void main(String[] args) {[m
[31m-            AnnotationConfigApplicationContext context =[m
[31m-                                new AnnotationConfigApplicationContext(TaskExecutor[m
[31m-[m
[31m-          AsyncTaskService asyncTaskService = context.getBean(AsyncTaskS[m
[31m-[m
[31m-          for(int i =0 ;i<10;i++){[m
[31m-                 asyncTaskService.executeAsyncTask(i);[m
[31m-                 asyncTaskService.executeAsyncTaskPlus(i);[m
[31m-[m
[31m-               }[m
[31m-               context.close();[m
[31m-[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-结果是并发执行而不是顺序执行的，如图3-2所示。[m
[31m-图3-2　运行结果[m
[31m-3.3　计划任务[m
[31m-[m
[31m-3.3.1　点睛[m
[31m-[m
[31m-     从Spring 3.1开始，计划任务在Spring中的实现变得异常的[m
[31m-简单。首先通过在配置类注解@EnableScheduling来开启对计[m
[31m-划任务的支持，然后在要执行计划任务的方法上注解[m
[31m-@Scheduled，声明这是一个计划任务。[m
[31m-[m
[31m-     Spring通过@Scheduled支持多种类型的计划任务，包含[m
[31m-cron、fixDelay、fixRate等。[m
[31m-[m
[31m-3.3.2　示例[m
[31m-[m
[31m-     （1）计划任务执行类。[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch3.taskscheduler;[m
[31m-       import java.text.SimpleDateFormat;[m
[31m-       import java.util.Date;[m
[31m-       import org.springframework.scheduling.annotation.Scheduled;[m
[31m-       import org.springframework.stereotype.Service;[m
[31m-       @Service[m
[31m-       public class ScheduledTaskService {[m
[31m-[m
[31m-                  private static final SimpleDateFormat dateFormat = new SimpleDate[m
[31m-                  @Scheduled(fixedRate = 5000) //1[m
[31m-                  public void reportCurrentTime() {[m
[31m-[m
[31m-                                                            System.out.println("每隔五秒执行一[m
[31m-       次 " + dateFormat.format(new Date()));[m
[31m-                    }[m
[31m-[m
[31m-                  @Scheduled(cron = "0 28 11 ? * *" ) //2[m
[31m-                  public void fixTimeExecution(){[m
[31m-[m
[31m-                                                                     System.out.println("在指定时[m
[31m-       间 " + dateFormat.format(new Date())+"执行");[m
[31m-[m
[31m-                  }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①通过@Scheduled声明该方法是计划任务，使用fixedRate[m
[31m-属性每隔固定时间执行。[m
[31m-[m
[31m-     ②使用cron属性可按照指定时间执行，本例指的是每天11[m
[31m-点28分执行；cron是UNIX和类UNIX（Linux）系统下的定时[m
[31m-任务。[m
[31m-[m
[31m-     （2）配置类。[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch3.taskscheduler;[m
[31m-[m
[31m-       import org.springframework.context.annotation.ComponentScan;[m
[31m-       import org.springframework.context.annotation.Configuration;[m
[31m-       import org.springframework.scheduling.annotation.EnableScheduling;[m
[31m-[m
[31m-       @Configuration[m
[31m-       @ComponentScan("com.wisely.highlight_spring4.ch3.taskscheduler")[m
[31m-       @EnableScheduling //1[m
[31m-       public class TaskSchedulerConfig {[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-①通过@EnableScheduling注解开启对计划任务的支持。[m
[31m-（3）运行。[m
[31m-[m
[31m-package com.wisely.highlight_spring4.ch3.taskscheduler;[m
[31m-import org.springframework.context.annotation.AnnotationConfigApplicati[m
[31m-public class Main {[m
[31m-[m
[31m-       public static void main(String[] args) {[m
[31m-                AnnotationConfigApplicationContext context =[m
[31m-                                    new AnnotationConfigApplicationContext(TaskSchedule[m
[31m-[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-结果如图3-3所示。[m
[31m-[m
[31m-                              图3-3　运行结果[m
[31m-3.4　条件注解@Conditional[m
[31m-[m
[31m-3.4.1　点睛[m
[31m-[m
[31m-     在2.4节学到，通过活动的profile，我们可以获得不同的[m
[31m-Bean。Spring 4提供了一个更通用的基于条件的Bean的创建，[m
[31m-即使用@Conditional注解。[m
[31m-[m
[31m-     @Conditional根据满足某一个特定条件创建一个特定的[m
[31m-Bean。比方说，当某一个jar包在一个类路径下的时候，自动配[m
[31m-置一个或多个Bean；或者只有某个Bean被创建才会创建另外一[m
[31m-个Bean。总的来说，就是根据特定条件来控制Bean的创建行[m
[31m-为，这样我们可以利用这个特性进行一些自动的配置。[m
[31m-[m
[31m-     在Spring Boot中将会大量应用到条件注解，更多内容见本[m
[31m-书6.1节。[m
[31m-[m
[31m-     下面的示例将以不同的操作系统作为条件，我们将通过实[m
[31m-现Condition接口，并重写其matches方法来构造判断条件。若[m
[31m-在Windows系统下运行程序，则输出列表命令为dir；若在[m
[31m-Linux操作系统下运行程序，则输出列表命令为ls。[m
[31m-[m
[31m-3.4.2　示例[m
[31m-[m
[31m-     1.判断条件定义[m
[31m-[m
[31m-     （1）判定Windows的条件。[m
[31m-package com.wisely.highlight_spring4.ch3.conditional;[m
[31m-[m
[31m-import org.springframework.context.annotation.Condition;[m
[31m-import org.springframework.context.annotation.ConditionContext;[m
[31m-import org.springframework.core.type.AnnotatedTypeMetadata;[m
[31m-[m
[31m-public class WindowsCondition implements Condition {[m
[31m-[m
[31m-       public boolean matches(ConditionContext context,[m
[31m-                     AnnotatedTypeMetadata metadata) {[m
[31m-[m
[31m-              return context.getEnvironment().getProperty("os.name").contains[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-（2）判定Linux的条件。[m
[31m-[m
[31m-package com.wisely.highlight_spring4.ch3.conditional;[m
[31m-[m
[31m-import org.springframework.context.annotation.Condition;[m
[31m-import org.springframework.context.annotation.ConditionContext;[m
[31m-import org.springframework.core.type.AnnotatedTypeMetadata;[m
[31m-[m
[31m-public class LinuxCondition implements Condition {[m
[31m-[m
[31m-       public boolean matches(ConditionContext context,[m
[31m-                     AnnotatedTypeMetadata metadata) {[m
[31m-[m
[31m-              return context.getEnvironment().getProperty("os.name").contains[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-2.不同系统下Bean的类[m
[31m-[m
[31m-（1）接口。[m
[31m-[m
[31m-package com.wisely.highlight_spring4.ch3.conditional;[m
[31m-[m
[31m-public interface ListService {[m
[31m-       public String showListCmd();[m
[31m-[m
[31m-}[m
[31m-（2）Windows下所要创建的Bean的类。[m
[31m-[m
[31m-package com.wisely.highlight_spring4.ch3.conditional;[m
[31m-[m
[31m-public class WindowsListService implements ListService {[m
[31m-[m
[31m-       @Override[m
[31m-       public String showListCmd() {[m
[31m-[m
[31m-              return "dir";[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-（3）Linux下所要创建的Bean的类。[m
[31m-[m
[31m-package com.wisely.highlight_spring4.ch3.conditional;[m
[31m-[m
[31m-public class LinuxListService implements ListService{[m
[31m-[m
[31m-       @Override[m
[31m-       public String showListCmd() {[m
[31m-[m
[31m-              return "ls";[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-3.配置类[m
[31m-[m
[31m-package com.wisely.highlight_spring4.ch3.conditional;[m
[31m-[m
[31m-import org.springframework.context.annotation.Bean;[m
[31m-import org.springframework.context.annotation.Conditional;[m
[31m-import org.springframework.context.annotation.Configuration;[m
[31m-[m
[31m-@Configuration[m
[31m-public class ConditionConifg {[m
[31m-[m
[31m-       @Bean[m
[31m-       @Conditional(WindowsCondition.class) //1[m
[31m-       public ListService windowsListService() {[m
[31m-[m
[31m-              return new WindowsListService();[m
[31m-              }[m
[31m-[m
[31m-              @Bean[m
[31m-              @Conditional(LinuxCondition.class) //2[m
[31m-              public ListService linuxListService() {[m
[31m-[m
[31m-                      return new LinuxListService();[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①通过@Conditional注解，符合Windows条件则实例化[m
[31m-windowsListService。[m
[31m-[m
[31m-     ②通过@Conditional注解，符合Linux条件则实例化[m
[31m-linuxListService。[m
[31m-[m
[31m-     4.运行[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch3.conditional;[m
[31m-[m
[31m-       import org.springframework.context.annotation.AnnotationConfigApplicati[m
[31m-[m
[31m-       public class Main {[m
[31m-[m
[31m-              public static void main(String[] args) {[m
[31m-                      AnnotationConfigApplicationContext context =[m
[31m-                                    new AnnotationConfigApplicationContext(ConditionConifg.[m
[31m-[m
[31m-                      ListService listService = context.getBean(ListService.class);[m
[31m-[m
[31m-                      System.out.println(context.getEnvironment().getProperty("os.nam[m
[31m-                                    + "系统下的列表命令为: "[m
[31m-                                    + listService.showListCmd());[m
[31m-[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     结果如图3-4和图3-5所示。[m
[31m-图3-4　Windows下列表命令[m
[31m-  图3-5　Linux下列表命令[m
[31m-3.5　组合注解与元注解[m
[31m-[m
[31m-3.5.1　点睛[m
[31m-[m
[31m-     从Spring 2开始，为了响应JDK 1.5推出的注解功能，[m
[31m-Spring开始大量加入注解来替代xml配置。Spring的注解主要用[m
[31m-来配置注入Bean，切面相关配置（@Transactional）。随着注[m
[31m-解的大量使用，尤其相同的多个注解用到各个类中，会相当啰[m
[31m-嗦。这就是所谓的模板代码，是Spring设计原则中要消除的代[m
[31m-码。[m
[31m-[m
[31m-     所谓元注解其实就是可以注解到别的注解上的注解，被注[m
[31m-解的注解称之为组合注解、是可能有点拗口，体会含义最重[m
[31m-要），组合注解具备元注解的功能。Spring的很多注解都可以[m
[31m-作为元注解，而且Spring本身已经有很多组合注解，如[m
[31m-@Configuration就是一个组合@Component注解，表明这个类其[m
[31m-实也是一个Bean。[m
[31m-[m
[31m-     我们前面的章节里大量使用@Configuration和[m
[31m-@ComponentScan注解到配置类上，如果你跟着本书一直在敲[m
[31m-代码的话是不是觉得已经有点麻烦了呢？下面我将这两个元注[m
[31m-解组成一个组合注解，这样我们只需写一个注解就可以表示两[m
[31m-个注解。[m
[31m-[m
[31m-3.5.2　示例[m
[31m-[m
[31m-     （1）示例组合注解。[m
[31m-package com.wisely.highlight_spring4.ch3.annotation;[m
[31m-[m
[31m-import java.lang.annotation.Documented;[m
[31m-import java.lang.annotation.ElementType;[m
[31m-import java.lang.annotation.Retention;[m
[31m-import java.lang.annotation.RetentionPolicy;[m
[31m-import java.lang.annotation.Target;[m
[31m-[m
[31m-import org.springframework.context.annotation.ComponentScan;[m
[31m-import org.springframework.context.annotation.Configuration;[m
[31m-[m
[31m-@Target(ElementType.TYPE)[m
[31m-@Retention(RetentionPolicy.RUNTIME)[m
[31m-@Documented[m
[31m-@Configuration //1[m
[31m-@ComponentScan //2[m
[31m-public @interface WiselyConfiguration {[m
[31m-[m
[31m-       String[] value() default {}; //3[m
[31m-[m
[31m-}[m
[31m-[m
[31m-代码解释[m
[31m-[m
[31m-①组合@Configuration元注解。[m
[31m-[m
[31m-②组合@ComponentScan元注解。[m
[31m-[m
[31m-③覆盖value参数。[m
[31m-[m
[31m-（2）演示服务Bean。[m
[31m-[m
[31m-package com.wisely.highlight_spring4.ch3.annotation;[m
[31m-[m
[31m-import org.springframework.stereotype.Service;[m
[31m-[m
[31m-@Service[m
[31m-public class DemoService {[m
[31m-[m
[31m-       public void outputResult(){[m
[31m-              System.out.println("从组合注解配置照样获得的bean");[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     （3）新的配置类。[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch3.annotation;[m
[31m-       @WiselyConfiguration("com.wisely.highlight_spring4.ch3.annotation")//1[m
[31m-       public class DemoConfig {[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-     ①使用@WiselyConfiguration组合注解替代@Configuration[m
[31m-和@ComponentScan。[m
[31m-     （4）运行。[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch3.annotation;[m
[31m-       import org.springframework.context.annotation.AnnotationConfigApplicati[m
[31m-       public class Main {[m
[31m-[m
[31m-              public static void main(String[] args) {[m
[31m-                      AnnotationConfigApplicationContext context =[m
[31m-                                    new AnnotationConfigApplicationContext(DemoConfig.class[m
[31m-                      DemoService demoService = context.getBean(DemoService.class);[m
[31m-                      demoService.outputResult();[m
[31m-                      context.close();[m
[31m-[m
[31m-              }[m
[31m-       }[m
[31m-结果如图3-6所示。[m
[31m-[m
[31m-                              图3-6　运行结果[m
[31m-3.6　@Enable*注解的工作原理[m
[31m-[m
[31m-     在本章的第一部分我们通过：[m
[31m-[m
[31m-     @EnableAspectJAutoProxy开启对AspectJ自动代理的支[m
[31m-持。[m
[31m-[m
[31m-     @EnableAsync开启异步方法的支持。[m
[31m-[m
[31m-     @EnableScheduling开启计划任务的支持。[m
[31m-[m
[31m-     在第二部分我们通过：[m
[31m-[m
[31m-     @EnableWebMvc开启Web MVC的配置支持。[m
[31m-[m
[31m-     在第三部分我们通过：[m
[31m-[m
[31m-     @EnableConfigurationProperties开启对[m
[31m-@ConfigurationProperties注解配置Bean的支持。[m
[31m-[m
[31m-     @EnableJpaRepositories开启对Spring Data JPA Repository的[m
[31m-支持。[m
[31m-[m
[31m-     @EnableTransactionManagement开启注解式事务的支持。[m
[31m-[m
[31m-     @EnableCaching开启注解式的缓存支持。[m
[31m-[m
[31m-     通过简单的@Enable*来开启一项功能的支持，从而避免自[m
[31m-己配置大量的代码，大大降低使用难度。那么这个神奇的功能[m
[31m-的实现原理是什么呢？我们一起来研究一下。[m
[31m-     通过观察这些@Enable*注解的源码，我们发现所有的注解[m
[31m-都有一个@Import注解，@Import是用来导入配置类的，这也[m
[31m-就意味着这些自动开启的实现其实是导入了一些自动配置的[m
[31m-Bean。这些导入的配置方式主要分为以下三种类型。[m
[31m-[m
[31m-3.6.1　第一类：直接导入配置类[m
[31m-[m
[31m-       @Target(ElementType.TYPE)[m
[31m-       @Retention(RetentionPolicy.RUNTIME)[m
[31m-       @Import(SchedulingConfiguration.class)[m
[31m-       @Documented[m
[31m-       public @interface EnableScheduling {[m
[31m-       }[m
[31m-[m
[31m-     直接导入配置类SchedulingConfiguration，这个类注解了[m
[31m-@Configuration，且注册了一个scheduledAnnotationProcessor的[m
[31m-Bean，源码如下：[m
[31m-[m
[31m-       @Configuration[m
[31m-       @Role(BeanDefinition.ROLE_INFRASTRUCTURE)[m
[31m-       public class SchedulingConfiguration {[m
[31m-[m
[31m-              @Bean(name = TaskManagementConfigUtils.SCHEDULED_ANNOTATION_PROCESS[m
[31m-              @Role(BeanDefinition.ROLE_INFRASTRUCTURE)[m
[31m-              public ScheduledAnnotationBeanPostProcessor scheduledAnnotationProc[m
[31m-[m
[31m-                      return new ScheduledAnnotationBeanPostProcessor();[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-3.6.2　第二类：依据条件选择配置类[m
[31m-       @Target(ElementType.TYPE)[m
[31m-       @Retention(RetentionPolicy.RUNTIME)[m
[31m-       @Documented[m
[31m-       @Import(AsyncConfigurationSelector.class)[m
[31m-       public @interface EnableAsync {[m
[31m-       Class<? extends Annotation> annotation() default Annotation.class;[m
[31m-[m
[31m-              boolean proxyTargetClass() default false;[m
[31m-              AdviceMode mode() default AdviceMode.PROXY;[m
[31m-              int order() default Ordered.LOWEST_PRECEDENCE;[m
[31m-       }[m
[31m-[m
[31m-     AsyncConfigurationSelector通过条件来选择需要导入的配[m
[31m-置类，AsyncConfigurationSelector的根接口为ImportSelector，[m
[31m-这个接口需重写selectImports方法，在此方法内进行事先条件[m
[31m-判断。此例中，若adviceMode为PORXY，则返回[m
[31m-ProxyAsyncConfiguration这个配置类；若activeMode为[m
[31m-ASPECTJ，则返回AspectJAsyncConfiguration配置类，源码如[m
[31m-下：[m
[31m-[m
[31m-       public class AsyncConfigurationSelector extends AdviceModeImportSelecto[m
[31m-[m
[31m-              private static final String ASYNC_EXECUTION_ASPECT_CONFIGURATION_CL[m
[31m-                             "org.springframework.scheduling.aspectj.AspectJAsyncConfigu[m
[31m-[m
[31m-              @Override[m
[31m-              public String[] selectImports(AdviceMode adviceMode) {[m
[31m-[m
[31m-                      switch (adviceMode) {[m
[31m-                             case PROXY:[m
[31m-                                    return new String[] { ProxyAsyncConfiguration.class.get[m
[31m-                             case ASPECTJ:[m
[31m-                                    return new String[] { ASYNC_EXECUTION_ASPECT_CONFIGURAT[m
[31m-                             default:[m
[31m-                                    return null;[m
[31m-[m
[31m-                      }[m
[31m-              }[m
[31m-       }[m
[31m-3.6.3　第三类：动态注册Bean[m
[31m-[m
[31m-       @Target(ElementType.TYPE)[m
[31m-       @Retention(RetentionPolicy.RUNTIME)[m
[31m-       @Documented[m
[31m-       @Import(AspectJAutoProxyRegistrar.class)[m
[31m-       public @interface EnableAspectJAutoProxy {[m
[31m-[m
[31m-              boolean proxyTargetClass() default false;[m
[31m-       }[m
[31m-[m
[31m-     AspectJAutoProxyRegistrar实现了[m
[31m-ImportBeanDefinitionRegistrar接口，ImportBean[m
[31m-DefinitionRegistrar的作用是在运行时自动添加Bean到已有的配[m
[31m-置类，通过重写方法：[m
[31m-[m
[31m-       registerBeanDefinitions(AnnotationMetadata importingClassMetadata,[m
[31m-[m
[31m-     其中，AnnotationMetadata参数用来获得当前配置类上的注[m
[31m-解；BeanDefinitionRegistry参数用来注册Bean。源码如下：[m
[31m-[m
[31m-       class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistra[m
[31m-              @Override[m
[31m-              public void registerBeanDefinitions([m
[31m-                             AnnotationMetadata importingClassMetadata, BeanDefinitionRe[m
[31m-[m
[31m-                      AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNeces[m
[31m-[m
[31m-                      AnnotationAttributes enableAJAutoProxy =[m
[31m-                                    AnnotationConfigUtils.attributesFor(importingClassMetad[m
[31m-[m
[31m-                      if (enableAJAutoProxy.getBoolean("proxyTargetClass")) {[m
[31m-                             AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(regi[m
[31m-[m
[31m-                      }[m
[31m-              }[m
[31m-}[m
[31m-3.7　测试[m
[31m-[m
[31m-3.7.1　点睛[m
[31m-[m
[31m-     测试是开发工作中不可缺少的部分。单元测试只针对当前[m
[31m-开发的类和方法进行测试，可以简单通过模拟依赖来实现，对[m
[31m-运行环境没有依赖；但是仅仅进行单元测试是不够的，它只能[m
[31m-验证当前类或方法能否正常工作，而我们想要知道系统的各个[m
[31m-部分组合在一起是否能正常工作，这就是集成测试存在的意[m
[31m-义。[m
[31m-[m
[31m-     集成测试一般需要来自不同层的不同对象的交互，如数据[m
[31m-库、网络连接、IoC容器等。其实我们也经常通过运行程序，[m
[31m-然后通过自己操作来完成类似于集成测试的流程。集成测试为[m
[31m-我们提供了一种无须部署或运行程序来完成验证系统各部分是[m
[31m-否能正常协同工作的能力。[m
[31m-[m
[31m-     Spring通过Spring TestContex Framework对集成测试提供顶[m
[31m-级支持。它不依赖于特定的测试框架，既可使用Junit，也可使[m
[31m-用TestNG。[m
[31m-[m
[31m-     基于Maven构建的项目结构默认有关于测试的目录：[m
[31m-src/test/java（测试代码）、src/test/resources（测试资源），区[m
[31m-别于src/main/java（项目源码）、src/main/resources（项目资[m
[31m-源）。[m
[31m-[m
[31m-Spring提供了一个SpringJUnit4ClassRunner类，它提供了[m
[31m-[m
[31m-Spring    TestContext  Framework的功能。通过[m
[31m-[m
[31m-@ContextConfiguration来配置Application  Context，通过[m
[31m-@ActiveProfiles确定活动的profile。[m
[31m-[m
[31m-     在使用了Spring测试后，我们前面的例子的“运行”部分都[m
[31m-可以用Spring测试来检验功能能否正常运作。[m
[31m-[m
[31m-     集成测试涉及程序中的各个分层，本节只对简单配置的[m
[31m-Application Context和在测试中注入Bean做演示，在本书第二[m
[31m-部分和第三部分会对Spring测试做更多的讲述。[m
[31m-[m
[31m-3.7.2　示例[m
[31m-[m
[31m-     1.准备[m
[31m-[m
[31m-     增加Spring测试的依赖包到Maven：[m
[31m-[m
[31m-                    <!-- Spring test 支持 -->[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework</groupId>[m
[31m-                             <artifactId>spring-test</artifactId>[m
[31m-                             <version>${spring-framework.version}</version>[m
[31m-                      </dependency>[m
[31m-                      <dependency>[m
[31m-                             <groupId>junit</groupId>[m
[31m-                             <artifactId>junit</artifactId>[m
[31m-                             <version>4.11</version>[m
[31m-                      </dependency>[m
[31m-[m
[31m-     2.业务代码[m
[31m-[m
[31m-     在src/main/java下的源码：[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch3.fortest;[m
[31m-[m
[31m-       public class TestBean {[m
[31m-       private String content;[m
[31m-[m
[31m-       public TestBean(String content) {[m
[31m-              super();[m
[31m-              this.content = content;[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-       public String getContent() {[m
[31m-              return content;[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-       public void setContent(String content) {[m
[31m-              this.content = content;[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-}[m
[31m-[m
[31m-3.配置类[m
[31m-[m
[31m-在src/main/java下的源码：[m
[31m-[m
[31m-package com.wisely.highlight_spring4.ch3.fortest;[m
[31m-[m
[31m-import org.springframework.context.annotation.Bean;[m
[31m-import org.springframework.context.annotation.Configuration;[m
[31m-import org.springframework.context.annotation.Profile;[m
[31m-@Configuration[m
[31m-public class TestConfig {[m
[31m-[m
[31m-       @Bean[m
[31m-       @Profile("dev")[m
[31m-       public TestBean devTestBean() {[m
[31m-[m
[31m-              return new TestBean("from development profile");[m
[31m-       }[m
[31m-[m
[31m-       @Bean[m
[31m-       @Profile("prod")[m
[31m-       public TestBean prodTestBean() {[m
[31m-[m
[31m-              return new TestBean("from production profile");[m
[31m-       }[m
[31m-[m
[31m-}[m
[31m-     4.测试[m
[31m-[m
[31m-     在src/test/java下的源码：[m
[31m-[m
[31m-       package com.wisely.highlight_spring4.ch3.fortest;[m
[31m-[m
[31m-       import org.junit.Assert;[m
[31m-       import org.junit.Test;[m
[31m-       import org.junit.runner.RunWith;[m
[31m-       import org.springframework.beans.factory.annotation.Autowired;[m
[31m-       import org.springframework.test.context.ActiveProfiles;[m
[31m-       import org.springframework.test.context.ContextConfiguration;[m
[31m-       import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;[m
[31m-[m
[31m-       @RunWith(SpringJUnit4ClassRunner.class) //1[m
[31m-       @ContextConfiguration(classes = {TestConfig.class}) //2[m
[31m-       @ActiveProfiles("prod") //3[m
[31m-       public class DemoBeanIntegrationTests {[m
[31m-[m
[31m-              @Autowired //4[m
[31m-              private TestBean testBean;[m
[31m-[m
[31m-              @Test //5[m
[31m-              public void prodBeanShouldInject(){[m
[31m-[m
[31m-                      String expected = "from production profile";[m
[31m-                      String actual = testBean.getContent();[m
[31m-                      Assert.assertEquals(expected, actual);[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①SpringJUnit4ClassRunner在JUnit环境下提供Spring[m
[31m-TestContext Framework的功能。[m
[31m-[m
[31m-     ②@ContextConfiguration用来加载配置[m
[31m-ApplicationContext，其中classes属性用来加载配置类。[m
[31m-[m
[31m-     ③@ActiveProfiles用来声明活动的profile。[m
[31m-     ④可使用普通的@Autowired注入Bean。[m
[31m-     ⑤测试代码，通过JUnit的Assert来校验结果是否和预期一[m
[31m-致。[m
[31m-     结果如图3-7所示。[m
[31m-[m
[31m-                                    图3-7　测试结果[m
[31m-[m
[31m-     将@ActiveProfiles（“prod”）改为[m
[31m-@ActiveProfiles（“dev”），演示测试不能通过的情景，如图3-[m
[31m-8所示。[m
[31m-图3-8　演示测试不能通过的情景[m
[31m-    第二部分　点睛Spring MVC 4.x[m
[31m-[m
[31m-第4章　Spring MVC基础[m
[31m-[m
[31m-     也许你还在问为什么要用Spring MVC，Struts 2.x不才是主[m
[31m-流吗？看SSH的概念多火！其实很多初学者混淆了一个概念，[m
[31m-SSH实际上指的是Struts 1.x+Spring+Hibernate，这个概念已经[m
[31m-有十几年的历史了。在Struts 1.x的时代，Struts 1.x是当之无愧[m
[31m-的MVC框架的霸主，但是在新的MVC框架涌现的时代，形式[m
[31m-已经完全不是这样的了，Struts 2.x借助了Struts 1.x的好名声，[m
[31m-让国内开发者认为Struts 2.x是霸主继任者（其实两者在技术上[m
[31m-无任何关系），导致国内程序员大多数学习基于Struts 2.x的框[m
[31m-架，又一个貌似很火的概念出来了S2SH（Struts[m
[31m-2.x+Spring+Hibernate）整合开发。[m
[31m-[m
[31m-     一起看看世界范围内到底是什么状况吧，请看下面的调查[m
[31m-统计。[m
[31m-[m
[31m-     Zeroturnaround（知名热部署软件JRebel厂商）统计如图4-1[m
[31m-所示。[m
[31m-                                图4-1　JRbel厂商统计[m
[31m-[m
[31m-     从图4-1可以看出，Spring MVC的市场占有率是40%，而[m
[31m-Struts 2只有可怜的6%，竟然只比骨灰级的Struts 1高那么一点[m
[31m-点。[m
[31m-[m
[31m-     vitalflux.com对2014—2015年度10佳Web框架排名。[m
[31m-     前10名没有Struts 2的身影，前五名为：[m
[31m-[m
[31m-     1.Spring MVC[m
[31m-[m
[31m-     2.Grails[m
[31m-[m
[31m-     3.Play[m
[31m-[m
[31m-     4.Spring Boot[m
[31m-[m
[31m-     5.Vaadin[m
[31m-     说了这么多，不过是为了大家更有信心地学习Spring[m
[31m-MVC，Spring MVC是目前Java Web框架当之无愧的霸主。[m
[31m-4.1　Spring MVC概述[m
[31m-[m
[31m-     说到Spring MVC，不得不先来谈谈什么是MVC，它和三[m
[31m-层架构是什么关系。可能很多读者都会抢答：[m
[31m-[m
[31m-     MVC：Model+View+Controller（数据模型+视图+控制[m
[31m-器）。[m
[31m-[m
[31m-     三层架构： Presentation tier+Application tier+Data tier（展[m
[31m-现层+应用层+数据访问层）。[m
[31m-[m
[31m-     那MVC和三层架构有什么关系呢？在我面试程序员的时[m
[31m-候，经常会有面试者告诉我：MVC的M就是数据访问层、V就[m
[31m-是展现层、C就是应用层。怎么样？听上去是不是好像很有道[m
[31m-理？[m
[31m-[m
[31m-     但是实际上MVC只存在三层架构的展现层，M实际上是数[m
[31m-据模型，是包含数据的对象。在Spring MVC里，有一个专门[m
[31m-的类叫Model，用来和V之间的数据交互、传值；V指的是视图[m
[31m-页面，包含JSP、freeMarker、Velocity、Thymeleaf、Tile等；C[m
[31m-当然就是控制器（Spring MVC的注解@Controller的类）。[m
[31m-[m
[31m-     在本书我很抱歉地告诉大家，本书将不会介绍太多View层[m
[31m-的知识，只会简单地使用JSP和jstl作为演示，因为Spring MVC[m
[31m-支持的模板引擎太多了，我们会在7.1节专门介绍Spring Boot推[m
[31m-荐使用的模板引擎，本章关注Spring MVC在实际开发中的各[m
[31m-种配置。[m
[31m-[m
[31m-     而三层架构是整个应用的架构，是由Spring框架负责管理[m
[31m-的。一般项目结构中都有Service层、DAO层，这两个反馈在[m
[31m-应用层和数据访问层。[m
[31m-[m
[31m-     弄清MVC和三层架构的关系对我们理解Spring MVC和进[m
[31m-行Web开发至关重要。[m
[31m-[m
[31m-     Spring MVC使我们可以简单地开发灵活且松耦合的Web项[m
[31m-目，本章我们将关注与基于注解和Java配置的零配置（无xml[m
[31m-配置）的Spring MVC开发。[m
[31m-4.2　Spring MVC项目快速搭建[m
[31m-[m
[31m-4.2.1　点睛[m
[31m-[m
[31m-     Spring MVC提供了一个DispatcherServlet来开发Web应用。[m
[31m-在Servlet 2.5及以下的时候只要在web.xml下配置<servlet>元素[m
[31m-即可。但我们在本节将使用Servlet 3.0+无web.xml的配置方[m
[31m-式，在Spring MVC里实现WebApplicationInitializer接口便可实[m
[31m-现等同于web.xml的配置。[m
[31m-[m
[31m-     下面我们将基于Maven搭建零配置的Spring MVC原型项[m
[31m-目，开发工具相关的内容这里将不再提及。[m
[31m-[m
[31m-4.2.2　示例[m
[31m-[m
[31m-     1.构建Maven项目[m
[31m-[m
[31m-     pom.xml内容：[m
[31m-[m
[31m-       <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://ww[m
[31m-       instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://[m
[31m-       4.0.0.xsd">[m
[31m-[m
[31m-           <modelVersion>4.0.0</modelVersion>[m
[31m-           <groupId>com.wisely</groupId>[m
[31m-           <artifactId>highlight_springmvc4</artifactId>[m
[31m-           <version>0.0.1-SNAPSHOT</version>[m
[31m-           <packaging>war</packaging>[m
[31m-[m
[31m-             <properties>[m
[31m-                      <!-- Generic properties -->[m
[31m-                      <java.version>1.7</java.version>[m
[31m-                                                <project.build.sourceEncoding>UTF-[m
[31m-8</project.build.sourceEncoding>[m
[31m-[m
[31m-                                         <project.reporting.outputEncoding>UTF-[m
[31m-8</project.reporting.outputEncoding>[m
[31m-[m
[31m-              <!-- Web -->[m
[31m-              <jsp.version>2.2</jsp.version>[m
[31m-              <jstl.version>1.2</jstl.version>[m
[31m-              <servlet.version>3.1.0</servlet.version>[m
[31m-              <!-- Spring -->[m
[31m-[m
[31m-                       <spring-framework.version>4.1.5.RELEASE</spring-[m
[31m-framework.version>[m
[31m-[m
[31m-              <!-- Logging -->[m
[31m-              <logback.version>1.0.13</logback.version>[m
[31m-              <slf4j.version>1.7.5</slf4j.version>[m
[31m-       </properties>[m
[31m-[m
[31m-       <dependencies>[m
[31m-              <dependency>[m
[31m-                     <groupId>javax</groupId>[m
[31m-                     <artifactId>javaee-web-api</artifactId>[m
[31m-                     <version>7.0</version>[m
[31m-                     <scope>provided</scope>[m
[31m-              </dependency>[m
[31m-[m
[31m-              <!-- Spring MVC -->[m
[31m-              <dependency>[m
[31m-[m
[31m-                     <groupId>org.springframework</groupId>[m
[31m-                     <artifactId>spring-webmvc</artifactId>[m
[31m-                     <version>${spring-framework.version}</version>[m
[31m-              </dependency>[m
[31m-[m
[31m-              <!-- 其他Web依赖 -->[m
[31m-              <dependency>[m
[31m-[m
[31m-                     <groupId>javax.servlet</groupId>[m
[31m-                     <artifactId>jstl</artifactId>[m
[31m-                     <version>${jstl.version}</version>[m
[31m-              </dependency>[m
[31m-              <dependency>[m
[31m-                     <groupId>javax.servlet</groupId>[m
[31m-                     <artifactId>javax.servlet-api</artifactId>[m
[31m-                     <version>${servlet.version}</version>[m
[31m-                     <scope>provided</scope>[m
[31m-              </dependency>[m
[31m-              <dependency>[m
[31m-                     <groupId>javax.servlet.jsp</groupId>[m
[31m-                     <artifactId>jsp-api</artifactId>[m
[31m-                     <version>${jsp.version}</version>[m
[31m-                     <scope>provided</scope>[m
[31m-              </dependency>[m
[31m-[m
[31m-              <!-- Spring and Transactions -->[m
[31m-              <dependency>[m
[31m-[m
[31m-                     <groupId>org.springframework</groupId>[m
[31m-                     <artifactId>spring-tx</artifactId>[m
[31m-                     <version>${spring-framework.version}</version>[m
[31m-              </dependency>[m
[31m-[m
[31m-              <!-- 使用SLF4J和LogBack作为日志 -->[m
[31m-              <dependency>[m
[31m-[m
[31m-                     <groupId>org.slf4j</groupId>[m
[31m-                     <artifactId>slf4j-api</artifactId>[m
[31m-                     <version>${slf4j.version}</version>[m
[31m-              </dependency>[m
[31m-              <dependency>[m
[31m-                     <groupId>log4j</groupId>[m
[31m-                     <artifactId>log4j</artifactId>[m
[31m-                     <version>1.2.16</version>[m
[31m-              </dependency>[m
[31m-              <dependency>[m
[31m-                     <groupId>org.slf4j</groupId>[m
[31m-                     <artifactId>jcl-over-slf4j</artifactId>[m
[31m-                     <version>${slf4j.version}</version>[m
[31m-              </dependency>[m
[31m-              <dependency>[m
[31m-                     <groupId>ch.qos.logback</groupId>[m
[31m-                     <artifactId>logback-classic</artifactId>[m
[31m-                     <version>${logback.version}</version>[m
[31m-              </dependency>[m
[31m-              <dependency>[m
[31m-                     <groupId>ch.qos.logback</groupId>[m
[31m-                     <artifactId>logback-core</artifactId>[m
[31m-                     <version>${logback.version}</version>[m
[31m-              </dependency>[m
[31m-              <dependency>[m
[31m-                     <groupId>ch.qos.logback</groupId>[m
[31m-                     <artifactId>logback-access</artifactId>[m
[31m-                     <version>${logback.version}</version>[m
[31m-              </dependency>[m
[31m-          </dependencies>[m
[31m-[m
[31m-                <build>[m
[31m-              <plugins>[m
[31m-[m
[31m-                   <plugin>[m
[31m-                             <groupId>org.apache.maven.plugins</groupId>[m
[31m-                                                             <artifactId>maven-compiler-[m
[31m-[m
[31m-plugin</artifactId>[m
[31m-                                    <version>2.3.2</version>[m
[31m-                                    <configuration>[m
[31m-[m
[31m-                                           <source>${java.version}</source>[m
[31m-                                           <target>${java.version}</target>[m
[31m-                                    </configuration>[m
[31m-                             </plugin>[m
[31m-                             <plugin>[m
[31m-                                    <groupId>org.apache.maven.plugins</groupId>[m
[31m-                                    <artifactId>maven-war-plugin</artifactId>[m
[31m-                                    <version>2.3</version>[m
[31m-                                    <configuration>[m
[31m-                                           <failOnMissingWebXml>false</failOnMissingWebXml>[m
[31m-                                    </configuration>[m
[31m-                             </plugin>[m
[31m-                      </plugins>[m
[31m-              </build>[m
[31m-       </project>[m
[31m-[m
[31m-     2.日志配置[m
[31m-[m
[31m-     在src/main/resources目录下，新建logback.xml用来配置日[m
[31m-志，内容如下：[m
[31m-[m
[31m-       <?xml version="1.0" encoding="UTF-8"?>[m
[31m-       <configuration scan="true" scanPeriod="1 seconds">[m
[31m-[m
[31m-              <contextListener class="ch.qos.logback.classic.jul.LevelChangePropa[m
[31m-                      <resetJUL>true</resetJUL>[m
[31m-[m
[31m-              </contextListener>[m
[31m-[m
[31m-              <jmxConfigurator/>[m
[31m-              <appender name="console" class="ch.qos.logback.core.ConsoleAppender[m
[31m-[m
[31m-                      <encoder>[m
[31m-                             <pattern>logbak: %d{HH:mm:ss.SSS} %logger{36} - %msg%n</pat[m
[31m-[m
[31m-                      </encoder>[m
[31m-              </appender>[m
[31m-[m
[31m-                  <logger name="org.springframework.web" level="DEBUG"/> <!-[m
[31m-       - 1 -->[m
[31m-[m
[31m-              <root level="info">[m
[31m-                      <appender-ref ref="console"/>[m
[31m-[m
[31m-              </root>[m
[31m-       </configuration>[m
[31m-     代码解释[m
[31m-[m
[31m-     ①将org.springframework.web包下的类的日志级别设置为[m
[31m-DEBUG，我们开发Spring MVC经常出现和参数类型相关的[m
[31m-4XX错误，设置此项我们会看到更详细的错误信息。[m
[31m-[m
[31m-     3.演示页面[m
[31m-[m
[31m-     在src/main/resources下建立views目录，并在此目录下新建[m
[31m-index.jsp，内容如下：[m
[31m-[m
[31m-<%@ page language="java" contentType="text/html; charset=UTF-[m
[31m-[m
[31m-8"[m
[31m-[m
[31m-    pageEncoding="UTF-8"%>[m
[31m-[m
[31m-<!DOCTYPE   html                      PUBLIC  "-[m
[31m-[m
[31m-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loos[m
[31m-[m
[31m-<html>[m
[31m-[m
[31m-<head>[m
[31m-[m
[31m-<meta                                 http-equiv="Content-[m
[31m-[m
[31m-Type" content="text/html; charset=UTF-8">[m
[31m-[m
[31m-<title>Insert title here</title>[m
[31m-[m
[31m-</head>[m
[31m-[m
[31m-<body>[m
[31m-[m
[31m-    <pre>[m
[31m-[m
[31m-         Welcome to Spring MVC world[m
[31m-[m
[31m-    </pre>[m
[31m-[m
[31m-</body>[m
[31m-[m
[31m-</html>[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     此处也许读者会奇怪，为什么页面不放在Maven标准的[m
[31m-src/main/webapp/WEB-INF下，此处这样建的主要目的是让大[m
[31m-家熟悉Spring Boot的页面习惯的放置方式，Spring Boot的页面[m
[31m-就放置在src/main/resources下。[m
[31m-[m
[31m-     4.Spring MVC配置[m
[31m-       package com.wisely.highlight_springmvc4;[m
[31m-[m
[31m-       import org.springframework.context.annotation.ComponentScan;[m
[31m-       import org.springframework.context.annotation.Configuration;[m
[31m-[m
[31m-       @Configuration[m
[31m-       @EnableWebMvc[m
[31m-       @ComponentScan("com.wisely.highlight_springmvc4")[m
[31m-       public class MyMvcConfig{[m
[31m-[m
[31m-              @Bean[m
[31m-              public InternalResourceViewResolver viewResolver(){[m
[31m-[m
[31m-                      InternalResourceViewResolver viewResolver = new InternalResourc[m
[31m-                      viewResolver.setPrefix("/WEB-INF/classes/views/");[m
[31m-                      viewResolver.setSuffix(".jsp");[m
[31m-                      viewResolver.setViewClass(JstlView.class);[m
[31m-                      return viewResolver;[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     此处无任何特别，只是一个普通的Spring配置类。这里我[m
[31m-们配置了一个JSP的ViewResolver，用来映射路径和实际页面[m
[31m-的位置，其中，@EnableWebMvc注解会开启一些默认配置，[m
[31m-如一些ViewResolver或者MessageConverter等。[m
[31m-[m
[31m-     在此处要特别解释一下Spring MVC的ViewResolver，这是[m
[31m-Spring MVC视图（JSP下就是html）渲染的核心机制；Spring[m
[31m-MVC里有一个接口叫做ViewResolver（我们的ViewResolver都[m
[31m-实现该接口），实现这个接口要重写方法[m
[31m-resolveViewName（），这个方法的返回值是接口View，而[m
[31m-View的职责就是使用model、request、response对象，并将渲染[m
[31m-的视图（不一定是html，可能是json、xml、pdf）返回给浏览[m
[31m-器。在4.5.2节我们会介绍更多关于ViewResolver的内容。[m
[31m-[m
[31m-     可能读者对路径前缀配置为/WEB-INF/classes/views/有些奇[m
[31m-怪，怎么和我开发的目录不一致？因为看到的页面效果是运行[m
[31m-[m
[31m-时而不是开发时的代码，运行时代码会将我们的页面自动编译[m
[31m-[m
[31m-到/WEB-INF/classes/views/下，图4-2是运行时的目录结构，这[m
[31m-样我们就能理解前缀为什么写成这样，在Spring Boot中，我们[m
[31m-将使用Thymeleaf作为模板，因而不需要这样的配置。[m
[31m-[m
[31m-         图4-2　运行时的目录结构[m
[31m-[m
[31m-5.Web配置[m
[31m-[m
[31m-package com.wisely.highlight_springmvc4;[m
[31m-[m
[31m-import javax.servlet.ServletContext;[m
[31m-import javax.servlet.ServletException;[m
[31m-import javax.servlet.ServletRegistration.Dynamic;[m
[31m-[m
[31m-import org.springframework.web.WebApplicationInitializer;[m
[31m-import org.springframework.web.context.support.AnnotationConfigWebAppli[m
[31m-import org.springframework.web.servlet.DispatcherServlet;[m
[31m-[m
[31m-public class WebInitializer implements WebApplicationInitializer {//1[m
[31m-[m
[31m-       @Override[m
[31m-       public void onStartup(ServletContext servletContext)[m
[31m-[m
[31m-                     throws ServletException {[m
[31m-              AnnotationConfigWebApplicationContext ctx = new AnnotationConfi[m
[31m-              ctx.register(MyMvcConfig.class);[m
[31m-              ctx.setServletContext(servletContext); //2[m
[31m-[m
[31m-              Dynamic servlet = servletContext.addServlet("dispatcher", new D[m
[31m-              servlet.addMapping("/");[m
[31m-              servlet.setLoadOnStartup(1);[m
[31m-[m
[31m-       }[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①WebApplicationInitializer是Spring提供用来配置Servlet[m
[31m-3.0+配置的接口，从而实现了替代web.xml的位置。实现此接[m
[31m-口将会自动被SpringServletContainerInitializer（用来启动[m
[31m-Servlet 3.0容器）获取到。[m
[31m-[m
[31m-     ②新建WebApplicationContext，注册配置类，并将其和当[m
[31m-前servletContext关联。[m
[31m-[m
[31m-     ③注册Spring MVC的DispatcherServlet。[m
[31m-     6.简单控制器[m
[31m-[m
[31m-       package com.wisely.highlight_springmvc4.web;[m
[31m-       import org.springframework.stereotype.Controller;[m
[31m-       import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-       import org.springframework.web.bind.annotation.ResponseBody;[m
[31m-       @Controller//1[m
[31m-       public class HelloController {[m
[31m-[m
[31m-              @RequestMapping("/index")//2[m
[31m-              public String hello(){[m
[31m-[m
[31m-                      return "index"; //3[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①利用@Controller注解声明是一个控制器。[m
[31m-     ②利用@RequestMapping配置URL和方法之间的映射。[m
[31m-     ③通过上面ViewResolver的Bean配置，返回值为index，说[m
[31m-明我们的页面放置的路径为/WEB-INF/classes/views/index.jsp。[m
[31m-     7.运行[m
[31m-     将程序部署到Tomcat中，启动Tomcat，并访问[m
[31m-http://localhost：8080/highlight_springmvc4/index，如图4-3所[m
[31m-示。[m
[31m-[m
[31m-                            图4-3　将程序部署到Tomcat[m
[31m-4.3　Spring MVC的常用注解[m
[31m-[m
[31m-4.3.1　点睛[m
[31m-[m
[31m-     Spring MVC常用以下几个注解。[m
[31m-[m
[31m-     （1）@Controller[m
[31m-[m
[31m-     @Controller注解在类上，表明这个类是Spring MVC里的[m
[31m-Controller，将其声明为Spring的一个Bean，Dispatcher Servlet[m
[31m-会自动扫描注解了此注解的类（这里和我们在1.3.3节演示用注[m
[31m-解作为拦截方式的例子原理类似），并将Web请求映射到注解[m
[31m-了@RequestMapping的方法上。这里特别指出，在声明普通[m
[31m-Bean的时候，使用@Component、@Service、@Repository和[m
[31m-@Controller是等同的，因为@Service、@Repository、[m
[31m-@Controller都组合了@Compoment元注解；但在Spring MVC声[m
[31m-明控制器Bean的时候，只能使用@Controller。[m
[31m-[m
[31m-     （2）@RequestMapping[m
[31m-[m
[31m-     @RequestMapping注解是用来映射Web请求（访问路径和[m
[31m-参数）、处理类和方法的。@RequestMapping可注解在类或方[m
[31m-法上。注解在方法上的@RequestMapping路径会继承注解在类[m
[31m-上的路径，@RequestMapping支持Servlet的request和response作[m
[31m-为参数，也支持对request和response的媒体类型进行配置。[m
[31m-[m
[31m-     （3）@ResponseBody[m
[31m-[m
[31m-     @ResponseBody支持将返回值放在response体内，而不是[m
[31m-返回一个页面。我们在很多基于Ajax的程序的时候，可以以此[m
[31m-注解返回数据而不是页面；此注解可放置在返回值前或者方法[m
[31m-上。[m
[31m-[m
[31m-     （4）@RequestBody[m
[31m-[m
[31m-     @RequestBody允许request的参数在request体中，而不是在[m
[31m-直接链接在地址后面。此注解放置在参数前。[m
[31m-[m
[31m-     （5）@PathVariable[m
[31m-[m
[31m-     @PathVariable用来接收路径参数，如/news/001，可接收[m
[31m-001作为参数，此注解放置在参数前。[m
[31m-[m
[31m-     （6）@RestController[m
[31m-[m
[31m-     @RestController是一个组合注解，组合了@Controller和[m
[31m-@ResponseBody，这就意味着当你只开发一个和页面交互数据[m
[31m-的控制的时候，需要使用此注解。若没有此注解，要想实现上[m
[31m-述功能，则需自己在代码中加@Controller和@ResponseBody两[m
[31m-个注解。[m
[31m-[m
[31m-     下面的示例将演示这几个注解的使用。[m
[31m-[m
[31m-4.3.2　示例[m
[31m-[m
[31m-     1.传值类[m
[31m-[m
[31m-     添加jackson及相关依赖，获得对象和json或xml之间的转[m
[31m-换：[m
[31m-[m
[31m-       <!--对json和xml格式的支持 -->[m
[31m-                      <dependency>[m
[31m-                             <groupId>com.fasterxml.jackson.dataformat</groupId>[m
[31m-                             <artifactId>jackson-dataformat-xml</artifactId>[m
[31m-                             <version>2.5.3</version>[m
[31m-                      </dependency>[m
[31m-[m
[31m-     这里特别指出，在实际项目中，我们其实主要支持json数[m
[31m-据，没必要同时支持json和xml，因为json比xml更简洁。由于[m
[31m-JavaScript的广泛使用，json成为最推荐的格式，在这种情况[m
[31m-下，我们的依赖包如下（上面的依赖包含下面的依赖）：[m
[31m-[m
[31m-       <dependency>[m
[31m-              <groupId>com.fasterxml.jackson.core</groupId>[m
[31m-              <artifactId>jackson-databind</artifactId>[m
[31m-              <version>2.5.3</version>[m
[31m-[m
[31m-       </dependency>[m
[31m-[m
[31m-     此类用来演示获取request对象参数和返回此对象到[m
[31m-response：[m
[31m-[m
[31m-       package com.wisely.highlight_springmvc4.domain;[m
[31m-[m
[31m-       public class DemoObj {[m
[31m-              private Long id;[m
[31m-              private String name;[m
[31m-[m
[31m-              public DemoObj() { // 1[m
[31m-                      super();[m
[31m-[m
[31m-              }[m
[31m-              public DemoObj(Long id, String name) {[m
[31m-[m
[31m-                      super();[m
[31m-                      this.id = id;[m
[31m-                      this.name = name;[m
[31m-              }[m
[31m-              public Long getId() {[m
[31m-                      return id;[m
[31m-              }[m
[31m-              public void setId(Long id) {[m
[31m-              this.id = id;[m
[31m-       }[m
[31m-       public String getName() {[m
[31m-[m
[31m-              return name;[m
[31m-       }[m
[31m-       public void setName(String name) {[m
[31m-[m
[31m-              this.name = name;[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-代码解释[m
[31m-[m
[31m-①jackson对对象和json做转换时一定需要此空构造。[m
[31m-[m
[31m-2.注解演示控制器[m
[31m-[m
[31m-package com.wisely.highlight_springmvc4.web.ch4_3;[m
[31m-[m
[31m-import javax.servlet.http.HttpServletRequest;[m
[31m-[m
[31m-import org.springframework.stereotype.Controller;[m
[31m-import org.springframework.web.bind.annotation.PathVariable;[m
[31m-import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-import org.springframework.web.bind.annotation.ResponseBody;[m
[31m-[m
[31m-import com.wisely.highlight_springmvc4.domain.DemoObj;[m
[31m-[m
[31m-@Controller // 1[m
[31m-@RequestMapping("/anno") //2[m
[31m-public class DemoAnnoController {[m
[31m-[m
[31m-              @RequestMapping(produces = "text/plain;charset=UTF-[m
[31m-8") // 3[m
[31m-[m
[31m-       public @ResponseBody String index(HttpServletRequest request) { //[m
[31m-              return "url:" + request.getRequestURL() + " can access";[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-       @RequestMapping(value = "/pathvar/{str}", produces = "text/plain;ch[m
[31m-8")// 5[m
[31m-[m
[31m-       public @ResponseBody String demoPathVar(@PathVariable String str,[m
[31m-                     HttpServletRequest request) {[m
[31m-[m
[31m-              return "url:" + request.getRequestURL() + " can access,str: " +[m
[31m-              }[m
[31m-[m
[31m-              @RequestMapping(value = "/requestParam", produces = "text/plain;cha[m
[31m-       8") //6[m
[31m-[m
[31m-              public @ResponseBody String passRequestParam(Long id,[m
[31m-                             HttpServletRequest request) {[m
[31m-[m
[31m-                      return "url:" + request.getRequestURL() + " can access,id: " +[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              @RequestMapping(value = "/obj", produces = "application/json;charse[m
[31m-       8")//7[m
[31m-[m
[31m-              @ResponseBody //8[m
[31m-              public String passObj(DemoObj obj, HttpServletRequest request) {[m
[31m-[m
[31m-                       return "url:" + request.getRequestURL()[m
[31m-                                           + " can access, obj id: " + obj.getId()+" obj name:[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              @RequestMapping(value = { "/name1", "/name2" }, produces = "text/pl[m
[31m-       8")//9[m
[31m-[m
[31m-              public @ResponseBody String remove(HttpServletRequest request) {[m
[31m-[m
[31m-                      return "url:" + request.getRequestURL() + " can access";[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①@Controller注解声明此类是一个控制器。[m
[31m-[m
[31m-     ②@RequestMapping（“/anno”）映射此类的访问路径[m
[31m-是/anno。[m
[31m-[m
[31m-     ③此方法未标注路径，因此使用类级别的路径/anno；[m
[31m-produces可定制返回的response的媒体类型和字符集，或需返回[m
[31m-值是json对象，则设置produces=“application/json；[m
[31m-charset=UTF-8”，在后面的章节我们会演示此项特性。[m
[31m-     ④演示可接受HttpServletRequest作为参数，当然也可以接[m
[31m-受HttpServletReponse作为参数。此处的@ReponseBody用在返[m
[31m-回值前面。[m
[31m-[m
[31m-     ⑤演示接受路径参数，并在方法参数前结合@PathVariable[m
[31m-使用，访问路径为/anno/pathvar/xx。[m
[31m-[m
[31m-     ⑥演示常规的request参数获取，访问路径[m
[31m-为/anno/requestParam？id=1。[m
[31m-[m
[31m-     ⑦演示解释参数到对象，访问路径为/anno/obj？[m
[31m-id=1&name=xx。[m
[31m-[m
[31m-     ⑧@ReponseBody也可以用在方法上。[m
[31m-[m
[31m-     ⑨演示映射不同的路径到相同的方法，访问路径[m
[31m-为/anno/name1或/anno/name2。[m
[31m-[m
[31m-     3.@RestController演示[m
[31m-[m
[31m-       package com.wisely.highlight_springmvc4.web.ch4_3;[m
[31m-[m
[31m-       import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-       import org.springframework.web.bind.annotation.RestController;[m
[31m-[m
[31m-       import com.wisely.highlight_springmvc4.domain.DemoObj;[m
[31m-[m
[31m-       @RestController //1[m
[31m-       @RequestMapping("/rest")[m
[31m-       public class DemoRestController {[m
[31m-[m
[31m-                              @RequestMapping(value = "/getjson",produces=[m
[31m-       {"application/json;charset=UTF-8"}) //2[m
[31m-[m
[31m-              public DemoObj getjson (DemoObj obj){[m
[31m-                      return new DemoObj(obj.getId()+1, obj.getName()+"yy");//3[m
[31m-[m
[31m-              }[m
[31m-                               @RequestMapping(value = "/getxml",produces=[m
[31m-[m
[31m-       {"application/xml;charset=UTF-8"})//4[m
[31m-              public DemoObj getxml(DemoObj obj){[m
[31m-                      return new DemoObj(obj.getId()+1, obj.getName()+"yy");//5[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-     ①使用@RestController，声明是控制器，并且返回数据时[m
[31m-不需要@ResponseBody。[m
[31m-     ②返回数据的媒体类型为json。[m
[31m-     ③直接返回对象，对象会自动转换成json。[m
[31m-     ④返回数据的媒体类型为xml。[m
[31m-     ⑤直接返回对象，对象会自动转换为xml。[m
[31m-     结果如图4-4和图4-5所示。[m
[31m-[m
[31m-  图4-4　访问http://localhost：8080/highlight_springmvc4/rest/getjson？[m
[31m-                                     id=1&name=xx[m
[31m-[m
[31m-   图4-5　访问http://localhost：8080/highlight_springmvc4/rest/getxml？[m
[31m-                                     id=1&name=xx[m
[31m-4.4　Spring MVC基本配置[m
[31m-[m
[31m-Spring  MVC的定制配置需要我们的配置类继承一个[m
[31m-[m
[31m-WebMvcConfigurerAdapter类，并在此类使用@EnableWebMvc[m
[31m-[m
[31m-注解，来开启对Spring MVC的配置支持，这样我们就可以重[m
[31m-[m
[31m-写这个类的方法，完成我们的常用配置。[m
[31m-[m
[31m-     我们将前面的MyMvcConfig配置类继承[m
[31m-WebMvcConfigurerAdapter，本章若不做特别说明，则关于配[m
[31m-置的相关内容都在MyMvcConfig里编写。[m
[31m-[m
[31m-4.4.1　静态资源映射[m
[31m-[m
[31m-     1.点睛[m
[31m-[m
[31m-     程序的静态文件（js、css、图片）等需要直接访问，这时[m
[31m-我们可以在配置里重写addResourceHandlers方法来实现。[m
[31m-[m
[31m-     2.示例[m
[31m-[m
[31m-     （1）添加静态资源[m
[31m-[m
[31m-     同上，我们在src/main/resources下建立assets/js目录，并复[m
[31m-制一个jquery.js放置在此目录下，如图4-6所示。[m
[31m-          图4-6　复制一个jquery.js放置在assetsl.js目录下[m
[31m-[m
[31m-配置代码：[m
[31m-[m
[31m-package com.wisely.highlight_springmvc4;[m
[31m-[m
[31m-import org.springframework.context.annotation.Bean;[m
[31m-import org.springframework.context.annotation.ComponentScan;[m
[31m-import org.springframework.context.annotation.Configuration;[m
[31m-import org.springframework.web.servlet.config.annotation.EnableWebMvc;[m
[31m-import org.springframework.web.servlet.config.annotation.ResourceHandle[m
[31m-import org.springframework.web.servlet.config.annotation.WebMvcConfigur[m
[31m-import org.springframework.web.servlet.view.InternalResourceViewResolve[m
[31m-import org.springframework.web.servlet.view.JstlView;[m
[31m-[m
[31m-@Configuration[m
[31m-@EnableWebMvc//1[m
[31m-@ComponentScan("com.wisely.highlight_springmvc4")[m
[31m-public class MyMvcConfig extends WebMvcConfigurerAdapter{//2[m
[31m-[m
[31m-       @Bean[m
[31m-       public InternalResourceViewResolver viewResolver(){[m
[31m-[m
[31m-              InternalResourceViewResolver viewResolver =[m
[31m-                             new InternalResourceViewResolver();[m
[31m-[m
[31m-              viewResolver.setPrefix("/WEB-INF/classes/views/");[m
[31m-              viewResolver.setSuffix(".jsp");[m
[31m-              viewResolver.setViewClass(JstlView.class);[m
[31m-              return viewResolver;[m
[31m-       }[m
[31m-              @Override[m
[31m-              public void addResourceHandlers(ResourceHandlerRegistry registry) {[m
[31m-[m
[31m-                      registry.addResourceHandler("/assets/**").addResourceLocations([m
[31m-[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①@EnableWebMvc开启SpringMVC支持，若无此句，重写[m
[31m-WebMvcConfigurerAdapter方法无效。[m
[31m-[m
[31m-     ②继承WebMvcConfigurerAdapter类，重写其方法可对[m
[31m-Spring MVC进行配置。[m
[31m-[m
[31m-     ③addResourceLocations指的是文件放置的目录，[m
[31m-addResourceHandler指的是对外暴露的访问路径。[m
[31m-[m
[31m-4.4.2　拦截器配置[m
[31m-[m
[31m-     1.点睛[m
[31m-     拦截器（Interceptor）实现对每一个请求处理前后进行相关[m
[31m-的业务处理，类似于Servlet的Filter。[m
[31m-     可让普通的Bean实现HanlderInterceptor接口或者继承[m
[31m-HandlerInterceptorAdapter类来实现自定义拦截器。[m
[31m-     通过重写WebMvcConfigurerAdapter的addInterceptors方法[m
[31m-来注册自定义的拦截器，本节演示一个简单的拦截器的开发和[m
[31m-配置，业务含义为计算每一次请求的处理时间。[m
[31m-2.示例[m
[31m-[m
[31m-（1）示例拦截器。[m
[31m-[m
[31m-package com.wisely.highlight_springmvc4.interceptor;[m
[31m-[m
[31m-import javax.servlet.http.HttpServletRequest;[m
[31m-import javax.servlet.http.HttpServletResponse;[m
[31m-[m
[31m-import org.springframework.web.servlet.ModelAndView;[m
[31m-import org.springframework.web.servlet.handler.HandlerInterceptorAdapte[m
[31m-[m
[31m-public class DemoInterceptor extends HandlerInterceptorAdapter {//1[m
[31m-[m
[31m-       @Override[m
[31m-       public boolean preHandle(HttpServletRequest request, //2[m
[31m-[m
[31m-                     HttpServletResponse response, Object handler) throws Except[m
[31m-              long startTime = System.currentTimeMillis();[m
[31m-              request.setAttribute("startTime", startTime);[m
[31m-              return true;[m
[31m-       }[m
[31m-[m
[31m-       @Override[m
[31m-       public void postHandle(HttpServletRequest request, //3[m
[31m-[m
[31m-                     HttpServletResponse response, Object handler,[m
[31m-                     ModelAndView modelAndView) throws Exception {[m
[31m-              long startTime = (Long) request.getAttribute("startTime");[m
[31m-              request.removeAttribute("startTime");[m
[31m-              long endTime = System.currentTimeMillis();[m
[31m-[m
[31m-                                                  System.out.println("本次请求处理时间[m
[31m-为:" + new Long(endTime - startTime)+"ms");[m
[31m-[m
[31m-              request.setAttribute("handlingTime", endTime - startTime);[m
[31m-       }[m
[31m-[m
[31m-}[m
[31m-[m
[31m-代码解释[m
[31m-[m
[31m-①继承HandlerInterceptorAdapter类来实现自定义拦截器。[m
[31m-[m
[31m-②重写preHandle方法，在请求发生前执行。[m
[31m-     ③重写postHandle方法，在请求完成后执行。[m
[31m-     （2）配置。[m
[31m-[m
[31m-              @Bean //1[m
[31m-              public DemoInterceptor demoInterceptor(){[m
[31m-[m
[31m-                      return new DemoInterceptor();[m
[31m-              }[m
[31m-              @Override[m
[31m-              public void addInterceptors(InterceptorRegistry registry) {//2[m
[31m-              registry.addInterceptor(demoInterceptor());[m
[31m-              }[m
[31m-[m
[31m-     代码解释[m
[31m-     ①配置拦截器的Bean。[m
[31m-     ②重写addInterceptors方法，注册拦截器。[m
[31m-     （3）运行。在浏览器访问任意路径，如http://localhost：[m
[31m-8080/highlight_springmvc4/index，查看控制台如图4-7所示。[m
[31m-[m
[31m-                                     图4-7　控制台[m
[31m-4.4.3　@ControllerAdvice[m
[31m-[m
[31m-     1.点睛[m
[31m-[m
[31m-     通过@ControllerAdvice，我们可以将对于控制器的全局配[m
[31m-置放置在同一个位置，注解了@Controller的类的方法可使用[m
[31m-@ExceptionHandler、@InitBinder、@ModelAttribute注解到方[m
[31m-法上，这对所有注解了@RequestMapping的控制器内的方法有[m
[31m-效。[m
[31m-[m
[31m-     @ExceptionHandler：用于全局处理控制器里的异常。[m
[31m-[m
[31m-     @InitBinder：用来设置WebDataBinder，WebDataBinder用[m
[31m-来自动绑定前台请求参数到Model中。[m
[31m-[m
[31m-     @ModelAttribute：@ModelAttribute本来的作用是绑定键值[m
[31m-对到Model里，此处是让全局的@RequestMapping都能获得在[m
[31m-此处设置的键值对。[m
[31m-[m
[31m-     本节将演示使用@ExceptionHandler处理全局异常，更人性[m
[31m-化的将异常输出给用户。[m
[31m-[m
[31m-     2.示例[m
[31m-[m
[31m-     （1）定制ControllerAdvice。[m
[31m-[m
[31m-       package com.wisely.highlight_springmvc4.advice;[m
[31m-[m
[31m-       import org.springframework.ui.Model;[m
[31m-       import org.springframework.web.bind.WebDataBinder;[m
[31m-       import org.springframework.web.bind.annotation.ControllerAdvice;[m
[31m-       import org.springframework.web.bind.annotation.ExceptionHandler;[m
[31m-       import org.springframework.web.bind.annotation.InitBinder;[m
[31m-       import org.springframework.web.bind.annotation.ModelAttribute;[m
[31m-       import org.springframework.web.context.request.WebRequest;[m
[31m-import org.springframework.web.servlet.ModelAndView;[m
[31m-[m
[31m-@ControllerAdvice //1[m
[31m-public class ExceptionHandlerAdvice {[m
[31m-[m
[31m-    @ExceptionHandler(value = Exception.class) //2[m
[31m-[m
[31m-    public ModelAndView exception(Exception exception, WebRequest reque[m
[31m-[m
[31m-       ModelAndView modelAndView = new ModelAndView("error");// error[m
[31m-[m
[31m-页面[m
[31m-[m
[31m-       modelAndView.addObject("errorMessage", exception.getMessage());[m
[31m-[m
[31m-       return modelAndView;[m
[31m-[m
[31m-    }[m
[31m-[m
[31m-    @ModelAttribute //3[m
[31m-[m
[31m-    public void addAttributes(Model model) {[m
[31m-           model.addAttribute("msg", "额外信息"); //3[m
[31m-[m
[31m-    }[m
[31m-[m
[31m-       @InitBinder //4[m
[31m-       public void initBinder(WebDataBinder webDataBinder) {[m
[31m-[m
[31m-              webDataBinder.setDisallowedFields("id"); //5[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①@ControllerAdvice声明一个控制器建言，[m
[31m-@ControllerAdvice组合了@Component注解，所以自动注册为[m
[31m-Spring的Bean。[m
[31m-[m
[31m-     ②@ExceptionHandler在此处定义全局处理，通过[m
[31m-@ExceptionHandler的value属性可过滤拦截的条件，在此处我[m
[31m-们可以看出我们拦截所有的Exception。[m
[31m-[m
[31m-     ③此处使用@ModelAttribute注解将键值对添加到全局，所[m
[31m-有注解的@RequestMapping的方法可获得此键值对。[m
[31m-[m
[31m-     ④通过@InitBinder注解定制WebDataBinder。[m
[31m-     ⑤此处演示忽略request参数的id，更多关于WebDataBinder[m
[31m-的配置，请参考WebDataBinder的API文档。[m
[31m-[m
[31m-     （2）演示控制器。[m
[31m-[m
[31m-       package com.wisely.highlight_springmvc4.web.ch4_4;[m
[31m-[m
[31m-       import org.springframework.stereotype.Controller;[m
[31m-       import org.springframework.web.bind.annotation.ModelAttribute;[m
[31m-       import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-[m
[31m-       import com.wisely.highlight_springmvc4.domain.DemoObj;[m
[31m-[m
[31m-       @Controller[m
[31m-       public class AdviceController {[m
[31m-[m
[31m-              @RequestMapping("/advice")[m
[31m-              public String getSomething(@ModelAttribute("msg") String msg,DemoOb[m
[31m-       {//1[m
[31m-[m
[31m-                           throw new IllegalArgumentException("非常抱歉，参数有[m
[31m-       误/"+"来自@ModelAttribute:"+ msg);[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-（3）异常展示页面。[m
[31m-在src/main/resources/views下，新建error.jsp，内容如下：[m
[31m-[m
[31m-<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>[m
[31m-[m
[31m-<%@ page language="java" contentType="text/html; charset=UTF-[m
[31m-[m
[31m-8"[m
[31m-[m
[31m-    pageEncoding="UTF-8"%>[m
[31m-[m
[31m-<!DOCTYPE  html                        PUBLIC  "-[m
[31m-[m
[31m-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loos[m
[31m-[m
[31m-<html>[m
[31m-[m
[31m-<head>[m
[31m-[m
[31m-<meta                                  http-equiv="Content-[m
[31m-[m
[31m-Type" content="text/html; charset=UTF-8">[m
[31m-[m
[31m-<title>@ControllerAdvice Demo</title>[m
[31m-       </head>[m
[31m-       <body>[m
[31m-[m
[31m-              ${errorMessage}[m
[31m-       </body>[m
[31m-       </html>[m
[31m-[m
[31m-     （4）运行。[m
[31m-     访问http://localhost：8080/highlight_springmvc4/advice？[m
[31m-id=1&name=xx。[m
[31m-     调试查看DemoObj，id被过滤掉了，且获得了[m
[31m-@ModelAttribute的msg信息，如图4-8所示。[m
[31m-[m
[31m-                                    图4-8　页面效果[m
[31m-[m
[31m-     页面效果如图4-9所示。[m
[31m-[m
[31m-                                    图4-9　页面效果[m
[31m-[m
[31m-4.4.4　其他配置[m
[31m-[m
[31m-     1.快捷的ViewController[m
[31m-     在4.2.2节我们配置页面转向的时候使用的代码如下：[m
[31m-              @RequestMapping("/index")//2[m
[31m-              public String hello(){[m
[31m-[m
[31m-                      return "index"; //3[m
[31m-              }[m
[31m-[m
[31m-     此处无任何业务处理，只是简单的页面转向，写了至少三[m
[31m-行有效代码；在实际开发中会涉及大量这样的页面转向，若都[m
[31m-这样写会很麻烦，我们可以通过在配置中重写[m
[31m-addViewControllers来简化配置：[m
[31m-[m
[31m-       @Override[m
[31m-              public void addViewControllers(ViewControllerRegistry registry) {[m
[31m-                      registry.addViewController("/index").setViewName("/index");[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     这样实现的代码更简洁，管理更集中。[m
[31m-     2.路径匹配参数配置[m
[31m-     在Spring MVC中，路径参数如果带“.”的话，“.”后面的值[m
[31m-将被忽略，例如，访问http://localhost：[m
[31m-8080/highlight_springmvc4/anno/pathvar/xx.yy，此时“.”后面的[m
[31m-yy被忽略，如图4-10所示。[m
[31m-[m
[31m-                              图4-10　忽略“.”后面的yy[m
[31m-[m
[31m-     通过重写configurePathMatch方法可不忽略“.”后面的参数，[m
[31m-代码如下：[m
[31m-[m
[31m-              @Override[m
[31m-              public void configurePathMatch(PathMatchConfigurer configurer) {[m
[31m-                configurer.setUseSuffixPatternMatch(false);[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-     这时再访问http://localhost：[m
[31m-8080/highlight_springmvc4/anno/pathvar/xx.yy，就可以接[m
[31m-受“.”后面的yy了，如图4-11所示。[m
[31m-[m
[31m-        图4-11　接受“.”后面yy[m
[31m-[m
[31m-3.更多配置[m
[31m-[m
[31m-     更多配置请查看WebMvcConfigurerAdapter类的API。因其[m
[31m-是WebMvcConfigurer接口的实现，所以WebMvcConfigurer的[m
[31m-API内的方法也可以用来配置MVC。下面我们列出了[m
[31m-WebMvcConfigurerAdapter和WebMvcConfigurer的源码。[m
[31m-[m
[31m-4.WebMvcConfigurerAdapter[m
[31m-[m
[31m-public abstract class WebMvcConfigurerAdapter implements WebMvcConfigur[m
[31m-       @Override[m
[31m-       public void addFormatters(FormatterRegistry registry) {[m
[31m-       }[m
[31m-       @Override[m
[31m-       public void configureMessageConverters(List<HttpMessageConverter<?[m
[31m-[m
[31m->> converters) {[m
[31m-       }[m
[31m-       @Override[m
[31m-       public void extendMessageConverters(List<HttpMessageConverter<?[m
[31m-[m
[31m->> converters) {[m
[31m-       }[m
[31m-       @Override[m
[31m-       public Validator getValidator() {[m
[31m-              return null;[m
[31m-       }[m
[31m-       @Override[m
[31m-       public void configureContentNegotiation(ContentNegotiationConfigure[m
[31m-       }[m
[31m-       @Override[m
[31m-       public void configureAsyncSupport(AsyncSupportConfigurer configurer[m
[31m-       }[m
[31m-       @Override[m
[31m-       public void configurePathMatch(PathMatchConfigurer configurer) {[m
[31m-       }[m
[31m-       @Override[m
[31m-       public void addArgumentResolvers(List<HandlerMethodArgumentResolver[m
[31m-       }[m
[31m-       @Override[m
[31m-       public void addReturnValueHandlers(List<HandlerMethodReturnValueHan[m
[31m-       }[m
[31m-       @Override[m
[31m-       public void configureHandlerExceptionResolvers(List<HandlerExceptio[m
[31m-       }[m
[31m-       @Override[m
[31m-       public MessageCodesResolver getMessageCodesResolver() {[m
[31m-[m
[31m-              return null;[m
[31m-       }[m
[31m-       @Override[m
[31m-       public void addInterceptors(InterceptorRegistry registry) {[m
[31m-       }[m
[31m-       @Override[m
[31m-       public void addViewControllers(ViewControllerRegistry registry) {[m
[31m-       }[m
[31m-       @Override[m
[31m-       public void configureViewResolvers(ViewResolverRegistry registry) {[m
[31m-       }[m
[31m-       @Override[m
[31m-       public void addResourceHandlers(ResourceHandlerRegistry registry) {[m
[31m-       }[m
[31m-       @Override[m
[31m-       public void configureDefaultServletHandling(DefaultServletHandlerCo[m
[31m-       }[m
[31m-[m
[31m-}[m
[31m-[m
[31m-5.WebMvcConfigurer[m
[31m-[m
[31m-public interface WebMvcConfigurer {[m
[31m-       void addFormatters(FormatterRegistry registry);[m
[31m-       void configureMessageConverters(List<HttpMessageConverter<?[m
[31m->> converters);[m
[31m-        void extendMessageConverters(List<HttpMessageConverter<?[m
[31m->> converters);[m
[31m-       Validator getValidator();[m
[31m-       void configureContentNegotiation(ContentNegotiationConfigurer confi[m
[31m-       void configureAsyncSupport(AsyncSupportConfigurer configurer);[m
[31m-       void configurePathMatch(PathMatchConfigurer configurer);[m
[31m-       void addArgumentResolvers(List<HandlerMethodArgumentResolver> argum[m
[31m-[m
[31m-       void addReturnValueHandlers(List<HandlerMethodReturnValueHandler> r[m
[31m-       void configureHandlerExceptionResolvers(List<HandlerExceptionResolv[m
[31m-       void addInterceptors(InterceptorRegistry registry);[m
[31m-       MessageCodesResolver getMessageCodesResolver();[m
[31m-       void addViewControllers(ViewControllerRegistry registry);[m
[31m-       void configureViewResolvers(ViewResolverRegistry registry);[m
[31m-       void addResourceHandlers(ResourceHandlerRegistry registry);[m
[31m-       void configureDefaultServletHandling(DefaultServletHandlerConfigure[m
[31m-[m
[31m-}[m
[31m-4.5　Spring MVC的高级配置[m
[31m-[m
[31m-4.5.1　文件上传配置[m
[31m-[m
[31m-     1.点睛[m
[31m-[m
[31m-     文件上传是一个项目里经常要用的功能，Spring MVC通过[m
[31m-配置一个MultipartResolver来上传文件。[m
[31m-[m
[31m-     在Spring的控制器中，通过MultipartFile file来接收文件，[m
[31m-通过MultipartFile[]files接收多个文件上传。[m
[31m-[m
[31m-     2.示例[m
[31m-[m
[31m-     （1）添加文件上传依赖。[m
[31m-[m
[31m-                      <!-- file upload -->[m
[31m-                      <dependency>[m
[31m-[m
[31m-                             <groupId>commons-fileupload</groupId>[m
[31m-                             <artifactId>commons-fileupload</artifactId>[m
[31m-                             <version>1.3.1</version>[m
[31m-                      </dependency>[m
[31m-                      <!-- 非必需，可简化I/O操作 -->[m
[31m-                      <dependency>[m
[31m-                             <groupId>commons-io</groupId>[m
[31m-                             <artifactId>commons-io</artifactId>[m
[31m-                             <version>2.3</version>[m
[31m-                      </dependency>[m
[31m-[m
[31m-     （2）上传页面。在src/main/resources/views下新建[m
[31m-upload.jsp。[m
[31m-<%@ page language="java" contentType="text/html; charset=UTF-[m
[31m-[m
[31m-8"[m
[31m-[m
[31m-    pageEncoding="UTF-8"%>[m
[31m-[m
[31m-<!DOCTYPE  html             PUBLIC                     "-[m
[31m-[m
[31m-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loos[m
[31m-[m
[31m-<html>[m
[31m-[m
[31m-<head>[m
[31m-[m
[31m-<meta                       http-equiv="Content-[m
[31m-[m
[31m-Type" content="text/html; charset=UTF-8">[m
[31m-[m
[31m-<title>upload page</title>[m
[31m-[m
[31m-</head>[m
[31m-<body>[m
[31m-[m
[31m-<div class="upload">[m
[31m-                    <form action="upload" enctype="multipart/form-[m
[31m-[m
[31m-data" method="post">[m
[31m-              <input type="file" name="file"/><br/>[m
[31m-              <input type="submit" value="上传">[m
[31m-[m
[31m-       </form>[m
[31m-</div>[m
[31m-[m
[31m-</body>[m
[31m-</html>[m
[31m-[m
[31m-（3）添加转向到upload页面的ViewController。[m
[31m-[m
[31m-       @Override[m
[31m-       public void addViewControllers(ViewControllerRegistry registry) {[m
[31m-[m
[31m-              registry.addViewController("/index").setViewName("/index");[m
[31m-              registry.addViewController("/toUpload").setViewName("/upload");[m
[31m-       }[m
[31m-[m
[31m-（4）MultipartResolver配置。[m
[31m-[m
[31m-@Bean[m
[31m-       public MultipartResolver multipartResolver() {[m
[31m-              CommonsMultipartResolver multipartResolver =[m
[31m-new CommonsMultipartResolver();[m
[31m-[m
[31m-              multipartResolver.setMaxUploadSize(1000000);[m
[31m-              return multipartResolver;[m
[31m-       }[m
[31m-[m
[31m-（5）控制器。[m
[31m-[m
[31m-package com.wisely.highlight_springmvc4.web.ch4_5;[m
[31m-[m
[31m-import java.io.File;[m
[31m-import java.io.IOException;[m
[31m-[m
[31m-import org.apache.commons.io.FileUtils;[m
[31m-import org.springframework.stereotype.Controller;[m
[31m-import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-import org.springframework.web.bind.annotation.RequestMethod;[m
[31m-import org.springframework.web.bind.annotation.ResponseBody;[m
[31m-import org.springframework.web.multipart.MultipartFile;[m
[31m-[m
[31m-@Controller[m
[31m-public class UploadController {[m
[31m-[m
[31m-       @RequestMapping(value = "/upload",method = RequestMethod.POST)[m
[31m-       public @ResponseBody String upload(MultipartFile file) {//1[m
[31m-[m
[31m-                     try {[m
[31m-                             FileUtils.writeByteArrayToFile(new File("e:/upload/"+fi[m
[31m-                                           file.getBytes()); //2[m
[31m-                             return "ok";[m
[31m-[m
[31m-                     } catch (IOException e) {[m
[31m-                             e.printStackTrace();[m
[31m-                             return "wrong";[m
[31m-[m
[31m-                     }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-}[m
[31m-[m
[31m-代码解释[m
[31m-     ①使用MultipartFile file接受上传的文件。[m
[31m-     ②使用FileUtils.writeByteArrayToFile快速写文件到磁盘。[m
[31m-     （6）运行。访问http://localhost：[m
[31m-8080/highlight_springmvc4/toUpload，如图4-12所示。[m
[31m-[m
[31m-                                      图4-12　访问[m
[31m-[m
[31m-     单击“上传”按钮后，查看e：\upload文件夹，如图4-13所[m
[31m-示。[m
[31m-[m
[31m-                             图4-13　查看upload文件夹[m
[31m-[m
[31m-4.5.2　自定义HttpMessageConverter[m
[31m-[m
[31m-     1.点睛[m
[31m-     HttpMessageConverter是用来处理request和response里的数[m
[31m-据的。Spring为我们内置了大量的HttpMessageConverter，例[m
[31m-如，MappingJackson2HttpMessageConverter、[m
[31m-[m
[31m-StringHttpMessage  Converter等。本节将演示自定义的[m
[31m-[m
[31m-HttpMessageConverter，并注册这个HttpMessageConverter到[m
[31m-[m
[31m-Spring MVC。[m
[31m-[m
[31m-2.示例[m
[31m-[m
[31m-（1）自定义HttpMessageConverter。[m
[31m-[m
[31m-package com.wisely.highlight_springmvc4.messageconverter;[m
[31m-[m
[31m-import java.io.IOException;[m
[31m-import java.nio.charset.Charset;[m
[31m-[m
[31m-import org.springframework.http.HttpInputMessage;[m
[31m-import org.springframework.http.HttpOutputMessage;[m
[31m-import org.springframework.http.MediaType;[m
[31m-import org.springframework.http.converter.AbstractHttpMessageConverter;[m
[31m-import org.springframework.http.converter.HttpMessageNotReadableExcepti[m
[31m-import org.springframework.http.converter.HttpMessageNotWritableExcepti[m
[31m-import org.springframework.util.StreamUtils;[m
[31m-[m
[31m-import com.wisely.highlight_springmvc4.domain.DemoObj;[m
[31m-[m
[31m-public class MyMessageConverter extends AbstractHttpMessageConverter<De[m
[31m-[m
[31m-       public MyMessageConverter() {                                    "x-[m
[31m-                                    super(new MediaType("application",[m
[31m-[m
[31m-wisely",Charset.forName("UTF-8")));//2[m
[31m-       }[m
[31m-[m
[31m-/**[m
[31m- *3[m
[31m- */[m
[31m-[m
[31m-@Override[m
[31m-protected DemoObj readInternal(Class<? extends DemoObj> clazz,[m
[31m-[m
[31m-              HttpInputMessage inputMessage) throws IOException,[m
[31m-              HttpMessageNotReadableException {[m
[31m-       String temp = StreamUtils.copyToString(inputMessage.getBody(),[m
[31m-[m
[31m-      Charset.forName("UTF-8"));[m
[31m-      String[] tempArr = temp.split("-");[m
[31m-                      return new DemoObj(new Long(tempArr[0]), tempArr[1]);[m
[31m-              }[m
[31m-[m
[31m-              /**[m
[31m-                *4[m
[31m-                */[m
[31m-[m
[31m-              @Override[m
[31m-              protected boolean supports(Class<?> clazz) {[m
[31m-[m
[31m-                      return DemoObj.class.isAssignableFrom(clazz);[m
[31m-              }[m
[31m-[m
[31m-              /**[m
[31m-                *5[m
[31m-                */[m
[31m-[m
[31m-              @Override[m
[31m-              protected void writeInternal(DemoObj obj, HttpOutputMessage outputM[m
[31m-[m
[31m-                             throws IOException, HttpMessageNotWritableException {[m
[31m-                      String out = "hello:" + obj.getId() + "-"[m
[31m-[m
[31m-                                    + obj.getName();[m
[31m-                      outputMessage.getBody().write(out.getBytes());[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①继承AbstractHttpMessageConverter接口来实现自定义的[m
[31m-HttpMessageConverter。[m
[31m-[m
[31m-     ②新建一个我们自定义的媒体类型application/x-wisely。[m
[31m-[m
[31m-     ③重写readIntenal方法，处理请求的数据。代码表明我们[m
[31m-处理由“-”隔开的数据，并转成DemoObj的对象。[m
[31m-[m
[31m-     ④表明本HttpMessageConverter只处理DemoObj这个类。[m
[31m-[m
[31m-     ⑤重写writeInternal，处理如何输出数据到response。此例[m
[31m-中，我们在原样输出前面加上“hello：”。[m
[31m-[m
[31m-     （2）配置。在addViewControllers中添加viewController映[m
[31m-射页面访问演示页面，代码如下：[m
[31m-[m
[31m-       registry.addViewController("/converter").setViewName("/converter");[m
[31m-[m
[31m-     配置自定义的HttpMessageConverter的Bean，在Spring[m
[31m-MVC里注册HttpMessageConverter有两个方法：[m
[31m-[m
[31m-     configureMessageConverters：重载会覆盖掉Spring MVC默[m
[31m-     认注册的多个HttpMessageConverter。[m
[31m-     extendMessageConverters：仅添加一个自定义的[m
[31m-     HttpMessageConverter，不覆盖默认注册的[m
[31m-     HttpMessageConverter。[m
[31m-     所以在此例中我们重写extendMessageConverters：[m
[31m-[m
[31m-              @Override[m
[31m-              public void extendMessageConverters(List<HttpMessageConverter<?[m
[31m-       >> converters) {[m
[31m-[m
[31m-                      converters.add(converter());[m
[31m-              }[m
[31m-[m
[31m-              @Bean[m
[31m-              public MyMessageConverter converter(){[m
[31m-[m
[31m-                      return new MyMessageConverter();[m
[31m-              }[m
[31m-[m
[31m-     （3）演示控制器。[m
[31m-[m
[31m-       package com.wisely.highlight_springmvc4.web.ch4_5;[m
[31m-[m
[31m-       import org.springframework.stereotype.Controller;[m
[31m-       import org.springframework.web.bind.annotation.RequestBody;[m
[31m-       import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-import org.springframework.web.bind.annotation.ResponseBody;[m
[31m-[m
[31m-import com.wisely.highlight_springmvc4.domain.DemoObj;[m
[31m-[m
[31m-@Controller[m
[31m-public class ConverterController {[m
[31m-[m
[31m-       @RequestMapping(value = "/convert", produces = { "application/x-[m
[31m-wisely" }) //1[m
[31m-[m
[31m-       public @ResponseBody DemoObj convert(@RequestBody DemoObj demoObj)[m
[31m-[m
[31m-              return demoObj;[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-}[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①指定返回的媒体类型为我们自定义的媒体类型[m
[31m-application/x-wisely。[m
[31m-[m
[31m-     （4）演示页面。在src/main/resources下新建conventer.jsp：[m
[31m-[m
[31m-<%@ page language="java" contentType="text/html; charset=UTF-[m
[31m-[m
[31m-8"[m
[31m-[m
[31m-    pageEncoding="UTF-8"%>[m
[31m-[m
[31m-<!DOCTYPE            html         PUBLIC            "-[m
[31m-[m
[31m-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loos[m
[31m-[m
[31m-<html>[m
[31m-[m
[31m-<head>[m
[31m-[m
[31m-<meta                                     http-equiv="Content-[m
[31m-[m
[31m-Type" content="text/html; charset=UTF-8">[m
[31m-[m
[31m-<title>HttpMessageConverter Demo</title>[m
[31m-[m
[31m-</head>[m
[31m-[m
[31m-<body>[m
[31m-[m
[31m-                            <div           id="resp"></div>[m
[31m-[m
[31m-<input type="button" onclick="req();" value="请求"/>[m
[31m-[m
[31m-<script src="assets/js/jquery.js" type="text/javascript">[m
[31m-[m
[31m-</script>[m
[31m-[m
[31m-<script>[m
[31m-[m
[31m-    function req(){[m
[31m-                      $.ajax({[m
[31m-                             url: "convert",[m
[31m-                             data: "1-wangyunfei", //1[m
[31m-                             type:"POST",[m
[31m-                             contentType:"application/x-wisely", //2[m
[31m-                             success: function(data){[m
[31m-                                    $("#resp").html(data);[m
[31m-                             }[m
[31m-[m
[31m-                      });[m
[31m-              }[m
[31m-[m
[31m-       </script>[m
[31m-       </body>[m
[31m-       </html>[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①注意这里的数据格式，后台处理按此格式处理，用“-”隔[m
[31m-开。[m
[31m-[m
[31m-     ②contentType设置的媒体类型是我们自定义的[m
[31m-application/x-wisely。[m
[31m-[m
[31m-     （5）运行。访问http://localhost：[m
[31m-8080/highlight_springmvc4/converter，如图4-14所示。[m
[31m-[m
[31m-    图4-14　访问http://localhost：8080/highlight_springmvc4/converter[m
[31m-[m
[31m-     单击“请求”按钮，做如下观察。[m
[31m-[m
[31m-     请求类型如图4-15所示。[m
[31m-                                   图4-15　请求类型[m
[31m-[m
[31m-     后台获得我们自定义的数据格式，如图4-16所示。[m
[31m-[m
[31m-                             图4-16　自定义的数据格式[m
[31m-[m
[31m-     页面效果如图4-17所示。[m
[31m-[m
[31m-                                   图4-17　页面效果[m
[31m-[m
[31m-4.5.3　服务器端推送技术[m
[31m-[m
[31m-     服务端推送技术在我们日常开发中较为常用，可能早期很[m
[31m-多人的解决方案是使用Ajax向服务器轮询消息，使浏览器尽可[m
[31m-能第一时间获得服务端的消息，因为这种方式的轮询频率不好[m
[31m-控制，所以大大增加了服务端的压力。[m
[31m-[m
[31m-     本节所有的服务器端推送的方案都是基于：当客户端向服[m
[31m-务端发送请求，服务端会抓住这个请求不放，等有数据更新的[m
[31m-时候才返回给客户端，当客户端接收到消息后，再向服务端发[m
[31m-送请求，周而复始。这种方式的好处是减少了服务器的请求数[m
[31m-量，大大减少了服务器的压力。[m
[31m-[m
[31m-     除了服务器端推送技术以外，还有一个另外的双向通信的[m
[31m-技术——WebSocket，我们将在本书第三部分实战Spring Boot[m
[31m-中演示。[m
[31m-[m
[31m-     本节将提供基于SSE（Server Send Event服务端发送事件）[m
[31m-的服务器端推送和基于Servlet 3.0+的异步方法特性，其中第一[m
[31m-种方式需要新式浏览器的支持，第二种方式是跨浏览器的。[m
[31m-[m
[31m-     1.SSE[m
[31m-[m
[31m-     （1）演示控制器。[m
[31m-[m
[31m-       package com.wisely.highlight_springmvc4.web.ch4_5;[m
[31m-[m
[31m-       import java.util.Random;[m
[31m-[m
[31m-       import org.springframework.stereotype.Controller;[m
[31m-       import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-       import org.springframework.web.bind.annotation.ResponseBody;[m
[31m-[m
[31m-       @Controller[m
[31m-       public class SseController {[m
[31m-[m
[31m-                         @RequestMapping(value="/push",produces="text/event-[m
[31m-       stream") //1[m
[31m-[m
[31m-              public @ResponseBody String push(){[m
[31m-                       Random r = new Random();[m
[31m-[m
[31m-                      try {[m
[31m-                             Thread.sleep(5000);[m
[31m-              } catch (InterruptedException e) {[m
[31m-[m
[31m-                             e.printStackTrace();[m
[31m-              }[m
[31m-              return "data:Testing 1,2,3" + r.nextInt() +"\n\n";[m
[31m-       }[m
[31m-[m
[31m-}[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①注意，这里使用输出的媒体类型为text/event-stream，这[m
[31m-是服务器端SSE的支持，本例演示每5秒钟向浏览器推送随机[m
[31m-消息。[m
[31m-[m
[31m-     （2）演示页面。在src/main/resources/views下新建sse.jsp：[m
[31m-[m
[31m-<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>[m
[31m-[m
[31m-<%@ page language="java" contentType="text/html; charset=UTF-[m
[31m-[m
[31m-8"[m
[31m-[m
[31m-    pageEncoding="UTF-8"%>[m
[31m-[m
[31m-<!DOCTYPE  html                  PUBLIC                           "-[m
[31m-[m
[31m-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loos[m
[31m-[m
[31m-<html>[m
[31m-[m
[31m-<head>[m
[31m-[m
[31m-<meta                            http-equiv="Content-[m
[31m-[m
[31m-Type" content="text/html; charset=UTF-8">[m
[31m-[m
[31m-<title>SSE Demo</title>[m
[31m-[m
[31m-</head>[m
[31m-<body>[m
[31m-[m
[31m-<div id="msgFrompPush"></div>[m
[31m-[m
[31m-<script    type="text/javascript"                 src="[m
[31m-[m
[31m-<c:url value="assets/js/jquery.js" />"></script>[m
[31m-[m
[31m-<script type="text/javascript">[m
[31m-[m
[31m-if (!!window.EventSource) { //1[m
[31m-          var source = new EventSource('push');[m
[31m-                    s='';[m
[31m-                    source.addEventListener('message', function(e) {//2[m
[31m-[m
[31m-                           s+=e.data+"<br/>";[m
[31m-                           $("#msgFrompPush").html(s);[m
[31m-[m
[31m-                    });[m
[31m-[m
[31m-                    source.addEventListener('open', function(e) {[m
[31m-                             console.log("连接打开.");[m
[31m-[m
[31m-                    }, false);[m
[31m-[m
[31m-                    source.addEventListener('error', function(e) {[m
[31m-                             if (e.readyState == EventSource.CLOSED) {[m
[31m-                                  console.log("连接关闭");[m
[31m-                             } else {[m
[31m-                                    console.log(e.readyState);[m
[31m-                             }[m
[31m-[m
[31m-                    }, false);[m
[31m-              } else {[m
[31m-[m
[31m-                             console.log("你的浏览器不支持SSE");[m
[31m-              }[m
[31m-       </script>[m
[31m-       </body>[m
[31m-       </html>[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①EventSource对象只有新式的浏览器才有（Chrome、[m
[31m-Firefox）等，EventSource是SSE的客户端；[m
[31m-[m
[31m-     ②添加SSE客户端监听，在此获得服务器端推送的消息。[m
[31m-[m
[31m-     （3）配置。[m
[31m-[m
[31m-     添加转向sse.jsp页面的映射：[m
[31m-[m
[31m-       registry.addViewController("/sse").setViewName("/sse");[m
[31m-     （4）运行。访问http://localhost：[m
[31m-8080/highlight_springmvc4/sse，如图4-18所示。[m
[31m-[m
[31m-                                   图4-18　运行效果[m
[31m-[m
[31m-     2.Servlet 3.0+异步方法处理[m
[31m-     （1）开启异步方法支持：[m
[31m-[m
[31m-              Dynamic servlet = servletContext.addServlet("dispatcher", new Dispa[m
[31m-                      servlet.addMapping("/");[m
[31m-                      servlet.setLoadOnStartup(1);[m
[31m-                      servlet.setAsyncSupported(true);//1[m
[31m-[m
[31m-     代码解释[m
[31m-     ①此句开启异步方法支持。[m
[31m-     （2）演示控制器：[m
[31m-[m
[31m-       package com.wisely.highlight_springmvc4.web.ch4_5;[m
[31m-       import org.springframework.beans.factory.annotation.Autowired;[m
[31m-       import org.springframework.stereotype.Controller;[m
[31m-       import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-       import org.springframework.web.bind.annotation.ResponseBody;[m
[31m-       import org.springframework.web.context.request.async.DeferredResult;[m
[31m-[m
[31m-       import com.wisely.highlight_springmvc4.service.PushService;[m
[31m-[m
[31m-       @Controller[m
[31m-       public class AysncController {[m
[31m-[m
[31m-              @Autowired[m
[31m-              PushService pushService; //1[m
[31m-[m
[31m-              @RequestMapping("/defer")[m
[31m-              @ResponseBody[m
[31m-              public DeferredResult<String> deferredCall() { //2[m
[31m-[m
[31m-                      return pushService.getAsyncUpdate();[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     异步任务的实现是通过控制器从另外一个线程返回一个[m
[31m-DeferredResult，这里的DeferredResult是从pushService中获得[m
[31m-的。[m
[31m-[m
[31m-     ①定时任务，定时更新DeferredResult。[m
[31m-[m
[31m-     ②返回给客户端DeferredResult。[m
[31m-[m
[31m-     （3）定时任务：[m
[31m-[m
[31m-       package com.wisely.highlight_springmvc4.service;[m
[31m-[m
[31m-       import org.springframework.scheduling.annotation.Scheduled;[m
[31m-       import org.springframework.stereotype.Service;[m
[31m-       import org.springframework.web.context.request.async.DeferredResult;[m
[31m-[m
[31m-       @Service[m
[31m-       public class PushService {[m
[31m-[m
[31m-              private DeferredResult<String> deferredResult; //1[m
[31m-       public DeferredResult<String> getAsyncUpdate() {//1[m
[31m-              deferredResult = new DeferredResult<String>();[m
[31m-              return deferredResult;[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-       @Scheduled(fixedDelay = 5000)[m
[31m-       public void refresh() {//1[m
[31m-[m
[31m-              if (deferredResult != null) {[m
[31m-                     deferredResult.setResult(new Long(System.currentTimeMillis([m
[31m-                                    .toString());[m
[31m-[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-}[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①在PushService里产生DeferredResult给控制器使用，通过[m
[31m-@Scheduled注解的方法定时更新DeferredResult。[m
[31m-[m
[31m-     （4）演示页面[m
[31m-[m
[31m-     在src/main/resources/views下新建async.jsp：[m
[31m-[m
[31m-<%@ page language="java" contentType="text/html; charset=UTF-[m
[31m-[m
[31m-8"[m
[31m-[m
[31m-    pageEncoding="UTF-8"%>[m
[31m-[m
[31m-<!DOCTYPE  html                       PUBLIC  "-[m
[31m-[m
[31m-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loos[m
[31m-[m
[31m-<html>[m
[31m-[m
[31m-<head>[m
[31m-[m
[31m-<meta                                 http-equiv="Content-[m
[31m-[m
[31m-Type" content="text/html; charset=UTF-8">[m
[31m-[m
[31m-<title>servlet async support</title>[m
[31m-[m
[31m-</head>                          src="assets/js/jquery.js">[m
[31m-<body>[m
[31m-<script type="text/javascript"[m
[31m-</script>[m
[31m-<script type="text/javascript">[m
[31m-              deferred();//1[m
[31m-[m
[31m-              function deferred(){[m
[31m-                      $.get('defer',function(data){[m
[31m-                             console.log(data); //2[m
[31m-                             deferred(); //3[m
[31m-                      });[m
[31m-[m
[31m-              }[m
[31m-       </script>[m
[31m-       </body>[m
[31m-       </html>[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     此处的代码使用的是jQuery的Ajax请求，所以没有浏览器[m
[31m-兼容性问题。[m
[31m-[m
[31m-     ①页面打开就向后台发送请求。[m
[31m-[m
[31m-     ②在控制台输出服务端推送的数据。[m
[31m-[m
[31m-     ③一次请求完成后再向后台发送请求。[m
[31m-[m
[31m-     （5）配置。[m
[31m-[m
[31m-     在MyMvcConfig上开始计划任务的支持，使用[m
[31m-@EnableScheduling：[m
[31m-[m
[31m-       @Configuration[m
[31m-       @EnableWebMvc[m
[31m-       @EnableScheduling[m
[31m-       @ComponentScan("com.wisely.highlight_springmvc4")[m
[31m-       public class MyMvcConfig extends WebMvcConfigurerAdapter{[m
[31m-[m
[31m-       }[m
[31m-     添加viewController：[m
[31m-[m
[31m-       registry.addViewController("/async").setViewName("/async");[m
[31m-[m
[31m-     （6）运行。访问http://localhost：[m
[31m-8080/highlight_springmvc4/async，如图4-19所示。[m
[31m-[m
[31m-                                   图4-19　运行效果[m
[31m-[m
[31m-     控制台输出如图4-20所示。[m
[31m-[m
[31m-                                 图4-20　控制台输出[m
[31m-4.6　Spring MVC的测试[m
[31m-[m
[31m-4.6.1　点睛[m
[31m-[m
[31m-     测试是保证软件质量的关键，所以我们在“第一部分点睛[m
[31m-Spring 4.x”、“第二部分点睛Spring MVC 4.x”和“第三部分实战[m
[31m-Spring Boot”中都将会有测试相关的内容。[m
[31m-[m
[31m-     在第一部分，我们只谈了简单的测试。在本节，我们要进[m
[31m-行一些和Spring MVC相关的测试，主要涉及控制器的测试。[m
[31m-[m
[31m-     为了测试Web项目通常不需要启动项目，我们需要一些[m
[31m-Servlet相关的模拟对象，比如：MockMVC、[m
[31m-MockHttpServletRequest、MockHttpServletResponse、[m
[31m-MockHttpSession等。[m
[31m-[m
[31m-     在Spring里，我们使用@WebAppConfiguration指定加载的[m
[31m-ApplicationContext是一个WebApplicationContext。[m
[31m-[m
[31m-可能许多人，包括我自己以前也觉得测试有什么用，自己[m
[31m-[m
[31m-启动一下，点点弄弄，就像我们前面的例子不也都是这样测试[m
[31m-[m
[31m-的吗？其实在现实开发中，我们是先有需求的，也就是说先知[m
[31m-[m
[31m-道我们想要的是什么样的，然后按照我们想要的样子去开发。[m
[31m-[m
[31m-在这里我也要引入一个概念叫测试驱动开发（Test  Driven[m
[31m-[m
[31m-Development，TDD），我们（设计人员）按照需求先写一个[m
[31m-[m
[31m-自己预期结果的测试用例，这个测试用例刚开始肯定是失败的[m
[31m-[m
[31m-测试，随着不断的编码和重构，最终让测试用例通过测试，这[m
[31m-[m
[31m-样才能保证软件的质量和可控性。[m
[31m-在下面的示例里我们借助JUnit和Spring     TestContext[m
[31m-[m
[31m-framework，分别演示对普通页面转向形控制器和[m
[31m-[m
[31m-RestController进行测试。[m
[31m-[m
[31m-4.6.2　示例[m
[31m-[m
[31m-（1）测试依赖：[m
[31m-[m
[31m-<dependency>[m
[31m-                     <groupId>org.springframework</groupId>[m
[31m-                     <artifactId>spring-test</artifactId>[m
[31m-                     <version>${spring-framework.version}</version>[m
[31m-                     <scope>test</scope>[m
[31m-[m
[31m-              </dependency>[m
[31m-[m
[31m-              <dependency>[m
[31m-                     <groupId>junit</groupId>[m
[31m-                     <artifactId>junit</artifactId>[m
[31m-                     <version>4.11</version>[m
[31m-                     <scope>test</scope>[m
[31m-[m
[31m-              </dependency>[m
[31m-[m
[31m-     代码解释[m
[31m-     这里<scope>test</scope>说明这些包的存活是在test周期，[m
[31m-也就意味着发布时我们将不包含这些jar包。[m
[31m-     （2）演示服务：[m
[31m-[m
[31m-       package com.wisely.highlight_springmvc4.service;[m
[31m-       import org.springframework.stereotype.Service;[m
[31m-       @Service[m
[31m-       public class DemoService {[m
[31m-       public String saySomething(){[m
[31m-              return "hello";[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-}[m
[31m-[m
[31m-（3）测试用例，在src/test/java下：[m
[31m-[m
[31m-package com.wisely.highlight_springmvc4.web.ch4_6;[m
[31m-[m
[31m-import static org.springframework.test.web.servlet.request.MockMvcReque[m
[31m-import static org.springframework.test.web.servlet.result.MockMvcResult[m
[31m-import static org.springframework.test.web.servlet.result.MockMvcResult[m
[31m-import static org.springframework.test.web.servlet.result.MockMvcResult[m
[31m-import static org.springframework.test.web.servlet.result.MockMvcResult[m
[31m-import static org.springframework.test.web.servlet.result.MockMvcResult[m
[31m-[m
[31m-import org.junit.Before;[m
[31m-import org.junit.Test;[m
[31m-import org.junit.runner.RunWith;[m
[31m-import org.springframework.beans.factory.annotation.Autowired;[m
[31m-import org.springframework.mock.web.MockHttpServletRequest;[m
[31m-import org.springframework.mock.web.MockHttpSession;[m
[31m-import org.springframework.test.context.ContextConfiguration;[m
[31m-import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;[m
[31m-import org.springframework.test.context.web.WebAppConfiguration;[m
[31m-import org.springframework.test.web.servlet.MockMvc;[m
[31m-import org.springframework.test.web.servlet.setup.MockMvcBuilders;[m
[31m-import org.springframework.web.context.WebApplicationContext;[m
[31m-[m
[31m-import com.wisely.highlight_springmvc4.MyMvcConfig;[m
[31m-import com.wisely.highlight_springmvc4.service.DemoService;[m
[31m-[m
[31m-@RunWith(SpringJUnit4ClassRunner.class)[m
[31m-@ContextConfiguration(classes = {MyMvcConfig.class})[m
[31m-@WebAppConfiguration("src/main/resources") //1[m
[31m-public class TestControllerIntegrationTests {[m
[31m-[m
[31m-       private MockMvc mockMvc; //2[m
[31m-[m
[31m-       @Autowired[m
[31m-       private DemoService demoService;//3[m
[31m-              @Autowired[m
[31m-              WebApplicationContext wac; //4[m
[31m-[m
[31m-              @Autowired[m
[31m-              MockHttpSession session; //5[m
[31m-[m
[31m-              @Autowired[m
[31m-              MockHttpServletRequest request; //6[m
[31m-[m
[31m-              @Before //7[m
[31m-              public void setup() {[m
[31m-              this.mockMvc =[m
[31m-[m
[31m-                               MockMvcBuilders.webAppContextSetup(this.wac).build(); //2[m
[31m-              }[m
[31m-[m
[31m-              @Test[m
[31m-              public void testNormalController() throws Exception{[m
[31m-[m
[31m-                      mockMvc.perform(get("/normal")) //8[m
[31m-                                    .andExpect(status().isOk())//9[m
[31m-                                    .andExpect(view().name("page"))//10[m
[31m-                                                               .andExpect(forwardedUrl("/WEB-[m
[31m-[m
[31m-       INF/classes/views/page.jsp"))//11[m
[31m-                                    .andExpect(model().attribute("msg", demoService.saySome[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              @Test[m
[31m-              public void testRestController() throws Exception{[m
[31m-[m
[31m-                      mockMvc.perform(get("/testRest")) //13[m
[31m-                      .andExpect(status().isOk())[m
[31m-[m
[31m-                       .andExpect(content().contentType("text/plain;charset=UTF-[m
[31m-       8"))//14[m
[31m-[m
[31m-                      .andExpect(content().string(demoService.saySomething()));//15[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①@WebAppConfiguration注解在类上，用来声明加载的[m
[31m-ApplicationContex是一个WebApplicationContext。它的属性指[m
[31m-定的是Web资源的位置，默认为src/main/webapp，本例修改为[m
[31m-src/main/resources。[m
[31m-[m
[31m-     ②MockMvc-模拟MVC对象，通过[m
[31m-MockMvcBuilders.webAppContextSetup（this.wac）.build（）[m
[31m-初始化。[m
[31m-[m
[31m-     ③可以在测试用例中注入Spring的Bean。[m
[31m-[m
[31m-     ④可注入WebApplicationContext。[m
[31m-[m
[31m-     ⑤可注入模拟的http session，此处仅作演示，没有使用。[m
[31m-[m
[31m-     ⑥可注入模拟的http request，此处仅作演示，没有使用。[m
[31m-[m
[31m-     ⑦@Before在测试开始前进行的初始化工作。[m
[31m-[m
[31m-     ⑧模拟向/normal进行get请求。[m
[31m-[m
[31m-     ⑨预期控制返回状态为200。[m
[31m-[m
[31m-     ⑩预期view的名称为page。[m
[31m-[m
[31m-     ⑪预期页面转向的真正路径为/WEB-[m
[31m-INF/classes/views/page.jsp。[m
[31m-[m
[31m-     ⑫预期model里的值是demoService.saySomething（）返回[m
[31m-值hello。[m
[31m-[m
[31m-     ⑬模拟向/testRest进行get请求。[m
[31m-[m
[31m-     ⑭预期返回值的媒体类型为text/plain；charset=UTF-8。[m
[31m-[m
[31m-     ⑮预期返回值的内容为demoService.saySomething（）返回[m
[31m-值hello。[m
[31m-此时运行该测试效果如图4-21所示。[m
[31m-[m
[31m-                             图4-21　测试效果[m
[31m-[m
[31m-（4）编写普通控制器。[m
[31m-[m
[31m-package com.wisely.highlight_springmvc4.web.ch4_6;[m
[31m-import org.springframework.beans.factory.annotation.Autowired;[m
[31m-import org.springframework.stereotype.Controller;[m
[31m-import org.springframework.ui.Model;[m
[31m-import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-import com.wisely.highlight_springmvc4.service.DemoService;[m
[31m-@Controller[m
[31m-public class NormalController {[m
[31m-[m
[31m-       @Autowired[m
[31m-       DemoService demoService;[m
[31m-[m
[31m-       @RequestMapping("/normal")[m
[31m-       public String testPage(Model model){[m
[31m-[m
[31m-              model.addAttribute("msg", demoService.saySomething());[m
[31m-              return "page";[m
[31m-       }[m
[31m-}[m
[31m-     （5）编写普通控制器的演示页面，在[m
[31m-src/main/resources/views下新建page.jsp：[m
[31m-[m
[31m-<%@ page language="java" contentType="text/html; charset=UTF-[m
[31m-[m
[31m-8"[m
[31m-[m
[31m-    pageEncoding="UTF-8"%>[m
[31m-[m
[31m-<!DOCTYPE   html                      PUBLIC  "-[m
[31m-[m
[31m-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loos[m
[31m-[m
[31m-<html>[m
[31m-[m
[31m-<head>[m
[31m-[m
[31m-<meta                                 http-equiv="Content-[m
[31m-[m
[31m-Type" content="text/html; charset=UTF-8">[m
[31m-[m
[31m-<title>Test page</title>[m
[31m-[m
[31m-</head>[m
[31m-[m
[31m-<body>[m
[31m-[m
[31m-    <pre>[m
[31m-[m
[31m-         Welcome to Spring MVC world[m
[31m-[m
[31m-    </pre>[m
[31m-[m
[31m-</body>[m
[31m-[m
[31m-</html>[m
[31m-[m
[31m-（6）编写RestController控制器：[m
[31m-[m
[31m-package com.wisely.highlight_springmvc4.web.ch4_6;[m
[31m-[m
[31m-import org.springframework.beans.factory.annotation.Autowired;[m
[31m-import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-import org.springframework.web.bind.annotation.ResponseBody;[m
[31m-import org.springframework.web.bind.annotation.RestController;[m
[31m-[m
[31m-import com.wisely.highlight_springmvc4.service.DemoService;[m
[31m-[m
[31m-@RestController[m
[31m-public class MyRestController {[m
[31m-[m
[31m-       @Autowired[m
[31m-       DemoService demoService;[m
[31m-[m
[31m-       @RequestMapping(value = "/testRest" ,produces="text/plain;charset=U[m
[31m-8")[m
[31m-[m
[31m-       public @ResponseBody String testRest(){[m
[31m-              return demoService.saySomething();[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-（7）运行测试，效果加图4-22所示。[m
[31m-[m
[31m-                             图4-22　测试效果[m
[31m-       第三部分　实战Spring Boot[m
[31m-[m
[31m-第5章　Spring Boot基础[m
[31m-[m
[31m-5.1　Spring Boot概述[m
[31m-[m
[31m-5.1.1　什么是Spring Boot[m
[31m-[m
[31m-     随着动态语言的流行（Ruby、Groovy、Scala、[m
[31m-Node.js），Java的开发显得格外的笨重：繁多的配置、低下的[m
[31m-开发效率、复杂的部署流程以及第三方技术集成难度大。[m
[31m-[m
[31m-     在上述环境下，Spring Boot应运而生。它使用“习惯优于配[m
[31m-置”（项目中存在大量的配置，此外还内置一个习惯性的配[m
[31m-置，让你无须手动进行配置）的理念让你的项目快速运行起[m
[31m-来。使用Spring Boot很容易创建一个独立运行（运行jar，内嵌[m
[31m-Servlet容器）、准生产级别的基于Spring框架的项目，使用[m
[31m-Spring Boot你可以不用或者只需要很少的Spring配置。[m
[31m-[m
[31m-5.1.2　Spring Boot核心功能[m
[31m-[m
[31m-     1.独立运行的Spring项目[m
[31m-     Spring Boot可以以jar包的形式独立运行，运行一个Spring[m
[31m-Boot项目只需通过java–jar xx.jar来运行。[m
[31m-[m
[31m-     2.内嵌Servlet容器[m
[31m-     Spring Boot可选择内嵌Tomcat、Jetty或者Undertow，这样[m
[31m-我们无须以war包形式部署项目。[m
[31m-     3.提供starter简化Maven配置[m
[31m-     Spring提供了一系列的starter pom来简化Maven的依赖加[m
[31m-载，例如，当你使用了spring-boot-starter-web时，会自动加入[m
[31m-如图5-1所示的依赖包。[m
[31m-[m
[31m-                              图5-1　自动加入的依赖包[m
[31m-[m
[31m-     4.自动配置Spring[m
[31m-     Spring Boot会根据在类路径中的jar包、类，为jar包里的类[m
[31m-自动配置Bean，这样会极大地减少我们要使用的配置。当然，[m
[31m-Spring Boot只是考虑了大多数的开发场景，并不是所有的场[m
[31m-景，若在实际开发中我们需要自动配置Bean，而Spring Boot没[m
[31m-有提供支持，则可以自定义自动配置（见6.5节）。[m
[31m-     5.准生产的应用监控[m
[31m-     Spring Boot提供基于http、ssh、telnet对运行时的项目进行[m
[31m-监控（见第10章）。[m
[31m-     6.无代码生成和xml配置[m
[31m-     Spring Boot的神奇的不是借助于代码生成来实现的，而是[m
[31m-通过条件注解来实现的，这是Spring 4.x提供的新特性，在3.5[m
[31m-节有过简单的演示，本章将用大量的篇幅讲解Spring Boot实现[m
[31m-的核心技术。[m
[31m-[m
[31m-     Spring 4.x提倡使用Java配置和注解配置组合，而Spring[m
[31m-Boot不需要任何xml配置即可实现Spring的所有配置。[m
[31m-[m
[31m-5.1.3　Spring Boot的优缺点[m
[31m-[m
[31m-     优点[m
[31m-[m
[31m-     （1）快速构建项目；[m
[31m-     （2）对主流开发框架的无配置集成；[m
[31m-     （3）项目可独立运行，无须外部依赖Servlet容器；[m
[31m-     （4）提供运行时的应用监控；[m
[31m-     （5）极大地提高了开发、部署效率；[m
[31m-     （6）与云计算的天然集成。[m
[31m-     缺点[m
[31m-     （1）书籍文档较少且不够深入，这是直接促使我写这本[m
[31m-书的原因；[m
[31m-[m
[31m-     （2）如果你不认同Spring框架，这也许是它的缺点，但建[m
[31m-议你一定要使用Spring框架。[m
[31m-[m
[31m-5.1.4　关于本书的Spring Boot版本[m
[31m-[m
[31m-在我写这本书的时候，Spring          Boot的最新正式版是[m
[31m-[m
[31m-1.2.4.RELEASE。Spring Boot 1.3.1.M2里程碑版本已经发布。[m
[31m-[m
[31m-     Spring Boot 1.3.1.x提供了大量新特性，最令人瞩目的是添[m
[31m-加了spring-boot-devtools来进行开发热部署，本书将以Spring[m
[31m-Boot 1.3.0版本作为演示讲解版本。[m
[31m-5.2　Spring Boot快速搭建[m
[31m-[m
[31m-5.2.1　http://start.spring.io[m
[31m-[m
[31m-     （1）打开浏览器，在地址栏中输入http://start.spring.io，如[m
[31m-图5-2所示。[m
[31m-[m
[31m-                                 图5-2　打开Spring.io[m
[31m-[m
[31m-     （2）填写项目信息，如图5-3所示。[m
[31m-                                 图5-3　填写项目信息[m
[31m-[m
[31m-     内容解释[m
[31m-[m
[31m-     ①我们在此以Maven作为项目构建方式，Spring Boot还支[m
[31m-持以Gradle作为项目构建工具；[m
[31m-[m
[31m-     ②部署形式以jar包形式，当然也可以用传统的war包形[m
[31m-式，我们将在10.2.2节进行讲解；[m
[31m-[m
[31m-     ③Java版本我们选用1.8，Spring Boot最低要求为1.6，和[m
[31m-Spring框架4.x的最低要求一致；[m
[31m-[m
[31m-     ④Spring boot还支持以Groovy语言开发，考虑到本书的受[m
[31m-众，本书以Java作为开发语言；[m
[31m-[m
[31m-     ⑤按照5.1.4节的阐述，选择Spring Boot版本为1.3.0里程碑[m
[31m-版本。[m
[31m-[m
[31m-     （3）选择项目选用的技术（即starter pom），如图5-4所[m
[31m-示。[m
[31m-[m
[31m-                            图5-4　选择项目选用的技术[m
[31m-[m
[31m-     内容解释[m
[31m-     这里备选的每一项技术都是Spring boot的starter pom，例如[m
[31m-我们选中的Web，就是在Maven里依赖spring-boot-starter-web。[m
[31m-     当这些技术的starter pom被选中后，与这项技术相关的[m
[31m-Spring的Bean将会被自动配置，我们将在第三部分讲述常用的[m
[31m-starter pom。[m
[31m-     （4）下载代码，如图5-5所示。[m
[31m-                                    图5-5　下载代码[m
[31m-[m
[31m-     内容解释[m
[31m-[m
[31m-     此处生成的是一个简单的基于Maven的项目，无任何特[m
[31m-别，可将这个项目导入到你常用的开发工具中（见附录[m
[31m-A.2。）[m
[31m-[m
[31m-5.2.2　Spring Tool Suite[m
[31m-[m
[31m-     对于习惯于Eclipse开发项目的读者，使用STS来构建Spring[m
[31m-Boot也十分简单。[m
[31m-（1）新建Spring Starter Project，如图5-6所示。[m
[31m-[m
[31m-                    图5-6　新建Spring Starter Project[m
[31m-[m
[31m-（2）填写项目信息和选择技术，如图5-7所示。[m
[31m-                   图5-7　填写项目信息和选择技术[m
[31m-[m
[31m-（3）项目结构如图5-8所示。[m
[31m-                              图5-8　项目结构[m
[31m-[m
[31m-（4）依赖树如图5-9所示。[m
[31m-                                     图5-9　依赖树[m
[31m-[m
[31m-5.2.3　IntelliJ IDEA[m
[31m-[m
[31m-     IntelliJ IDEA是我比较推崇的开发工具，对新技术有第一[m
[31m-时间的支持；使用IntelliJ IDEA 14.1版本可直接新建Spring[m
[31m-Boot项目。[m
[31m-[m
[31m-     （1）新建Spring Initializr项目，如图5-10所示。[m
[31m-                   图5-10　新建Spring Initializr项目[m
[31m-[m
[31m-（2）填写项目信息，如图5-11所示。[m
[31m-[m
[31m-                          图5-11　填写项目信息[m
[31m-[m
[31m-（3）选择项目使用技术，如图5-12所示。[m
[31m-                       图5-12　选择项目使用技术[m
[31m-[m
[31m-（4）填写项目名称，如图5-13所示。[m
[31m-[m
[31m-                          图5-13　填写项目名称[m
[31m-[m
[31m-（5）将项目设置为Maven项目，如图5-14所示。[m
[31m-                             图5-14　设置为Maven项目[m
[31m-[m
[31m-     （6）项目结构及依赖树如图5-15所示。[m
[31m-[m
[31m-                             图5-15　项目结构及依赖树[m
[31m-[m
[31m-5.2.4　Spring Boot CLI[m
[31m-[m
[31m-     Spring Boot CLI是Spring Boot提供的控制台命令工具。[m
[31m-     1.下载Spring Boot CLI[m
[31m-     Spring Boot 1.3.0.M1的下载地址是：[m
[31m-     http://repo.spring.io/release/org/springframework/boot/spring-[m
[31m-boot-cli/1.3.0.RELEASE/spring-boot-cli-1.3.0.RELEASE-bin.zip[m
[31m-     2.解压并配置到环境变量[m
[31m-     解压后将CLI的bin目录添加到环境变量的Path中，这样我[m
[31m-们就可以在控制台直接调用Spring Boot CLI了，如图5-16所[m
[31m-示。[m
[31m-                  图5-16　将bin目录添加到环境变量的Path中[m
[31m-[m
[31m-     3.使用命令初始化项目[m
[31m-[m
[31m-     要想实现上面几个例子的效果，需在控制台输入以下命[m
[31m-令：[m
[31m-[m
[31m-spring  init  --build=maven  --java-version=1.8  --[m
[31m-[m
[31m-dependencies=web --packaging=jar --boot-version=1.3.0.M1 --[m
[31m-[m
[31m-groupId=com.wisely --artifactId=ch5_2_4[m
[31m-[m
[31m-运行效果如图5-17所示。[m
[31m-[m
[31m-              图5-17　运行效果[m
[31m-[m
[31m-4.项目结构[m
[31m-     从图5-18同样可以看出这是一个普通的Maven项目。[m
[31m-[m
[31m-                                   图5-18　项目结构[m
[31m-[m
[31m-5.2.5　Maven手工构建[m
[31m-[m
[31m-     前面我讲述了用不同的方式构建Spring Boot项目，但事实[m
[31m-上建立的只是一个Maven项目，如果不借助上面的方式，我们[m
[31m-应如何构建Spring Boot项目呢？[m
[31m-[m
[31m-     1.Maven项目构建[m
[31m-     我们可以用任意开发工具新建空的Maven项目，在1.2节已[m
[31m-经做了较为详细的讲解。[m
[31m-     2.修改pom.xml[m
[31m-     （1）添加Spring Boot的父级依赖，这样当前的项目就是[m
[31m-Spring Boot项目了。spring-boot-starter-parent是一个特殊的[m
[31m-starter，它用来提供相关的Maven默认依赖，使用它之后，常[m
[31m-用的包依赖可以省去version标签，关于Spring Boot提供了哪些[m
[31m-jar包的依赖，可查看C：\Users\用户[m
[31m-\.m2\repository\org\springframework\boot\spring-boot-[m
[31m-dependencies\1.3.0.M1\spring-boot-dependencies-1.3.0.M1.pom文[m
[31m-件中的声明。[m
[31m-              <parent>[m
[31m-                      <groupId>org.springframework.boot</groupId>[m
[31m-                      <artifactId>spring-boot-starter-parent</artifactId>[m
[31m-                      <version>1.3.0.M1</version>[m
[31m-                      <relativePath/>[m
[31m-[m
[31m-              </parent>[m
[31m-[m
[31m-     （2）在dependencies添加Web支持的starter pom，这样就添[m
[31m-加了Web的依赖。[m
[31m-[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework.boot</groupId>[m
[31m-                                                           <artifactId>spring-boot-starter-[m
[31m-[m
[31m-       web</artifactId>[m
[31m-                      </dependency>[m
[31m-[m
[31m-     （3）添加Spring Boot的编译插件。[m
[31m-[m
[31m-       <build>[m
[31m-                      <plugins>[m
[31m-                             <plugin>[m
[31m-                                    <groupId>org.springframework.boot</groupId>[m
[31m-                                                               <artifactId>spring-boot-maven-[m
[31m-[m
[31m-       plugin</artifactId>[m
[31m-                             </plugin>[m
[31m-[m
[31m-                      </plugins>[m
[31m-       </build>[m
[31m-[m
[31m-     （4）因为我们使用的是里程碑版的Spring Boot，若使用的[m
[31m-是正式版则不需要下面的配置。[m
[31m-[m
[31m-       <repositories>[m
[31m-                      <repository>[m
[31m-                             <id>spring-snapshots</id>[m
[31m-                             <name>Spring Snapshots</name>[m
[31m-                             <url>https://repo.spring.io/snapshot</url>[m
[31m-                             <snapshots>[m
[31m-[m
[31m-                                    <enabled>true</enabled>[m
[31m-                             </snapshots>[m
[31m-                      </repository>[m
[31m-                      <repository>[m
[31m-                             <id>spring-milestones</id>[m
[31m-                             <name>Spring Milestones</name>[m
[31m-                             <url>https://repo.spring.io/milestone</url>[m
[31m-                             <snapshots>[m
[31m-[m
[31m-                                    <enabled>false</enabled>[m
[31m-                             </snapshots>[m
[31m-                      </repository>[m
[31m-              </repositories>[m
[31m-              <pluginRepositories>[m
[31m-                      <pluginRepository>[m
[31m-                             <id>spring-snapshots</id>[m
[31m-                             <name>Spring Snapshots</name>[m
[31m-                             <url>https://repo.spring.io/snapshot</url>[m
[31m-                             <snapshots>[m
[31m-[m
[31m-                                    <enabled>true</enabled>[m
[31m-                             </snapshots>[m
[31m-                      </pluginRepository>[m
[31m-                      <pluginRepository>[m
[31m-                             <id>spring-milestones</id>[m
[31m-                             <name>Spring Milestones</name>[m
[31m-                             <url>https://repo.spring.io/milestone</url>[m
[31m-                             <snapshots>[m
[31m-[m
[31m-                                    <enabled>false</enabled>[m
[31m-                             </snapshots>[m
[31m-                      </pluginRepository>[m
[31m-              </pluginRepositories>[m
[31m-[m
[31m-5.2.6　简单演示[m
[31m-[m
[31m-     1.新建Spring Boot项目[m
[31m-[m
[31m-     使用上述方法新建Spring Boot项目后，生成的项目的根包[m
[31m-目录下会有一个artifactId+Application命名规则的入口类。如图[m
[31m-5-19所示。[m
[31m-[m
[31m-                                    图5-19　入口类[m
[31m-[m
[31m-     2.添加测试控制器[m
[31m-     为了演示简单，我们不再新建控制器类，而是直接在入口[m
[31m-类中编写代码。[m
[31m-[m
[31m-       package com.wisely.ch5_2_2;[m
[31m-       import org.springframework.boot.SpringApplication;[m
[31m-       import org.springframework.boot.autoconfigure.SpringBootApplication;[m
[31m-       import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-       import org.springframework.web.bind.annotation.RestController;[m
[31m-       @RestController[m
[31m-       @SpringBootApplication //1[m
[31m-       public class Ch522Application {[m
[31m-[m
[31m-                @RequestMapping("/")[m
[31m-                      String index() {[m
[31m-                             return "Hello Spring Boot";[m
[31m-                      }[m
[31m-[m
[31m-              public static void main(String[] args) { //2[m
[31m-                      SpringApplication.run(Ch522Application.class, args);[m
[31m-[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-     ①@SpringBootApplication[m
[31m-     @SpringBootApplication是Spring Boot项目的核心注解，主[m
[31m-要目的是开启自动配置。我们将在6.1.2节中做更详细的讲解。[m
[31m-[m
[31m-     ②main方法[m
[31m-     这是一个标准的Java应用的main方法，主要作用是作为项[m
[31m-目启动的入口。我们将在6.1.1节做更详细的讲解。[m
[31m-     3.运行效果[m
[31m-     我们可以通过Maven命令，运行项目。[m
[31m-[m
[31m-       mvn spring-boot:run[m
[31m-[m
[31m-     或单击Ch522Application右键，在右键菜单中选择以Spring[m
[31m-Boot APP或Java Application运行项目，如图5-20所示。[m
[31m-[m
[31m-                                   图5-20　右键菜单[m
[31m-[m
[31m-     访问http://localhost：8080，结果如图5-21所示。[m
[31m-[m
[31m-                                   图5-21　运行结果[m
[31m-第6章　Spring Boot核心[m
[31m-[m
[31m-6.1　基本配置[m
[31m-[m
[31m-6.1.1　入口类和@SpringBootApplication[m
[31m-[m
[31m-     Spring Boot通常有一个名为*Application的入口类，入口类[m
[31m-里有一个main方法，这个main方法其实就是一个标准的Java应[m
[31m-用的入口方法。在main方法中使用[m
[31m-SpringApplication.run（Ch522Application.class，args），启动[m
[31m-Spring Boot应用项目。[m
[31m-[m
[31m-     @SpringBootApplication是Spring Boot的核心注解，它是一[m
[31m-个组合注解，源码如下：[m
[31m-[m
[31m-       @Target(ElementType.TYPE)[m
[31m-       @Retention(RetentionPolicy.RUNTIME)[m
[31m-       @Documented[m
[31m-       @Inherited[m
[31m-       @Configuration[m
[31m-       @EnableAutoConfiguration[m
[31m-       @ComponentScan[m
[31m-       public @interface SpringBootApplication {[m
[31m-[m
[31m-              Class<?>[] exclude() default {};[m
[31m-              String[] excludeName() default {};[m
[31m-       }[m
[31m-[m
[31m-     @SpringBootApplication注解主要组合了@Configuration、[m
[31m-@EnableAutoConfiguration、@ComponentScan；若不使用[m
[31m-@SpringBootApplication注解，则可以在入口类上直接使用[m
[31m-@Configuration、@EnableAutoConfiguration、[m
[31m-@ComponentScan。[m
[31m-[m
[31m-     其中，@EnableAutoConfiguration让Spring Boot根据类路径[m
[31m-中的jar包依赖为当前项目进行自动配置。[m
[31m-[m
[31m-     例如，添加了spring-boot-starter-web依赖，会自动添加[m
[31m-Tomcat和Spring MVC的依赖，那么Spring Boot会对Tomcat和[m
[31m-Spring MVC进行自动配置。[m
[31m-[m
[31m-     又如，添加了spring-boot-starter-data-jpa依赖，Spring Boot[m
[31m-会自动进行JPA相关的配置。[m
[31m-[m
[31m-     Spring Boot会自动扫描@SpringBootApplication所在类的同[m
[31m-级包（如com.wisely.ch5_2_2）以及下级包里的Bean（若为JPA[m
[31m-项目还可以扫描标注@Entity的实体类）。建议入口类放置的[m
[31m-位置在groupId+arctifactID组合的包名下。[m
[31m-[m
[31m-6.1.2　关闭特定的自动配置[m
[31m-[m
[31m-     通过上面的@SpringBootApplication的源码我们可以看出，[m
[31m-关闭特定的自动配置应该使用@SpringBootApplication注解的[m
[31m-exclude参数，例如：[m
[31m-[m
[31m-@SpringBootApplication(exclude        =[m
[31m-{DataSourceAutoConfiguration.class})[m
[31m-6.1.3　定制Banner[m
[31m-[m
[31m-     1.修改Banner[m
[31m-     （1）在Spring Boot启动的时候会有一个默认启动图案，如[m
[31m-图6-1所示。[m
[31m-[m
[31m-                                 图6-1　默认启动图案[m
[31m-[m
[31m-     （2）我们在src/main/resources下新建一个banner.txt。[m
[31m-     （3）通过http://patorjk.com/software/taag网站生成字符，如[m
[31m-敲入的为“WISELY”，将网站生成的字符复制到banner.txt中。[m
[31m-     （4）这时再启动程序，图案将变为如图6-2所示。[m
[31m-[m
[31m-                                 图6-2　改变后的图案[m
[31m-[m
[31m-     2.关闭banner[m
[31m-     （1）main里的内容修改为：[m
[31m-       SpringApplication app = new SpringApplication(Ch522Application.class);[m
[31m-       app.setShowBanner(false);[m
[31m-       app.run(args);[m
[31m-[m
[31m-     （2）或使用fluent API修改为：[m
[31m-[m
[31m-       new SpringApplicationBuilder(Ch522Application.class)[m
[31m-                                    .showBanner(false)[m
[31m-                                    .run(args);[m
[31m-[m
[31m-6.1.4　Spring Boot的配置文件[m
[31m-[m
[31m-     Spring Boot使用一个全局的配置文件application.properties[m
[31m-或application.yml，放置在src/main/resources目录或者类路径[m
[31m-的/config下。[m
[31m-[m
[31m-     Spring Boot不仅支持常规的properties配置文件，还支持[m
[31m-yaml语言的配置文件。yaml是以数据为中心的语言，在配置数[m
[31m-据的时候具有面向对象的特征。[m
[31m-[m
[31m-     Spring Boot的全局配置文件的作用是对一些默认配置的配[m
[31m-置值进行修改。[m
[31m-[m
[31m-     1.简单示例[m
[31m-     将Tomcat的默认端口号8080修改为9090，并将默认的访问[m
[31m-路径“/”修改为“/helloboot”。[m
[31m-     可以在application.properties中添加：[m
[31m-       server.port=9090[m
[31m-       server.context-path=/helloboot[m
[31m-[m
[31m-     或在application.yml中添加：[m
[31m-[m
[31m-       server:[m
[31m-           port: 9090[m
[31m-           contextPath: /helloboot[m
[31m-[m
[31m-     从上面的配置可以看出，在Spring Boot中，context-path、[m
[31m-contextPath或者CONTEXT_PATH形式其实是通用的。并且，[m
[31m-yaml的配置更简洁清晰。目前STS 3.7.0已开始支持yaml语言配[m
[31m-置，而IntelliJ IDEA则只对Spring Boot的properties配置提供了[m
[31m-自动提示的功能，且@PropertySource注解也不支持加载yaml[m
[31m-文件。在日常开发中，我们习惯于用properties文件来配置，所[m
[31m-以目前推荐使用properties进行配置。[m
[31m-[m
[31m-     在附录A.3中有Spring Boot常用配置的列表。[m
[31m-[m
[31m-6.1.5　starter pom[m
[31m-[m
[31m-     Spring Boot为我们提供了简化企业级开发绝大多数场景的[m
[31m-starter pom，只要使用了应用场景所需要的starter pom，相关的[m
[31m-技术配置将会消除，就可以得到Spring Boot为我们提供的自动[m
[31m-配置的Bean。[m
[31m-1.官方starter pom[m
[31m-Spring Boot官方提供了如表6-1所示的starter pom。[m
[31m-[m
[31m-                     表6-1　官方提供的starter pom[m
[31m-     2.第三方starter pom[m
[31m-     除官方的starter pom外，还有第三方为Spring Boot所写的[m
[31m-starter pom，如表6-2所示。[m
[31m-[m
[31m-                          表6-2　第三方所写的starter pom[m
[31m-[m
[31m-6.1.6　使用xml配置[m
[31m-[m
[31m-     Spring Boot提倡零配置，即无xml配置，但是在实际项目[m
[31m-中，可能有一些特殊要求你必须使用xml配置，这时我们可以[m
[31m-通过Spring提供的@ImportResource来加载xml配置，例如：[m
[31m-[m
[31m-       @ImportResource({"classpath:some-[m
[31m-       context.xml","classpath:another-context.xml"})[m
[31m-6.2　外部配置[m
[31m-[m
[31m-     Spring Boot允许使用properties文件、yaml文件或者命令行[m
[31m-参数作为外部配置。[m
[31m-[m
[31m-6.2.1　命令行参数配置[m
[31m-[m
[31m-     Spring Boot可以是基于jar包运行的，打成jar包的程序可以[m
[31m-直接通过下面命令运行：[m
[31m-[m
[31m-       java –jar xx.jar[m
[31m-[m
[31m-     可以通过以下命令修改Tomcat端口号：[m
[31m-[m
[31m-       java –jar xx.jar --server.port=9090[m
[31m-[m
[31m-6.2.2　常规属性配置[m
[31m-[m
[31m-     在2.2节我们讲述了在常规Spring环境下，注入properties文[m
[31m-件里的值的方式，通过@PropertySource指明properties文件的[m
[31m-位置，然后通过@Value注入值。在Spring Boot里，我们只需[m
[31m-在application.properties定义属性，直接使用@Value注入即可。[m
[31m-1.实战[m
[31m-在上例的基础上，进行如下的修改。[m
[31m-[m
[31m-（1）application.properties增加属性：[m
[31m-[m
[31m-book.author=wangyunfei[m
[31m-book.name[m
[31m-[m
[31m-=spring boot[m
[31m-[m
[31m-（2）修改入口类：[m
[31m-[m
[31m-package com.wisely.ch5_2_2;[m
[31m-[m
[31m-import org.springframework.beans.factory.annotation.Value;[m
[31m-import org.springframework.boot.SpringApplication;[m
[31m-import org.springframework.boot.autoconfigure.SpringBootApplication;[m
[31m-import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-import org.springframework.web.bind.annotation.RestController;[m
[31m-[m
[31m-@RestController[m
[31m-@SpringBootApplication[m
[31m-public class Ch522Application {[m
[31m-[m
[31m-         @Value("${book.author}")[m
[31m-         private String bookAuthor;[m
[31m-         @Value("${book.name}")[m
[31m-         private String bookName;[m
[31m-[m
[31m-         @RequestMapping("/")[m
[31m-              String index() {[m
[31m-                     return "book name is:"+bookName+" and book author is:" + bo[m
[31m-              }[m
[31m-[m
[31m-       public static void main(String[] args) {[m
[31m-              SpringApplication.run(Ch522Application.class, args);[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     （3）运行，访问http://localhost：9090/helloboot/，效果如[m
[31m-图6-3所示。[m
[31m-[m
[31m-        图6-3　运行效果[m
[31m-[m
[31m-6.2.3　类型安全的配置（基于properties）[m
[31m-[m
[31m-     上例中使用@Value注入每个配置在实际项目中会显得格外[m
[31m-麻烦，因为我们的配置通常会是许多个，若使用上例的方式则[m
[31m-[m
[31m-要使用@Value注入很多次。[m
[31m-[m
[31m-Spring  Boot还提供了基于类型安全的配置方式，通过[m
[31m-[m
[31m-@ConfigurationProperties将properties属性和一个Bean及其属性[m
[31m-[m
[31m-关联，从而实现类型安全的配置。[m
[31m-[m
[31m-1.实战[m
[31m-[m
[31m-（1）新建Spring Boot项目，如图6-4所示。[m
[31m-                      图6-4　新建Spring Boot项目[m
[31m-[m
[31m-（2）添加配置，即在application.properties上添加：[m
[31m-[m
[31m-author.name=wyf[m
[31m-author.age[m
[31m-[m
[31m-=32[m
[31m-     当然，我们也可以新建一个properties文件，这就需要我们[m
[31m-在@ConfigurationProperties的属性locations里指定properties的[m
[31m-位置，且需要在入口类上配置。[m
[31m-[m
[31m-     （3）类型安全的Bean，代码如下：[m
[31m-[m
[31m-       package com.wisely.ch6_2_3.config;[m
[31m-[m
[31m-       import org.springframework.boot.context.properties.ConfigurationPropert[m
[31m-[m
[31m-       @Component[m
[31m-       @ConfigurationProperties(prefix = "author") //1[m
[31m-       public class AuthorSettings {[m
[31m-[m
[31m-              private String name;[m
[31m-              private Long age;[m
[31m-[m
[31m-              public String getName() {[m
[31m-                      return name;[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              public void setName(String name) {[m
[31m-                      this.name = name;[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              public Long getAge() {[m
[31m-                      return age;[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              public void setAge(Long age) {[m
[31m-                      this.age = age;[m
[31m-[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①通过@ConfigurationProperties加载properties文件内的配[m
[31m-置，通过prefix属性指定properties的配置的前缀，通过locations[m
[31m-指定properties文件的位置，例如：[m
[31m-       @ConfigurationProperties(prefix = "author",locations = {"classpath:conf[m
[31m-[m
[31m-     本例不需要配置locations。[m
[31m-[m
[31m-     （4）检验代码：[m
[31m-[m
[31m-       package com.wisely.ch6_2_3;[m
[31m-[m
[31m-       import org.springframework.beans.factory.annotation.Autowired;[m
[31m-       import org.springframework.boot.SpringApplication;[m
[31m-       import org.springframework.boot.autoconfigure.SpringBootApplication;[m
[31m-       import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-       import org.springframework.web.bind.annotation.RestController;[m
[31m-[m
[31m-       import com.wisely.ch6_2_3.config.AuthorSettings;[m
[31m-       @RestController[m
[31m-       @SpringBootApplication[m
[31m-       public class Ch623Application {[m
[31m-[m
[31m-              @Autowired[m
[31m-              private AuthorSettings authorSettings; //1[m
[31m-[m
[31m-              @RequestMapping("/")[m
[31m-              public String index(){[m
[31m-[m
[31m-                      return "author name is "+ authorSettings.getName()+" and author[m
[31m-              }[m
[31m-[m
[31m-              public static void main(String[] args) {[m
[31m-                      SpringApplication.run(Ch623Application.class, args);[m
[31m-[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①可以用@Autowired直接注入该配置。[m
[31m-[m
[31m-     （5）运行，访问：http://localhost：8080/，效果如图6-5所[m
[31m-示。[m
[31m-图6-5　运行效果[m
[31m-6.3　日志配置[m
[31m-[m
[31m-     Spring Boot支持Java Util Logging、Log4J、Log4J2和[m
[31m-Logback作为日志框架，无论使用哪种日志框架，Spring Boot[m
[31m-已为当前使用日志框架的控制台输出及文件输出做好了配置，[m
[31m-可对比4.2.2节中没有Spring Boot时日志配置的方式。[m
[31m-[m
[31m-     默认情况下，Spring Boot使用Logback作为日志框架。[m
[31m-     配置日志级别：[m
[31m-[m
[31m-       logging.file=D:/mylog[m
[31m-[m
[31m-       /log.log[m
[31m-[m
[31m-     配置日志文件，格式为logging.level.包名=级别：[m
[31m-[m
[31m-       logging.level.org.springframework.web= DEBUG[m
[31m-6.4　Profile配置[m
[31m-[m
[31m-     Profile是Spring用来针对不同的环境对不同的配置提供支持[m
[31m-的，全局Profile配置使用application-{profile}.properties（如[m
[31m-application-prod.properties）。[m
[31m-[m
[31m-     通过在application.properties中设置[m
[31m-spring.profiles.active=prod来指定活动的Profile。[m
[31m-[m
[31m-     下面将做一个最简单的演示，如我们分为生产（prod）和[m
[31m-开发（dev）环境，生产环境下端口号为80，开发环境下端口[m
[31m-为8888。[m
[31m-[m
[31m-实战[m
[31m-[m
[31m-     （1）新建Spring Boot项目，如图6-6所示。[m
[31m-                      图6-6　新建Spring Boot项目[m
[31m-[m
[31m-（2）生产和开发环境下的配置文件如下：[m
[31m-application-prod.properties：[m
[31m-[m
[31m-server.port=80[m
[31m-[m
[31m-application-dev.properties：[m
[31m-server.port=8888[m
[31m-[m
[31m-此时目录结构如图6-7所示。[m
[31m-[m
[31m-                              图6-7　目录结构[m
[31m-[m
[31m-（3）运行。[m
[31m-application.properties增加：[m
[31m-[m
[31m-spring.profiles.active=dev[m
[31m-[m
[31m-启动程序结果为：[m
[31m-修改application.properties：[m
[31m-[m
[31m-spring.profiles.active=prod[m
[31m-6.5　Spring Boot运行原理[m
[31m-[m
[31m-     在前面几个章节，我们见识了Spring Boot为我们做的自动[m
[31m-配置，为了让大家快速领略Spring Boot的魅力，我们将在本节[m
[31m-先通过分析Spring Boot的运行原理后，根据已掌握的知识自定[m
[31m-义一个starter pom。[m
[31m-[m
[31m-     在3.5章中我们了解到Spring 4.x提供了基于条件来配置[m
[31m-Bean的能力，其实Spring Boot的神奇的实现也是基于这一原理[m
[31m-的。[m
[31m-[m
[31m-     本节虽然没有摆在书的显著位置，但是本节的内容是理解[m
[31m-[m
[31m-Spring Boot运作原理的关键。我们可以借助这一特性来理解[m
[31m-Spring Boot运行自动配置的原理，并实现自己的自动配置。[m
[31m-[m
[31m-Spring  Boot关于自动配置的源码在spring-boot-[m
[31m-[m
[31m-autoconfigure-1.3.0.x.jar内，主要包含了如图6-8所示的配置。[m
[31m-                                  图6-8　包含的配置[m
[31m-[m
[31m-     若想知道Spring Boot为我们做了哪些自动配置，可以查看[m
[31m-这里的源码。[m
[31m-[m
[31m-     可以通过下面三种方式查看当前项目中已启用和未启用的[m
[31m-自动配置的报告。[m
[31m-[m
[31m-     （1）运行jar时增加--debug参数：[m
[31m-java -jar xx.jar --debug[m
[31m-[m
[31m-（2）在application.properties中设置属性：[m
[31m-[m
[31m-debug=true[m
[31m-[m
[31m-（3）在STS中设置，如图6-9所示。[m
[31m-[m
[31m-                           图6-9　在STS中设置[m
[31m-此时启动，可在控制台输出。已启用的自动配置为：[m
[31m-[m
[31m-未启用的自动配置为：[m
[31m-[m
[31m-6.5.1　运作原理[m
[31m-[m
[31m-关于Spring    Boot的运作原理，我们还是回归到[m
[31m-[m
[31m-@SpringBootApplication注解上来，这个注解是一个组合注[m
[31m-[m
[31m-解，它的核心功能是由@EnableAutoConfiguration注解提供[m
[31m-[m
[31m-的。[m
[31m-[m
[31m-下面我们来看下@EnableAutoConfiguration注解的源码：[m
[31m-[m
[31m-@Target(ElementType.TYPE)[m
[31m-@Retention(RetentionPolicy.RUNTIME)[m
[31m-@Documented[m
[31m-@Inherited[m
[31m-@Import({ EnableAutoConfigurationImportSelector.class,[m
[31m-[m
[31m-              AutoConfigurationPackages.Registrar.class })[m
[31m-public @interface EnableAutoConfiguration {[m
[31m-[m
[31m-       Class<?>[] exclude() default {};[m
[31m-       String[] excludeName() default {};[m
[31m-       }[m
[31m-[m
[31m-     这里的关键功能是@Import注解导入的配置功能，[m
[31m-EnableAutoConfigurationImportSelector使用[m
[31m-SpringFactoriesLoader.loadFactoryNames方法来扫描具有META-[m
[31m-INF/spring.factories文件的jar包，而我们的spring-boot-[m
[31m-autoconfigure-1.3.0.x.jar里就有一个spring.factories文件，此文件[m
[31m-中声明了有哪些自动配置，如图6-10所示。[m
[31m-[m
[31m-                                   图6-10　自动配置[m
[31m-[m
[31m-6.5.2　核心注解[m
[31m-[m
[31m-     打开上面任意一个AutoConfiguration文件，一般都有下面[m
[31m-的条件注解，在spring-boot-autoconfigure-1.3.0.x.jar的[m
[31m-org.springframwork.boot.autoconfigure.condition包下，条件注解[m
[31m-如下。[m
[31m-     @ConditionalOnBean：当容器里有指定的Bean的条件下。[m
[31m-[m
[31m-     @ConditionalOnClass：当类路径下有指定的类的条件下。[m
[31m-[m
[31m-     @ConditionalOnExpression：基于SpEL表达式作为判断条[m
[31m-件。[m
[31m-[m
[31m-     @ConditionalOnJava：基于JVM版本作为判断条件。[m
[31m-[m
[31m-     @ConditionalOnJndi：在JNDI存在的条件下查找指定的位[m
[31m-置。[m
[31m-[m
[31m-     @ConditionalOnMissingBean：当容器里没有指定Bean的情[m
[31m-况下。[m
[31m-[m
[31m-     @ConditionalOnMissingClass：当类路径下没有指定的类的[m
[31m-条件下。[m
[31m-[m
[31m-     @ConditionalOnNotWebApplication：当前项目不是Web项[m
[31m-目的条件下。[m
[31m-[m
[31m-     @ConditionalOnProperty：指定的属性是否有指定的值。[m
[31m-[m
[31m-     @ConditionalOnResource：类路径是否有指定的值。[m
[31m-[m
[31m-     @ConditionalOnSingleCandidate：当指定Bean在容器中只[m
[31m-有一个，或者虽然有多个但是指定首选的Bean。[m
[31m-[m
[31m-     @ConditionalOnWebApplication：当前项目是Web项目的条[m
[31m-件下。[m
[31m-[m
[31m-     这些注解都是组合了@Conditional元注解，只是使用了不[m
[31m-同的条件（Condition），我们在3.5节已做过阐述定义一个根[m
[31m-据条件创建不同Bean的演示。[m
[31m-     下面我们用在3.5节学过的知识简单分析一下[m
[31m-@ConditionalOnWebApplication注解。[m
[31m-[m
[31m-       package org.springframework.boot.autoconfigure.condition;[m
[31m-[m
[31m-       import java.lang.annotation.Documented;[m
[31m-       import java.lang.annotation.ElementType;[m
[31m-       import java.lang.annotation.Retention;[m
[31m-       import java.lang.annotation.RetentionPolicy;[m
[31m-       import java.lang.annotation.Target;[m
[31m-[m
[31m-       import org.springframework.context.annotation.Conditional;[m
[31m-       @Target({ ElementType.TYPE, ElementType.METHOD })[m
[31m-       @Retention(RetentionPolicy.RUNTIME)[m
[31m-       @Documented[m
[31m-       @Conditional(OnWebApplicationCondition.class)[m
[31m-       public @interface ConditionalOnWebApplication {[m
[31m-       }[m
[31m-[m
[31m-     从源码可以看出，此注解使用的条件是[m
[31m-OnWebApplicationCondition，下面我们看看这个条件是如何构[m
[31m-造的：[m
[31m-[m
[31m-       package org.springframework.boot.autoconfigure.condition;[m
[31m-[m
[31m-       import org.springframework.context.annotation.Condition;[m
[31m-       import org.springframework.context.annotation.ConditionContext;[m
[31m-       import org.springframework.core.Ordered;[m
[31m-       import org.springframework.core.annotation.Order;[m
[31m-       import org.springframework.core.type.AnnotatedTypeMetadata;[m
[31m-       import org.springframework.util.ClassUtils;[m
[31m-       import org.springframework.util.ObjectUtils;[m
[31m-       import org.springframework.web.context.WebApplicationContext;[m
[31m-       import org.springframework.web.context.support.StandardServletEnvironme[m
[31m-[m
[31m-       @Order(Ordered.HIGHEST_PRECEDENCE + 20)[m
[31m-       class OnWebApplicationCondition extends SpringBootCondition {[m
[31m-[m
[31m-              private static final String WEB_CONTEXT_CLASS = "org.springframewor[m
[31m-                             + "support.GenericWebApplicationContext";[m
[31m-       @Override[m
[31m-       public ConditionOutcome getMatchOutcome(ConditionContext context,[m
[31m-[m
[31m-                     AnnotatedTypeMetadata metadata) {[m
[31m-              boolean webApplicationRequired = metadata[m
[31m-[m
[31m-                             .isAnnotated(ConditionalOnWebApplication.class.getName([m
[31m-              ConditionOutcome webApplication = isWebApplication(context, met[m
[31m-[m
[31m-              if (webApplicationRequired && !webApplication.isMatch()) {[m
[31m-                     return ConditionOutcome.noMatch(webApplication.getMessage()[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              if (!webApplicationRequired && webApplication.isMatch()) {[m
[31m-                     return ConditionOutcome.noMatch(webApplication.getMessage()[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              return ConditionOutcome.match(webApplication.getMessage());[m
[31m-       }[m
[31m-[m
[31m-       private ConditionOutcome isWebApplication(ConditionContext context,[m
[31m-                     AnnotatedTypeMetadata metadata) {[m
[31m-[m
[31m-              if (!ClassUtils.isPresent(WEB_CONTEXT_CLASS, context.getClassLo[m
[31m-                     return ConditionOutcome.noMatch("web application classes no[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              if (context.getBeanFactory() != null) {[m
[31m-                     String[] scopes = context.getBeanFactory().getRegisteredSco[m
[31m-                     if (ObjectUtils.containsElement(scopes, "session")) {[m
[31m-                             return ConditionOutcome.match("found web application 's[m
[31m-                     }[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              if (context.getEnvironment() instanceof StandardServletEnvironm[m
[31m-                     return ConditionOutcome[m
[31m-                                    .match("found web application StandardServletEnviro[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              if (context.getResourceLoader() instanceof WebApplicationContex[m
[31m-                     return ConditionOutcome.match("found web application WebApp[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              return ConditionOutcome.noMatch("not a web application");[m
[31m-       }[m
[31m-[m
[31m-}[m
[31m-     从isWebApplication方法可以看出，判断条件是：[m
[31m-[m
[31m-     （1）GenericWebApplicationContext是否在类路径中；[m
[31m-[m
[31m-     （2）容器里是否有名为session的scope；[m
[31m-[m
[31m-     （3）当前容器的Enviroment是否为[m
[31m-StandardServletEnvironment；[m
[31m-[m
[31m-     （4）当前的ResourceLoader是否为[m
[31m-WebApplicationContext（ResourceLoader是ApplicationContext[m
[31m-的顶级接口之一）；[m
[31m-[m
[31m-     （5）我们需要构造ConditionOutcome类的对象来帮助我[m
[31m-们，最终通过ConditionOutcome.isMatch方法返回布尔值来确定[m
[31m-条件。[m
[31m-[m
[31m-6.5.3　实例分析[m
[31m-[m
[31m-     在了解了Spring Boot的运作原理和主要的条件注解后，现[m
[31m-在来分析一个简单的Spring Boot内置的自动配置功能：http的[m
[31m-编码配置。[m
[31m-[m
[31m-     我们在常规项目中配置http编码的时候是在web.xml里配置[m
[31m-一个filter，如：[m
[31m-[m
[31m-       <filter>[m
[31m-           <filter-name>encodingFilter</filter-name>[m
[31m-                                                                                                       <filter-[m
[31m-[m
[31m-       class>org.springframework.web.filter.CharacterEncodingFilter[m
[31m-           </filter-class>[m
[31m-           <init-param>[m
[31m-             <param-name>encoding</param-name>[m
[31m-             <param-value>UTF-8</param-value>[m
[31m-           </init-param>[m
[31m-           <init-param>[m
[31m-[m
[31m-             <param-name>forceEncoding</param-name>[m
[31m-             <param-value>true</param-value>[m
[31m-           </init-param>[m
[31m-         </filter>[m
[31m-[m
[31m-     自动配置要满足两个条件：[m
[31m-[m
[31m-     （1）能配置CharacterEncodingFilter这个Bean；[m
[31m-[m
[31m-     （2）能配置encoding和forceEncoding这两个参数。[m
[31m-[m
[31m-     1.配置参数[m
[31m-[m
[31m-     在6.2.3节我们讲述了类型安全的配置，Spring Boot的自动[m
[31m-配置也是基于这一点实现的，这里的配置类可以在[m
[31m-application.properties中直接设置，源码如下：[m
[31m-[m
[31m-       @ConfigurationProperties(prefix = "spring.http.encoding")//1[m
[31m-       public class HttpEncodingProperties {[m
[31m-[m
[31m-              public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-[m
[31m-       8");//2[m
[31m-[m
[31m-              private Charset charset = DEFAULT_CHARSET; //2[m
[31m-[m
[31m-              private boolean force = true; //3[m
[31m-[m
[31m-              public Charset getCharset() {[m
[31m-                      return this.charset;[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              public void setCharset(Charset charset) {[m
[31m-                      this.charset = charset;[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              public boolean isForce() {[m
[31m-                      return this.force;[m
[31m-[m
[31m-              }[m
[31m-              public void setForce(boolean force) {[m
[31m-                      this.force = force;[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①在application.properties配置的时候前缀是[m
[31m-spring.http.encoding；[m
[31m-[m
[31m-     ②默认编码方式为UTF-8，若修改可使用[m
[31m-spring.http.encoding.charset=编码；[m
[31m-[m
[31m-     ③设置forceEncoding，默认为true，若修改可使用[m
[31m-spring.http.encoding.force=false。[m
[31m-[m
[31m-     2.配置Bean[m
[31m-[m
[31m-     通过调用上述配置，并根据条件配置[m
[31m-CharacterEncodingFilter的Bean，我们来看看源码：[m
[31m-[m
[31m-       @Configuration[m
[31m-       @EnableConfigurationProperties(HttpEncodingProperties.class) //1[m
[31m-       @ConditionalOnClass(CharacterEncodingFilter.class) //2[m
[31m-       @ConditionalOnProperty(prefix = "spring.http.encoding", value = "enable[m
[31m-       public class HttpEncodingAutoConfiguration {[m
[31m-[m
[31m-              @Autowired[m
[31m-              private HttpEncodingProperties httpEncodingProperties; //[m
[31m-       ３[m
[31m-[m
[31m-              @Bean//4[m
[31m-              @ConditionalOnMissingBean(CharacterEncodingFilter.class) //5[m
[31m-              public CharacterEncodingFilter characterEncodingFilter() {[m
[31m-[m
[31m-                      CharacterEncodingFilter filter = new OrderedCharacterEncodingFi[m
[31m-                      filter.setEncoding(this.httpEncodingProperties.getCharset().nam[m
[31m-                      filter.setForceEncoding(this.httpEncodingProperties.isForce());[m
[31m-                      return filter;[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①开启属性注入，通过@EnableConfigurationProperties声[m
[31m-明，使用@Autowired注入；[m
[31m-[m
[31m-     ②当CharacterEncodingFilter在类路径的条件下；[m
[31m-[m
[31m-     ③当设置spring.http.encoding=enabled的情况下，如果没有[m
[31m-设置则默认为true，即条件符合；[m
[31m-[m
[31m-     ④像使用Java配置的方式配置CharacterEncodingFilter这个[m
[31m-Bean；[m
[31m-[m
[31m-     ⑤当容器中没有这个Bean的时候新建Bean。[m
[31m-[m
[31m-6.5.4　实战[m
[31m-[m
[31m-     看完前面几节的讲述，是不是觉得Spring Boot的自动配置[m
[31m-其实很简单，是不是跃跃欲试地想让自己的项目也具备这样的[m
[31m-功能。其实我们完全可以仿照上面http编码配置的例子自己写[m
[31m-一个自动配置，不过这里再做的彻底点，我们自己写一个[m
[31m-starter pom，这意味着我们不仅有自动配置的功能，而且具有[m
[31m-更通用的耦合度更低的配置。[m
[31m-[m
[31m-     为了方便理解，在这里举一个简单的实战例子，包含当某[m
[31m-个类存在的时候，自动配置这个类的Bean，并可将Bean的属性[m
[31m-在application.properties中配置。[m
[31m-     （1）新建starter的Maven项目，如图6-11所示。[m
[31m-图6-11　新建starter的Maven项目[m
[31m-在pom.xml中修改代码如下：[m
[31m-[m
[31m-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://ww[m
[31m-instance"[m
[31m-[m
[31m-   xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.ap[m
[31m-4.0.0.xsd">[m
[31m-[m
[31m-   <modelVersion>4.0.0</modelVersion>[m
[31m-[m
[31m-   <groupId>com.wisely</groupId>[m
[31m-   <artifactId>spring-boot-starter-hello</artifactId>[m
[31m-   <version>0.0.1-SNAPSHOT</version>[m
[31m-   <packaging>jar</packaging>[m
[31m-[m
[31m-   <name>spring-boot-starter-hello</name>[m
[31m-   <url>http://maven.apache.org</url>[m
[31m-[m
[31m-   <properties>[m
[31m-                                                <project.build.sourceEncoding>UTF-[m
[31m-[m
[31m-8</project.build.sourceEncoding>[m
[31m-   </properties>[m
[31m-[m
[31m-   <dependencies>[m
[31m-       <dependency>[m
[31m-              <groupId>org.springframework.boot</groupId>[m
[31m-              <artifactId>spring-boot-autoconfigure</artifactId>[m
[31m-              <version>1.3.0.M1</version>[m
[31m-       </dependency>[m
[31m-       <dependency>[m
[31m-          <groupId>junit</groupId>[m
[31m-          <artifactId>junit</artifactId>[m
[31m-          <version>3.8.1</version>[m
[31m-          <scope>test</scope>[m
[31m-       </dependency>[m
[31m-[m
[31m-   </dependencies>[m
[31m-   <!-- 使用Spring Boot正式版时，无须下列配置 -->[m
[31m-   <repositories>[m
[31m-[m
[31m-              <repository>[m
[31m-                     <id>spring-snapshots</id>[m
[31m-                     <name>Spring Snapshots</name>[m
[31m-                     <url>https://repo.spring.io/snapshot</url>[m
[31m-                     <snapshots>[m
[31m-                             <enabled>true</enabled>[m
[31m-                     </snapshots>[m
[31m-[m
[31m-              </repository>[m
[31m-              <repository>[m
[31m-[m
[31m-                     <id>spring-milestones</id>[m
[31m-                     <name>Spring Milestones</name>[m
[31m-                     <url>https://repo.spring.io/milestone</url>[m
[31m-                     <snapshots>[m
[31m-[m
[31m-                             <enabled>false</enabled>[m
[31m-                     </snapshots>[m
[31m-              </repository>[m
[31m-       </repositories>[m
[31m-       <pluginRepositories>[m
[31m-              <pluginRepository>[m
[31m-                     <id>spring-snapshots</id>[m
[31m-                     <name>Spring Snapshots</name>[m
[31m-                     <url>https://repo.spring.io/snapshot</url>[m
[31m-                     <snapshots>[m
[31m-[m
[31m-                             <enabled>true</enabled>[m
[31m-                     </snapshots>[m
[31m-              </pluginRepository>[m
[31m-              <pluginRepository>[m
[31m-                     <id>spring-milestones</id>[m
[31m-                     <name>Spring Milestones</name>[m
[31m-                     <url>https://repo.spring.io/milestone</url>[m
[31m-                     <snapshots>[m
[31m-[m
[31m-                             <enabled>false</enabled>[m
[31m-                     </snapshots>[m
[31m-              </pluginRepository>[m
[31m-       </pluginRepositories>[m
[31m-</project>[m
[31m-[m
[31m-代码解释[m
[31m-[m
[31m-在此处增加Spring Boot自身的自动配置作为依赖。[m
[31m-[m
[31m-（2）属性配置，代码如下：[m
[31m-[m
[31m-package com.wisely.spring_boot_starter_hello;[m
[31m-[m
[31m-import org.springframework.boot.context.properties.ConfigurationPropert[m
[31m-[m
[31m-@ConfigurationProperties(prefix="hello")[m
[31m-public class HelloServiceProperties {[m
[31m-[m
[31m-       private static final String MSG = "world";[m
[31m-              private String msg = MSG;[m
[31m-              public String getMsg() {[m
[31m-[m
[31m-                      return msg;[m
[31m-              }[m
[31m-              public void setMsg(String msg) {[m
[31m-[m
[31m-                      this.msg = msg;[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     这里配置与6.2.3节是一样的，是类型安全的属性获取。在[m
[31m-application.properties中通过hello.msg=来设置，若不设置，默[m
[31m-认为hello.msg=world。[m
[31m-[m
[31m-     （3）判断依据类，代码如下：[m
[31m-[m
[31m-       package com.wisely.spring_boot_starter_hello;[m
[31m-       public class HelloService {[m
[31m-[m
[31m-              private String msg;[m
[31m-[m
[31m-                public String sayHello(){[m
[31m-                       return "Hello" + msg;[m
[31m-[m
[31m-                }[m
[31m-[m
[31m-              public String getMsg() {[m
[31m-                      return msg;[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              public void setMsg(String msg) {[m
[31m-                      this.msg = msg;[m
[31m-[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     本例根据此类的存在与否来创建这个类的Bean，这个类可[m
[31m-以是第三方类库的类。[m
[31m-[m
[31m-     （4）自动配置类，代码如下：[m
[31m-[m
[31m-       package com.wisely.spring_boot_starter_hello;[m
[31m-[m
[31m-       import org.springframework.beans.factory.annotation.Autowired;[m
[31m-       import org.springframework.boot.autoconfigure.condition.ConditionalOnCl[m
[31m-       import org.springframework.boot.autoconfigure.condition.ConditionalOnMi[m
[31m-       import org.springframework.boot.autoconfigure.condition.ConditionalOnPr[m
[31m-       import org.springframework.boot.context.properties.EnableConfigurationP[m
[31m-       import org.springframework.context.annotation.Bean;[m
[31m-       import org.springframework.context.annotation.Configuration;[m
[31m-[m
[31m-       @Configuration[m
[31m-       @EnableConfigurationProperties(HelloServiceProperties.class)[m
[31m-       @ConditionalOnClass(HelloService.class)[m
[31m-       @ConditionalOnProperty(prefix = "hello", value = "enabled", matchIfMiss[m
[31m-       public class HelloServiceAutoConfiguration {[m
[31m-[m
[31m-              @Autowired[m
[31m-              private HelloServiceProperties helloServiceProperties;[m
[31m-[m
[31m-              @Bean[m
[31m-              @ConditionalOnMissingBean(HelloService.class)[m
[31m-              public HelloService helloService(){[m
[31m-[m
[31m-                      HelloService helloService = new HelloService();[m
[31m-                      helloService.setMsg(helloServiceProperties.getMsg());[m
[31m-                      return helloService;[m
[31m-              }[m
[31m-       }[m
[31m-     代码解释[m
[31m-     根据HelloServiceProperties提供的参数，并通过[m
[31m-@ConditionalOnClass判断HelloService这个类在类路径中是否[m
[31m-存在，且当容器中没有这个Bean的情况下自动配置这个Bean。[m
[31m-     （5）注册配置。在6.5.1中我们知道，若想自动配置生[m
[31m-效，需要注册自动配置类。在src/main/resources下新建META-[m
[31m-INF/spring.factories，结构如图6-12所示。[m
[31m-[m
[31m-                                      图6-12　结构[m
[31m-[m
[31m-     在spring.factories中填写如下内容注册：[m
[31m-[m
[31m-       org.springframework.boot.autoconfigure.EnableAutoConfiguration=\[m
[31m-       com.wisely.spring_boot_starter_hello.HelloServiceAutoConfiguration[m
[31m-[m
[31m-     若有多个自动配置，则用“，”隔开，此处“\”是为了换行后[m
[31m-仍然能读到属性。[m
[31m-[m
[31m-     另外，若在此例新建的项目中无src/main/resources文件[m
[31m-夹，需执行如图6-13所示操作。[m
[31m-[m
[31m-                      图6-13　调出src/maln/resources文件夹[m
[31m-[m
[31m-     （5）使用starter。新建Spring Boot项目，并将我们的starter[m
[31m-作为依赖，如图6-14所示。[m
[31m-                            图6-14　新建Spring Boot项目[m
[31m-[m
[31m-     在pom.xml中添加spring-boot-starter-hello的依赖，代码如[m
[31m-下：[m
[31m-[m
[31m-       <dependency>[m
[31m-                      <groupId>com.wisely</groupId>[m
[31m-                      <artifactId>spring-boot-starter-hello</artifactId>[m
[31m-                      <version>0.0.1-SNAPSHOT</version>[m
[31m-[m
[31m-       </dependency>[m
[31m-[m
[31m-     我们可以在Maven的依赖里查看spring-boot-starter-hello，[m
[31m-如图6-15所示。[m
[31m-[m
[31m-                       图6-15　查看spring-Doot-starter-hello[m
[31m-[m
[31m-     在开发阶段，我们引入的依赖是spring-boot-starter-hello这[m
[31m-个项目。在starter稳定之后，我们可以将spring-boot-starter-[m
[31m-hello通过“mvn install”安装到本地库，或者将这个jar包发布到[m
[31m-Maven私服上。[m
[31m-[m
[31m-     简单的运行类代码如下：[m
[31m-[m
[31m-       package com.wisely.ch6_5;[m
[31m-       import org.springframework.beans.factory.annotation.Autowired;[m
[31m-       import org.springframework.boot.SpringApplication;[m
[31m-       import org.springframework.boot.autoconfigure.SpringBootApplication;[m
[31m-       import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-       import org.springframework.web.bind.annotation.RestController;[m
[31m-       import com.wisely.spring_boot_starter_hello.HelloService;[m
[31m-       @RestController[m
[31m-       @SpringBootApplication[m
[31m-       public class Ch65Application {[m
[31m-[m
[31m-              @Autowired[m
[31m-              HelloService helloService;[m
[31m-              @RequestMapping("/")[m
[31m-              public String index(){[m
[31m-[m
[31m-                      return helloService.sayHello();[m
[31m-              }[m
[31m-              public static void main(String[] args) {[m
[31m-[m
[31m-                      SpringApplication.run(Ch65Application.class, args);[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     在代码中可以直接注入HelloService的Bean，但在项目中我[m
[31m-们并没有配置这个Bean，这是通过自动配置完成的。[m
[31m-[m
[31m-     访问http://localhost：8080，效果如图6-16所示。[m
[31m-[m
[31m-                        图6-16　访问http://local host：8080[m
[31m-[m
[31m-     这时在application.properties中配置msg的内容：[m
[31m-[m
[31m-       hello.msg[m
[31m-[m
[31m-       = wangyunfei[m
[31m-     此时再次访问http://localhost：8080，效果如图6-17所示。[m
[31m-[m
[31m-                                   图6-17　查看效果[m
[31m-[m
[31m-     在application.properties中添加debug属性，查看自动配置报[m
[31m-告：[m
[31m-[m
[31m-       debug=true[m
[31m-[m
[31m-     我们新增的自动配置显示在控制台的报告中，如图6-18所[m
[31m-示。[m
[31m-[m
[31m-                                 图6-18　控制台报告[m
[31m-第7章　Spring Boot的Web开发[m
[31m-[m
[31m-     Web开发是开发中至关重要的一部分，Web开发的核心内[m
[31m-容主要包括内嵌Servlet容器和Spring MVC。[m
[31m-7.1　Spring Boot的Web开发支持[m
[31m-[m
[31m-     Spring Boot提供了spring-boot-starter-web为Web开发予以支[m
[31m-持，spring-boot-starter-web为我们提供了嵌入的Tomcat以及[m
[31m-Spring MVC的依赖。而Web相关的自动配置存储在spring-boot-[m
[31m-autoconfigure.jar的org.springframework.boot.autoconfigure.web[m
[31m-下，如图7-1所示。[m
[31m-                      图7-1　Web相关的自动配置[m
[31m-[m
[31m-从这些文件名可以看出：[m
[31m-[m
[31m-ServerPropertiesAutoConfiguration和ServerProperties自动配[m
[31m-置内嵌Servlet容器；[m
[31m-HttpEncodingAutoConfiguration和HttpEncodingProperties用[m
[31m-来自动配置http的编码；[m
[31m-MultipartAutoConfiguration和MultipartProperties用来自动配[m
[31m-置上传文件的属性；[m
[31m-[m
[31m-JacksonHttpMessageConvertersConfiguration用来自动配置[m
[31m-[m
[31m-mappingJackson2Http  MessageConverter和[m
[31m-[m
[31m-mappingJackson2XmlHttpMessage Converter；[m
[31m-[m
[31m-WebMvcAutoConfiguration和WebMvcProperties配置Spring[m
[31m-[m
[31m-MVC。[m
[31m-7.2　Thymeleaf模板引擎[m
[31m-[m
[31m-     本书前面的内容很少用到页面模板引擎相关的内容，偶尔[m
[31m-使用了JSP页面，但是尽可能少地涉及JSP相关知识，这是因为[m
[31m-JSP在内嵌的Servlet的容器上运行有一些问题（内嵌Tomcat、[m
[31m-Jetty不支持以jar形式运行JSP，Undertow不支持JSP）。[m
[31m-[m
[31m-     Spring Boot提供了大量模板引擎，包含括FreeMarker、[m
[31m-Groovy、Thymeleaf、Velocity和Mustache，Spring Boot中推荐[m
[31m-使用Thymeleaf作为模板引擎，因为Thymeleaf提供了完美的[m
[31m-Spring MVC的支持。[m
[31m-[m
[31m-7.2.1　Thymeleaf基础知识[m
[31m-[m
[31m-     Thymeleaf是一个Java类库，它是一个xml/xhtml/html5的模[m
[31m-板引擎，可以作为MVC的Web应用的View层。[m
[31m-[m
[31m-     Thymeleaf还提供了额外的模块与Spring MVC集成，所以[m
[31m-我们可以使用Thymeleaf完全替代JSP。[m
[31m-[m
[31m-     下面我们演示日常工作中常用的Thymeleaf用法，我们将把[m
[31m-本节的内容在7.2.4节运行演示。[m
[31m-[m
[31m-     1.引入Thymeleaf[m
[31m-[m
[31m-     下面的代码是一个基本的Thymeleaf模板页面，在这里我们[m
[31m-引入了Bootstrap（作为样式控制）和jQuery（DOM操作），当[m
[31m-然它们不是必需的：[m
[31m-<html xmlns:th="http://www.thymeleaf.org"><!-- 1 -->[m
[31m-[m
[31m-<head>[m
[31m-[m
[31m-<meta content="text/html;charset=UTF-8"/>[m
[31m-[m
[31m-<link th:src="@{bootstrap/css/bootstrap.min.css}" rel="stylesheet"/[m
[31m-[m
[31m-- 2 -->[m
[31m-[m
[31m-         <link       th:src="@{bootstrap/css/bootstrap-[m
[31m-[m
[31m-theme.min.css}" rel="stylesheet"/><!-- 2 -->[m
[31m-[m
[31m-</head>[m
[31m-[m
[31m-<body>[m
[31m-[m
[31m-                     <script  th:src="@{jquery-[m
[31m-[m
[31m-1.10.2.min.js}" type="text/javascript"></script><!-- 2 -->[m
[31m-[m
[31m-         <script th:src="@{bootstrap/js/bootstrap.min.js}">[m
[31m-[m
[31m-</script><!-- 2 -->[m
[31m-[m
[31m-</body>[m
[31m-[m
[31m-</html>[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①通过xmlns：th=http://www.thymeleaf.org命名空间，将镜[m
[31m-头页面转换为动态的视图。需要进行动态处理的元素将使[m
[31m-用“th：”为前缀；[m
[31m-[m
[31m-     ②通过“@{}”引用Web静态资源，这在JSP下是极易出错[m
[31m-的。[m
[31m-[m
[31m-     2.访问model中的数据[m
[31m-[m
[31m-     通过“${}”访问model中的属性，这和JSP极为相似。[m
[31m-[m
[31m-           <div class="panel panel-primary">[m
[31m-              <div class="panel-heading">[m
[31m-                      <h3 class="panel-title">访问model</h3>[m
[31m-              </div>[m
[31m-              <div class="panel-body">[m
[31m-                      <span th:text="${singlePerson.name}"></span>[m
[31m-              </div>[m
[31m-[m
[31m-           </div>[m
[31m-     代码解释[m
[31m-[m
[31m-     使用<span th：text="${singlePerson.name}"></span>访问[m
[31m-model中的singlePerson的name属性。注意：需要处理的动态内[m
[31m-容需要加上“th：”前缀。[m
[31m-[m
[31m-     3.model中的数据迭代[m
[31m-[m
[31m-     Thymeleaf的迭代和JSP的写法也很相似，代码如下：[m
[31m-[m
[31m-           <div class="panel panel-primary">[m
[31m-              <div class="panel-heading">[m
[31m-                      <h3 class="panel-title">列表</h3>[m
[31m-              </div>[m
[31m-              <div class="panel-body">[m
[31m-                      <ul class="list-group">[m
[31m-                                                                          <li class="list-group-[m
[31m-[m
[31m-       item" th:each="person:${people}">[m
[31m-                                    <span th:text="${person.name}"></span>[m
[31m-                                        <span th:text="${person.age}"></span>[m
[31m-[m
[31m-                             </li>[m
[31m-                      </ul>[m
[31m-              </div>[m
[31m-         </div>[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     使用th：each来做循环迭代（th：each="person：[m
[31m-${people}"），person作为迭代元素来使用，然后像上面一样[m
[31m-访问迭代元素中的属性。[m
[31m-[m
[31m-     4.数据判断[m
[31m-[m
[31m-     代码如下：[m
[31m-[m
[31m-           <div th:if="${not #lists.isEmpty(people)}">[m
[31m-                  <div class="panel panel-primary">[m
[31m-                      <div class="panel-heading">[m
[31m-                             <h3 class="panel-title">列表</h3>[m
[31m-                      </div>[m
[31m-                      <div class="panel-body">[m
[31m-                             <ul class="list-group">[m
[31m-                                                                           <li class="list-group-[m
[31m-[m
[31m-       item" th:each="person:${people}">[m
[31m-                                           <span th:text="${person.name}"></span>[m
[31m-                                               <span th:text="${person.age}"></span>[m
[31m-[m
[31m-                                    </li>[m
[31m-                             </ul>[m
[31m-                      </div>[m
[31m-                </div>[m
[31m-         </div>[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     通过${not#lists.isEmpty（people）}表达式判断people是否[m
[31m-为空。Thymeleaf支持>、<、>=、<===、！= 作为比较条件，[m
[31m-同时也支持将SpringEL表达式语言用于条件中。[m
[31m-[m
[31m-     5.在JavaScript中访问model[m
[31m-[m
[31m-     在项目中，我们经常需要在JavaScript访问model中的值，[m
[31m-在Thymeleaf里实现代码如下：[m
[31m-[m
[31m-       <script th:inline="javascript">[m
[31m-              var single = [[${singlePerson}]];[m
[31m-              console.log(single.name+"/"+single.age)[m
[31m-[m
[31m-       </script>[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     通过th：inline=“javascript”添加到script标签，这样[m
[31m-     JavaScript代码即可访问model中的属性；[m
[31m-     通过“[[${}]]”格式获得实际的值。[m
[31m-[m
[31m-     还有一种是需要在html的代码里访问model中的属性，例[m
[31m-如，我们需要在列表后单击每一行后面的按钮获得model中的[m
[31m-值，可做如下处理：[m
[31m-[m
[31m-       <li class="list-group-item" th:each="person:${people}">[m
[31m-              <span th:text="${person.name}"></span>[m
[31m-[m
[31m-             <span th:text="${person.age}"></span>[m
[31m-             <button class="btn" th:onclick="'getName(\'' + ${person.name} + '\')[m
[31m-       获得名字</button>[m
[31m-       </li>[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     注意格式th：[m
[31m-onclick="'getName（\''+${person.name}+'\'）；'"。[m
[31m-[m
[31m-     6.其他知识[m
[31m-[m
[31m-     更多更完整的Thymeleaf的知识，请查看[m
[31m-http://www.thymeleaf.org的官网。[m
[31m-[m
[31m-7.2.2　与Spring MVC集成[m
[31m-[m
[31m-     在Spring MVC中，若我们需要集成一个模板引擎的话，需[m
[31m-要定义ViewResolver，而ViewResolver需要定义一个View，如[m
[31m-4.2.2节中我们为JSP定义的ViewResolver的代码：[m
[31m-[m
[31m-       @Bean[m
[31m-              public InternalResourceViewResolver viewResolver(){[m
[31m-       InternalResourceViewResolver viewResolver = new InternalResourc[m
[31m-       viewResolver.setPrefix("/WEB-INF/classes/views/");[m
[31m-       viewResolver.setSuffix(".jsp");[m
[31m-       viewResolver.setViewClass(JstlView.class);[m
[31m-       return viewResolver;[m
[31m-}[m
[31m-[m
[31m-通过上面的代码可以看出，使用JsltView定义了一个[m
[31m-[m
[31m-InternalResourceViewResolver，因而使用Thymeleaf作为我们的[m
[31m-[m
[31m-模板引擎也应该做类似的定义。庆幸的是，Thymeleaf为我们[m
[31m-[m
[31m-定义好了org.thymeleaf.spring4.view.ThymeleafView和[m
[31m-[m
[31m-org.thymeleaf.spring4.view.ThymeleafViewResolver（默认使用[m
[31m-[m
[31m-ThymeleafView作为View）。Thymeleaf给我们提供了一个[m
[31m-[m
[31m-SpringTemplateEngine类，用来驱动在Spring  MVC下使用[m
[31m-[m
[31m-Thymeleaf模板引擎，另外还提供了一个TemplateResolver用来[m
[31m-[m
[31m-设置通用的模板引擎（包含前缀、后缀等），这使我们在[m
[31m-[m
[31m-Spring MVC中集成Thymeleaf引擎变得十分简单，代码如下：[m
[31m-[m
[31m-@Bean[m
[31m-public TemplateResolver templateResolver(){[m
[31m-TemplateResolver templateResolver = new ServletContextTemplateResol[m
[31m-templateResolver.setPrefix("/WEB-INF/templates");[m
[31m-templateResolver.setSuffix(".html");[m
[31m-templateResolver.setTemplateMode("HTML5");[m
[31m-return templateResolver;[m
[31m-[m
[31m-}[m
[31m-[m
[31m-@Bean[m
[31m-public SpringTemplateEngine templateEngine(){[m
[31m-SpringTemplateEngine templateEngine = new SpringTemplateEngine();[m
[31m-templateEngine.setTemplateResolver(templateResolver());[m
[31m-return templateEngine;[m
[31m-}[m
[31m-[m
[31m-@Bean[m
[31m-public ThymeleafViewResolver thymeleafViewResolver(){[m
[31m-ThymeleafViewResolver thymeleafViewResolver = new ThymeleafViewReso[m
[31m-thymeleafViewResolver.setTemplateEngine(templateEngine());[m
[31m-       // thymeleafViewResolver.setViewClass(ThymeleafView.class);[m
[31m-              return thymeleafViewResolver;[m
[31m-              }[m
[31m-[m
[31m-7.2.3　Spring Boot的Thymeleaf支持[m
[31m-[m
[31m-     在上一节我们讲述了Thymeleaf与Spring MVC集成的配[m
[31m-置，讲述的目的是为了方便大家理解Spring MVC和Thymeleaf[m
[31m-集成的原理。但在Spring Boot中这一切都是不需要的，Spring[m
[31m-Boot通过org.springframework.boot.autoconfigure.thymeleaf包对[m
[31m-Thymeleaf进行了自动配置，如图7-2所示。[m
[31m-[m
[31m-                                  图7-2　thymeleaf包[m
[31m-[m
[31m-     通过ThymeleafAutoConfiguration类对集成所需要的Bean进[m
[31m-行自动配置，包括templateResolver、templateEngine和[m
[31m-thymeleafViewResolver的配置。[m
[31m-[m
[31m-     通过ThymeleafProperties来配置Thymeleaf，在[m
[31m-application.properties中，以spring.thymeleaf开头来配置，通过[m
[31m-查看ThymeleafProperties的主要源码，我们可以看出如何设置[m
[31m-属性以及默认配置：[m
[31m-[m
[31m-       @ConfigurationProperties("spring.thymeleaf")[m
[31m-       public class ThymeleafProperties {[m
[31m-[m
[31m-              public static final String DEFAULT_PREFIX = "classpath:/templates/"[m
[31m-public static final String DEFAULT_SUFFIX = ".html";[m
[31m-[m
[31m-       /**                                              Boot默认模板，防止在[m
[31m-                                          *前缀设置，Spring[m
[31m-[m
[31m-classpath:/templates/ 目录下[m
[31m-[m
[31m-*/[m
[31m-[m
[31m-private String prefix = DEFAULT_PREFIX;[m
[31m-[m
[31m-/**[m
[31m- * 后缀设置，默认为html[m
[31m-[m
[31m- */[m
[31m-[m
[31m-private String suffix = DEFAULT_SUFFIX;[m
[31m-[m
[31m-/**[m
[31m- * 模板模式设置，默认为HTML 5[m
[31m-[m
[31m- */[m
[31m-[m
[31m-private String mode = "HTML5";[m
[31m-[m
[31m-/**[m
[31m- * 模板的编码设置，默认为UTF-8[m
[31m-[m
[31m- */[m
[31m-[m
[31m-private String encoding = "UTF-8";[m
[31m-[m
[31m-/**[m
[31m- * 模板的媒体类型设置，默认为text/html.[m
[31m-[m
[31m- */[m
[31m-[m
[31m-private String contentType = "text/html";[m
[31m-[m
[31m-       /**[m
[31m-         * 是否开启模板缓存，默认是开启，开发时请关闭[m
[31m-         */[m
[31m-[m
[31m-       private boolean cache = true;[m
[31m-       //….[m
[31m-}[m
[31m-[m
[31m-7.2.4　实战[m
[31m-[m
[31m-     1.新建Spring Boot项目[m
[31m-     选择Thymeleaf依赖，spring-boot-starter-thymeleaf会自动包[m
[31m-含spring-boot-starter-web，如图7-3所示。[m
[31m-[m
[31m-                            图7-3　新建Spring Boot项目[m
[31m-[m
[31m-     2.示例JavaBean[m
[31m-     此类用来在模板页面展示数据用，包含name属性和age属[m
[31m-性：[m
[31m-[m
[31m-       package com.wisely;[m
[31m-       public class Person {[m
[31m-[m
[31m-              private String name;[m
[31m-              private Integer age;[m
[31m-              public Person() {[m
[31m-                      super();[m
[31m-[m
[31m-              }[m
[31m-              public Person(String name, Integer age) {[m
[31m-[m
[31m-                      super();[m
[31m-                      this.name = name;[m
[31m-                      this.age = age;[m
[31m-              }[m
[31m-              public String getName() {[m
[31m-                      return name;[m
[31m-              }[m
[31m-              public void setName(String name) {[m
[31m-                      this.name = name;[m
[31m-              }[m
[31m-              public Integer getAge() {[m
[31m-                      return age;[m
[31m-              }[m
[31m-              public void setAge(Integer age) {[m
[31m-                      this.age = age;[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     3.脚本样式静态文件[m
[31m-[m
[31m-     根据默认原则，脚本样式、图片等静态文件应放置在[m
[31m-src/main/resources/static下，这里引入了Bootstrap和jQuery，结[m
[31m-构如图7-4所示。[m
[31m-[m
[31m-                                    图7-4　文件位置[m
[31m-[m
[31m-     4.演示页面[m
[31m-[m
[31m-     根据默认原则，页面应放置在src/main/resources/templates[m
[31m-下。在src/main/resources/templates下新建index.html，如图7-5[m
[31m-所示。[m
[31m-[m
[31m-       图7-5　新建index.html[m
[31m-[m
[31m-代码如下：[m
[31m-[m
[31m-<html xmlns:th="http://www.thymeleaf.org">[m
[31m-   <head>[m
[31m-         <meta content="text/html;charset=UTF-8"/>[m
[31m-         <meta http-equiv="X-UA-Compatible" content="IE=edge"/>[m
[31m-                        <meta name="viewport" content="width=device-[m
[31m-[m
[31m-width, initial-scale=1"/>[m
[31m-       <link th:href="@{bootstrap/css/bootstrap.min.css}" rel="stylesheet"[m
[31m-                              <link th:href="@{bootstrap/css/bootstrap-[m
[31m-[m
[31m-theme.min.css}" rel="stylesheet"/>[m
[31m-   </head>[m
[31m-   <body>[m
[31m-[m
[31m-   <div class="panel panel-primary">[m
[31m-       <div class="panel-heading">[m
[31m-              <h3 class="panel-title">访问model</h3>[m
[31m-       </div>[m
[31m-       <div class="panel-body">[m
[31m-              <span th:text="${singlePerson.name}"></span>[m
[31m-       </div>[m
[31m-[m
[31m-   </div>[m
[31m-[m
[31m-   <div th:if="${not #lists.isEmpty(people)}">[m
[31m-          <div class="panel panel-primary">[m
[31m-              <div class="panel-heading">[m
[31m-                     <h3 class="panel-title">列表</h3>[m
[31m-              </div>[m
[31m-              <div class="panel-body">[m
[31m-                     <ul class="list-group">[m
[31m-                                                                    <li class="list-group-[m
[31m-[m
[31m-item" th:each="person:${people}">[m
[31m-                                    <span th:text="${person.name}"></span>[m
[31m-[m
[31m-                                  <span th:text="${person.age}"></span>[m
[31m-                                  <button class="btn" th:onclick="'getName(\'' + ${per[m
[31m-获得名字</button>[m
[31m-                             </li>[m
[31m-                     </ul>[m
[31m-              </div>[m
[31m-         </div>[m
[31m- </div>[m
[31m-[m
[31m-                     <script                th:src="@{jquery-[m
[31m-[m
[31m-1.10.2.min.js}" type="text/javascript"></script><!-- 2 -->[m
[31m-[m
[31m-<script th:src="@{bootstrap/js/bootstrap.min.js}">[m
[31m-[m
[31m-</script><!-- 2 -->[m
[31m-[m
[31m-<script th:inline="javascript">[m
[31m-   var single = [[${singlePerson}]];[m
[31m-   console.log(single.name+"/"+single.age)[m
[31m-[m
[31m-   function getName(name){[m
[31m-          console.log(name);[m
[31m-[m
[31m-   }[m
[31m-</script>[m
[31m-[m
[31m- </body>[m
[31m-</html>[m
[31m-[m
[31m-5.数据准备[m
[31m-[m
[31m-代码如下：[m
[31m-[m
[31m-package com.wisely;[m
[31m-[m
[31m-import java.util.ArrayList;[m
[31m-import java.util.List;[m
[31m-[m
[31m-import org.springframework.boot.SpringApplication;[m
[31m-import org.springframework.boot.autoconfigure.SpringBootApplication;[m
[31m-import org.springframework.stereotype.Controller;[m
[31m-import org.springframework.ui.Model;[m
[31m-import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-@Controller[m
[31m-@SpringBootApplication[m
[31m-public class Ch72Application {[m
[31m-[m
[31m-       @RequestMapping("/")[m
[31m-       public String index(Model model){[m
[31m-[m
[31m-              Person single = new Person("aa",11);[m
[31m-[m
[31m-              List<Person> people = new ArrayList<Person>();[m
[31m-              Person p1 = new Person("xx",11);[m
[31m-              Person p2 = new Person("yy",22);[m
[31m-              Person p3 = new Person("zz",33);[m
[31m-              people.add(p1);[m
[31m-              people.add(p2);[m
[31m-              people.add(p3);[m
[31m-[m
[31m-              model.addAttribute("singlePerson", single);[m
[31m-              model.addAttribute("people", people);[m
[31m-[m
[31m-              return "index";[m
[31m-       }[m
[31m-[m
[31m-       public static void main(String[] args) {[m
[31m-              SpringApplication.run(Ch72Application.class, args);[m
[31m-[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-6.运行[m
[31m-[m
[31m-访问http://localhost：8080，效果如图7-6所示。[m
[31m-[m
[31m-单击“获得名字”选项，效果如图7-7所示。[m
[31m-图7-6　访问http://localhost：8080[m
[31m-图7-7　单击获得名字[m
[31m-7.3　Web相关配置[m
[31m-[m
[31m-7.3.1　Spring Boot提供的自动配置[m
[31m-[m
[31m-     通过查看WebMvcAutoConfiguration及WebMvcProperties的[m
[31m-源码，可以发现Spring Boot为我们提供了如下的自动配置。[m
[31m-[m
[31m-1.自动配置的ViewResolver[m
[31m-[m
[31m-（1）ContentNegotiatingViewResolver[m
[31m-[m
[31m-这是Spring  MVC提供的一个特殊的ViewResolver，[m
[31m-[m
[31m-ContentNegotiatingViewResolver不是自己处理View，而是代理[m
[31m-[m
[31m-给不同的ViewResolver来处理不同的View，所以它有最高的优[m
[31m-[m
[31m-先级。[m
[31m-[m
[31m-（2）BeanNameViewResolver[m
[31m-[m
[31m-     在控制器（@Controller）中的一个方法的返回值的字符串[m
[31m-（视图名）会根据BeanNameViewResolver去查找Bean的名称[m
[31m-为返回字符串的View来渲染视图。是不是不好理解，下面举[m
[31m-个小例子。[m
[31m-[m
[31m-定义BeanNameViewResolver的Bean：[m
[31m-[m
[31m-@Bean[m
[31m-[m
[31m-       public BeanNameViewResolver beanNameViewResolver() {[m
[31m-              BeanNameViewResolver resolver = new BeanNameViewResolver();[m
[31m-              return resolver;[m
[31m-[m
[31m-       }[m
[31m-     定义一个View的Bean，名称为jsonView：[m
[31m-[m
[31m-       @Bean[m
[31m-              public MappingJackson2JsonView jsonView(){[m
[31m-                      MappingJackson2JsonView jsonView = new MappingJackson2JsonView([m
[31m-                      return jsonView;[m
[31m-              }[m
[31m-[m
[31m-     在控制器中，返回值为字符串jsonView，它会找Bean的名[m
[31m-称为jsonView的视图来渲染：[m
[31m-[m
[31m-       @RequestMapping(value = "/json",produces=[m
[31m-       {MediaType.APPLICATION_JSON_VALUE})[m
[31m-[m
[31m-              public String json(Model model) {[m
[31m-                      Person single = new Person("aa",11);[m
[31m-                      model.addAttribute("single", single);[m
[31m-                      return "jsonView";[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-     （3）InternalResourceViewResolver[m
[31m-[m
[31m-     这个是一个极为常用的ViewResolver，主要通过设置前[m
[31m-缀、后缀，以及控制器中方法来返回视图名的字符串，以得到[m
[31m-实际页面，Spring Boot的源码如下：[m
[31m-[m
[31m-                      @Bean[m
[31m-                      @ConditionalOnMissingBean(InternalResourceViewResolver.class)[m
[31m-                      public InternalResourceViewResolver defaultViewResolver() {[m
[31m-[m
[31m-                             InternalResourceViewResolver resolver = new InternalResourc[m
[31m-                             resolver.setPrefix(this.prefix);[m
[31m-                             resolver.setSuffix(this.suffix);[m
[31m-                             return resolver;[m
[31m-                      }[m
[31m-     2.自动配置的静态资源[m
[31m-[m
[31m-     在自动配置类的addResourceHandlers方法中定义了以下静[m
[31m-态资源的自动配置。[m
[31m-[m
[31m-     （1）类路径文件[m
[31m-[m
[31m-     把类路径下的/static、/public、/resources和/META-[m
[31m-INF/resources文件夹下的静态文件直接映射为/**，可以通过[m
[31m-http://localhost：8080/**来访问。[m
[31m-[m
[31m-     （2）webjar[m
[31m-[m
[31m-     何谓webjar，webjar就是将我们常用的脚本框架封装在jar[m
[31m-包中的jar包，更多关于webjar的内容请访问[m
[31m-http://www.webjars.org网站。[m
[31m-[m
[31m-     把webjar的/META-INF/resources/webjars/下的静态文件映[m
[31m-射为/webjar/**，可以通过http://localhost：8080/webjar/**来访[m
[31m-问。[m
[31m-[m
[31m-     3.自动配置的Formatter和Converter[m
[31m-[m
[31m-     关于自动配置Formatter和Converter，我们可以看一下[m
[31m-WebMvcAutoConfiguration类中的定义：[m
[31m-[m
[31m-              @Override[m
[31m-                      public void addFormatters(FormatterRegistry registry) {[m
[31m-                                                                           for (Converter<?, ?[m
[31m-[m
[31m-       > converter : getBeansOfType(Converter.class)){[m
[31m-                                    registry.addConverter(converter);[m
[31m-[m
[31m-                             }[m
[31m-[m
[31m-                             for (GenericConverter converter : getBeansOfType(GenericCon[m
[31m-                                    registry.addConverter(converter);[m
[31m-[m
[31m-                             }[m
[31m-                                                                            for (Formatter<?[m
[31m-> formatter : getBeansOfType(Formatter.class)) {[m
[31m-[m
[31m-                             registry.addFormatter(formatter);[m
[31m-                     }[m
[31m-              }[m
[31m-[m
[31m-              private <T> Collection<T> getBeansOfType(Class<T> type) {[m
[31m-                     return this.beanFactory.getBeansOfType(type).values();[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-     从代码中可以看出，只要我们定义了Converter、[m
[31m-GenericConverter和Formatter接口的实现类的Bean，这些Bean[m
[31m-就会自动注册到Spring MVC中。[m
[31m-[m
[31m-     4.自动配置的HttpMessageConverters[m
[31m-[m
[31m-     在WebMvcAutoConfiguration中，我们注册了[m
[31m-messageConverters，代码如下；[m
[31m-[m
[31m-       @Autowired[m
[31m-                      private HttpMessageConverters messageConverters;[m
[31m-[m
[31m-                      @Override[m
[31m-                      public void configureMessageConverters(List<HttpMessageConverte[m
[31m-       >> converters) {[m
[31m-[m
[31m-                             converters.addAll(this.messageConverters.getConverters());[m
[31m-                      }[m
[31m-[m
[31m-在这里直接注入了HttpMessageConverters的Bean，而这个[m
[31m-[m
[31m-Bean是在HttpMessageConvertersAutoConfiguration类中定义[m
[31m-[m
[31m-的，我们自动注册的HttpMessage Converter除了Spring MVC默[m
[31m-[m
[31m-认的ByteArrayHttpMessageConverter、StringHttpMessage[m
[31m-[m
[31m-Converter、Resource  HttpMessageConverter、[m
[31m-[m
[31m-SourceHttpMessageConverter、AllEncompassing[m
[31m-[m
[31m-FormHttpMessageConverter外，在我们的HttpMessageConverters[m
[31m-AutoConfiguration的自动配置文件里还引入了[m
[31m-JacksonHttpMessageConverters Configuration和GsonHttpMessage[m
[31m-ConverterConfiguration，使我们获得了额外的[m
[31m-HttpMessageConverter：[m
[31m-[m
[31m-若jackson的jar包在类路径上，则Spring                Boot通过[m
[31m-[m
[31m-JacksonHttpMessage Converters Configuration增加[m
[31m-[m
[31m-MappingJackson2HttpMessage Converter和Mapping Jackson2[m
[31m-[m
[31m-XmlHttpMessageConverter；[m
[31m-[m
[31m-若gson的jar包在类路径上，则Spring                   Boot通过[m
[31m-[m
[31m-GsonHttpMessageConverter    Configuration增加[m
[31m-[m
[31m-GsonHttpMessageConverter。[m
[31m-[m
[31m-在Spring                    Boot中，如果要新增自定义的[m
[31m-[m
[31m-HttpMessageConverter，则只需定义一个你自己的[m
[31m-[m
[31m-HttpMessageConverters的Bean，然后在此Bean中注册自定义[m
[31m-[m
[31m-HttpMessageConverter即可，例如：[m
[31m-[m
[31m-   @Bean[m
[31m-       public HttpMessageConverters customConverters() {[m
[31m-                                                                      HttpMessageConverter<?[m
[31m-[m
[31m-> customConverter1= new CustomConverter1();[m
[31m-                                                                      HttpMessageConverter<?[m
[31m-[m
[31m-> customConverter2= new CustomConverter2();[m
[31m-              return new HttpMessageConverters(customConverter1, customConver[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-5.静态首页的支持[m
[31m-把静态index.html文件放置在如下目录。[m
[31m-[m
[31m-classpath：/META-INF/resources/index.html[m
[31m-     classpath：/resources/index.html[m
[31m-     classpath：/static/index.html[m
[31m-     classpath：/public/index.html[m
[31m-[m
[31m-     当我们访问应用根目录http://localhost：8080/时，会直接映[m
[31m-射。[m
[31m-[m
[31m-7.3.2　接管Spring Boot的Web配置[m
[31m-[m
[31m-     如果Spring Boot提供的Spring MVC不符合要求，则可以通[m
[31m-过一个配置类（注解有@Configuration的类）加上[m
[31m-@EnableWebMvc注解来实现完全自己控制的MVC配置。[m
[31m-[m
[31m-     当然，通常情况下，Spring Boot的自动配置是符合我们大[m
[31m-多数需求的。在你既需要保留Spring Boot提供的便利，又需要[m
[31m-增加自己的额外的配置的时候，可以定义一个配置类并继承[m
[31m-WebMvcConfigurerAdapter，无须使用@EnableWebMvc注解，[m
[31m-然后按照第4章讲解的Spring MVC的配置方法来添加Spring[m
[31m-Boot为我们所做的其他配置，例如：[m
[31m-[m
[31m-       @Configuration[m
[31m-       public class WebMvcConfig extends WebMvcConfigurerAdapter{[m
[31m-[m
[31m-                @Override[m
[31m-                    public void addViewControllers(ViewControllerRegistry registry)[m
[31m-                           registry.addViewController("/xx").setViewName("/xx");[m
[31m-                    }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     值得指出的是，在这里重写的addViewControllers方法，并[m
[31m-不会覆盖WebMvcAutoConfiguration中的[m
[31m-addViewControllers（在此方法中，Spring Boot将“/”映射至[m
[31m-index.html），这也就意味着我们自己的配置和Spring Boot的[m
[31m-自动配置同时有效，这也是我们推荐添加自己的MVC配置的[m
[31m-方式。[m
[31m-[m
[31m-7.3.3　注册Servlet、Filter、Listener[m
[31m-[m
[31m-     当使用嵌入式的Servlet容器（Tomcat、Jetty等）时，我们[m
[31m-通过将Servlet、Filter和Listener声明为Spring Bean而达到注册[m
[31m-的效果；或者注册ServletRegistrationBean、[m
[31m-FilterRegistrationBean和ServletListenerRegistrationBean的[m
[31m-Bean。[m
[31m-[m
[31m-     （1）直接注册Bean示例，代码如下：[m
[31m-[m
[31m-           @Bean[m
[31m-       public XxServlet xxServlet (){[m
[31m-[m
[31m-                      return new XxServlet();[m
[31m-              }[m
[31m-              @Bean[m
[31m-              public YyFilter yyFilter (){[m
[31m-[m
[31m-                      return new YyFilter();[m
[31m-              }[m
[31m-[m
[31m-              @Bean[m
[31m-              public ZzListener zzListener (){[m
[31m-[m
[31m-                      return new ZzListener();[m
[31m-              }[m
[31m-[m
[31m-     （2）通过RegistrationBean示例：[m
[31m-[m
[31m-           @Bean[m
[31m-               public ServletRegistrationBean servletRegistrationBean()[m
[31m-[m
[31m-       {[m
[31m-                      return new ServletRegistrationBean(new XxServlet(),"/xx/*");[m
[31m-       }[m
[31m-       @Bean[m
[31m-       public FilterRegistrationBean filterRegistrationBean(){[m
[31m-[m
[31m-              FilterRegistrationBean registrationBean = new FilterRegistratio[m
[31m-              registrationBean.setFilter( new YyFilter());[m
[31m-              registrationBean.setOrder(2);[m
[31m-              return registrationBean;[m
[31m-       }[m
[31m-[m
[31m-       @Bean[m
[31m-       public ServletListenerRegistrationBean<ZzListener> zzListenerServle[m
[31m-{[m
[31m-[m
[31m-              return new ServletListenerRegistrationBean<ZzListener>[m
[31m-(new ZzListener());[m
[31m-[m
[31m-       }[m
[31m-7.4　Tomcat配置[m
[31m-[m
[31m-     本节虽然叫Tomcat配置，但其实指的是servlet容器的配[m
[31m-置，因为Spring Boot默认内嵌的Tomcat为servlet容器，所以本[m
[31m-节只讲对Tomcat配置，其实本节的配置对Tomcat、Jetty和[m
[31m-Undertow都是通用的。[m
[31m-[m
[31m-7.4.1　配置Tomcat[m
[31m-[m
[31m-     关于Tomcat的所有属性都在[m
[31m-org.springframework.boot.autoconfigure.web.ServerProperties配置[m
[31m-类中做了定义，我们只需在application.properties配置属性做配[m
[31m-置即可。通用的Servlet容器配置都以“server”作为前缀，而[m
[31m-Tomcat特有配置都以“server.tomcat”作为前缀。下面举一些常[m
[31m-用的例子。[m
[31m-[m
[31m-     配置Servlet容器：[m
[31m-[m
[31m-       server.port= #配置程序端口，默认为8080[m
[31m-       server.session-timeout= #用户会话session过期时间，以秒为单位[m
[31m-       server.context-path= #配置访问路径，默认为/[m
[31m-[m
[31m-     配置Tomcat：[m
[31m-[m
[31m-       server.tomcat.uri-encoding = #配置Tomcat编码，默认为UTF-8[m
[31m-       server.tomcat.compression= # Tomcat是否开启压缩，默认为关闭off[m
[31m-     更为详细的Servlet容器配置及Tomcat配置，请查看附录A[m
[31m-中以“server”和“server.tomcat”为前缀的配置。[m
[31m-[m
[31m-7.4.2　代码配置Tomcat[m
[31m-[m
[31m-如果你需要通过代码的方式配置servlet容器，则可以注册[m
[31m-[m
[31m-一个实现EmbeddedServletContainerCustomizer接口的Bean；若[m
[31m-[m
[31m-想直接配置Tomcat、Jetty、Undertow，则可以直接定定义[m
[31m-[m
[31m-TomcatEmbeddedServletContainerFactory、[m
[31m-[m
[31m-JettyEmbeddedServletContainer             Factory、[m
[31m-[m
[31m-UndertowEmbeddedServletContainerFactory。[m
[31m-[m
[31m-1.通用配置[m
[31m-[m
[31m-（1）新建类的配置：[m
[31m-[m
[31m-package com.wisely.ch7_4;[m
[31m-[m
[31m-import java.util.concurrent.TimeUnit;[m
[31m-[m
[31m-import org.springframework.boot.context.embedded.ConfigurableEmbeddedSe[m
[31m-import org.springframework.boot.context.embedded.EmbeddedServletContain[m
[31m-import org.springframework.boot.context.embedded.ErrorPage;[m
[31m-import org.springframework.http.HttpStatus;[m
[31m-import org.springframework.stereotype.Component;[m
[31m-[m
[31m-@Component[m
[31m-public class CustomServletContainer implements EmbeddedServletContainer[m
[31m-[m
[31m-       @Override[m
[31m-       public void customize(ConfigurableEmbeddedServletContainer containe[m
[31m-[m
[31m-              container.setPort(8888); //1[m
[31m-              container.addErrorPages(new ErrorPage(HttpStatus.NOT_FOUND, "/4[m
[31m-              container.setSessionTimeout(10,TimeUnit.MINUTES); //3[m
[31m-[m
[31m-       }[m
[31m-}[m
[31m-     （2）当前配置文件内配置。若要在当前已有的配置文件[m
[31m-内添加类的Bean的话，则在Spring配置中，注意当前类要声明[m
[31m-为static：[m
[31m-[m
[31m-       @SpringBootApplication[m
[31m-       public class Ch74Application {[m
[31m-[m
[31m-              public static void main(String[] args) {[m
[31m-                      SpringApplication.run(Ch74Application.class, args);[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              @Component[m
[31m-              public static class CustomServletContainer implements EmbeddedServl[m
[31m-[m
[31m-                      @Override[m
[31m-                      public void customize(ConfigurableEmbeddedServletContainer cont[m
[31m-[m
[31m-                             container.setPort(8888); //1[m
[31m-                             container.addErrorPages(new ErrorPage(HttpStatus.NOT_FOUND,[m
[31m-                             container.setSessionTimeout(10,TimeUnit.MINUTES); //3[m
[31m-                      }[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     2.特定配置[m
[31m-[m
[31m-     下面以Tomcat为例（Jetty使用[m
[31m-JettyEmbeddedServletContainerFactory，Undertow使用[m
[31m-UndertowEmbeddedServletContainerFactory）：[m
[31m-[m
[31m-       @Bean[m
[31m-              public EmbeddedServletContainerFactory servletContainer() {[m
[31m-              TomcatEmbeddedServletContainerFactory factory = new TomcatEmbeddedS[m
[31m-[m
[31m-       factory.setPort(8888); //1[m
[31m-       factory.addErrorPages(new ErrorPage(HttpStatus.NOT_FOUND, "/404.html"))[m
[31m-[m
[31m-              factory.setSessionTimeout(10, TimeUnit.MINUTES); //3[m
[31m-              return factory;[m
[31m-       }[m
[31m-     代码解释[m
[31m-     上面两个例子的代码都实现了这些功能：[m
[31m-     ①配置端口号；[m
[31m-     ②配置错误页面，根据HttpStatus中的错误状态信息，直接[m
[31m-转向错误页面，其中404.html放置在src/main/resources/static下[m
[31m-即可；[m
[31m-     ③配置Servlet容器用户会话（session）过期时间。[m
[31m-[m
[31m-7.4.3　替换Tomcat[m
[31m-[m
[31m-     Spring Boot默认使用Tomcat作为内嵌Servlet容器，查看[m
[31m-spring-boot-starter-web依赖，如图7-8所示。[m
[31m-[m
[31m-                     图7-8　查看Spring-boot-starter-web依赖[m
[31m-[m
[31m-     如果要使用Jetty或者Undertow为sevvlet容器，只需修改[m
[31m-spring-boot-starter-web的依赖即可。[m
[31m-[m
[31m-     1.替换为Jetty[m
[31m-     在pom.xml中，将spring-boot-starter-web的依赖由spring-[m
[31m-boot-starter-tomcat替换为spring-boot-starter-Jetty：[m
[31m-[m
[31m-              <dependency>[m
[31m-                             <groupId>org.springframework.boot</groupId>[m
[31m-                                                           <artifactId>spring-boot-starter-[m
[31m-[m
[31m-       web</artifactId>[m
[31m-                             <exclusions>[m
[31m-                                    <exclusion>[m
[31m-                                           <groupId>org.springframework.boot</groupId>[m
[31m-                                                            <artifactId>spring-boot-starter-[m
[31m-[m
[31m-       tomcat</artifactId>[m
[31m-                                    </exclusion>[m
[31m-[m
[31m-                             </exclusions>[m
[31m-                      </dependency>[m
[31m-                      <dependency>[m
[31m-[m
[31m-                             <groupId>org.springframework.boot</groupId>[m
[31m-                                                           <artifactId>spring-boot-starter-[m
[31m-[m
[31m-       jetty</artifactId>[m
[31m-                      </dependency>[m
[31m-[m
[31m-     此时启动Spring Boot，控制台输出效果如图7-9所示。[m
[31m-[m
[31m-                               图7-9　控制台输出效果[m
[31m-[m
[31m-     2.替换为Undertow[m
[31m-[m
[31m-     在pom.xml中，将spring-boot-starter-web的依赖由spring-[m
[31m-boot-starter-tomcat替换为spring-boot-starter-undertow：[m
[31m-[m
[31m-       <dependency>[m
[31m-                             <groupId>org.springframework.boot</groupId>[m
[31m-                                                           <artifactId>spring-boot-starter-[m
[31m-[m
[31m-       web</artifactId>[m
[31m-                             <exclusions>[m
[31m-                                    <exclusion>[m
[31m-                                           <groupId>org.springframework.boot</groupId>[m
[31m-                                                            <artifactId>spring-boot-starter-[m
[31m-       tomcat</artifactId>[m
[31m-[m
[31m-                                    </exclusion>[m
[31m-                             </exclusions>[m
[31m-                      </dependency>[m
[31m-[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework.boot</groupId>[m
[31m-                                                           <artifactId>spring-boot-starter-[m
[31m-[m
[31m-       undertow</artifactId>[m
[31m-              </dependency>[m
[31m-[m
[31m-     此时启动Spring Boot，控制台输出效果如图7-10所示。[m
[31m-[m
[31m-                              图7-10　控制台输出效果[m
[31m-[m
[31m-7.4.4　SSL配置[m
[31m-[m
[31m-     SSL的配置也是我们在实际应用中经常遇到的场景。[m
[31m-[m
[31m-     SSL（Secure Sockets Layer，安全套接层）是为网络通信提[m
[31m-供安全及数据完整性的一种安全协议，SSL在网络传输层对网[m
[31m-络连接进行加密。SSL协议位于TCP/IP协议与各种应用层协议[m
[31m-之间，为数据通信提供安全支持。SSL协议可分为两层：SSL[m
[31m-记录协议（SSL Record Protocol），它建立在可靠的传输协议[m
[31m-（如TCP）之上，为高层协议提供数据封装、压缩、加密等基[m
[31m-本功能的支持。SSL握手协议（SSL Handshake Protocol），它[m
[31m-建立在SSL记录协议之上，用于在实际数据传输开始前，通信[m
[31m-双方进行身份认证、协商加密算法、交换加密密钥等。[m
[31m-[m
[31m-     而在基于B/S的Web应用中，是通过HTTPS来实现SSL的。[m
[31m-HTTPS是以安全为目标的HTTP通道，简单讲是HTTP的安全[m
[31m-版，即在HTTP下加入SSL层，HTTPS的安全基础是SSL。[m
[31m-     因为Spring Boot用的是内嵌的Tomcat，因而我们做SSL配[m
[31m-[m
[31m-置的时候需要做如下的操作。[m
[31m-     1.生成证书[m
[31m-     使用SSL首先需要一个证书，这个证书既可以是自签名[m
[31m-[m
[31m-的，也可以是从SSL证书授权中心获得的。本例为了演示方[m
[31m-便，演示自授权证书的生成。[m
[31m-[m
[31m-     每一个JDK或者JRE里都有一个工具叫keytool，它是一个[m
[31m-证书管理工具，可以用来生成自签名的证书，如图7-11所示。[m
[31m-[m
[31m-                                    图7-11　keytool[m
[31m-[m
[31m-     在配置了JAVA_HOME，并将JAVA_HOME的bin目录加入[m
[31m-到Path后，即可在控制台调用该命令，如图7-12所示。[m
[31m-                           图7-12　将bin目录加入到Path[m
[31m-[m
[31m-     在控制台输入如下命令，然后按照提示操作，如图7-13所[m
[31m-示。[m
[31m-[m
[31m-       keytool –genkey -alias tomcat[m
[31m-[m
[31m-                                图7-13　按照提示操作[m
[31m-     这时候我们在当前目录下生成了一个.keystore文件，这就[m
[31m-是我们要用的证书文件，如图7-14所示。[m
[31m-[m
[31m-                                 图7-14　keystore文件[m
[31m-[m
[31m-     2.Spring Boot配置SSL[m
[31m-     添加一个index.html到src/main/resources/static下，作为测[m
[31m-试。[m
[31m-     将.keystore文件复制到项目的根目录，然后在[m
[31m-application.properties中做如下SSL的配置：[m
[31m-[m
[31m-       server.port = 8443[m
[31m-       server.ssl.key-store = .keystore[m
[31m-[m
[31m-       server.ssl.key-store-password= 111111[m
[31m-       server.ssl.keyStoreType= JKS[m
[31m-       server.ssl.keyAlias: tomcat[m
[31m-     此时启动Spring Boot，控制台输出效果如图7-15所示。[m
[31m-[m
[31m-                              图7-15　控制台输出效果[m
[31m-[m
[31m-     此时访问https://localhost：8443，效果如图7-16所示。[m
[31m-[m
[31m-                            图7-16　访问localhost：8443[m
[31m-[m
[31m-     3.http转向https[m
[31m-     很多时候我们在地址栏输入的是http，但是会自动转向到[m
[31m-https，例如我们访问百度的时候，如图7-17所示。[m
[31m-                              图7-17　http自动转向https[m
[31m-[m
[31m-     要实现这个功能，我们需配置[m
[31m-TomcatEmbeddedServletContainerFactory，并且添加Tomcat的[m
[31m-connector来实现。[m
[31m-[m
[31m-     这时我们需要在配置文件里增加如下配置：[m
[31m-[m
[31m-       import org.apache.catalina.Context;[m
[31m-       import org.apache.catalina.connector.Connector;[m
[31m-       import org.apache.tomcat.util.descriptor.web.SecurityCollection;[m
[31m-       import org.apache.tomcat.util.descriptor.web.SecurityConstraint;[m
[31m-       import org.springframework.boot.SpringApplication;[m
[31m-       import org.springframework.boot.autoconfigure.SpringBootApplication;[m
[31m-       import org.springframework.boot.context.embedded.EmbeddedServletContain[m
[31m-       import org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedS[m
[31m-       import org.springframework.context.annotation.Bean;[m
[31m-[m
[31m-       @SpringBootApplication[m
[31m-       public class Ch74Application {[m
[31m-[m
[31m-              public static void main(String[] args) {[m
[31m-                      SpringApplication.run(Ch74Application.class, args);[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              @Bean[m
[31m-              public EmbeddedServletContainerFactory servletContainer() {[m
[31m-[m
[31m-                  TomcatEmbeddedServletContainerFactory tomcat = new TomcatEmbedded[m
[31m-                         @Override[m
[31m-                         protected void postProcessContext(Context context) {[m
[31m-                             SecurityConstraint securityConstraint = new SecurityConstra[m
[31m-                             securityConstraint.setUserConstraint("CONFIDENTIAL");[m
[31m-                             SecurityCollection collection = new SecurityCollection();[m
[31m-                             collection.addPattern("/*");[m
[31m-                             securityConstraint.addCollection(collection);[m
[31m-                             context.addConstraint(securityConstraint);[m
[31m-[m
[31m-                         }[m
[31m-                      };[m
[31m-[m
[31m-                  tomcat.addAdditionalTomcatConnectors(httpConnector());[m
[31m-                  return tomcat;[m
[31m-              }[m
[31m-              @Bean[m
[31m-              public Connector httpConnector() {[m
[31m-                  Connector connector = new Connector("org.apache.coyote.http11.Htt[m
[31m-                  connector.setScheme("http");[m
[31m-                  connector.setPort(8080);[m
[31m-                  connector.setSecure(false);[m
[31m-                  connector.setRedirectPort(8443);[m
[31m-                  return connector;[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     此时启动Spring Boot，控制台输出效果如图7-18所示。[m
[31m-[m
[31m-                               图7-18　启动Spring Boot[m
[31m-[m
[31m-     此时我们访问：http://localhost：8080，会自动转到[m
[31m-https://localhost：8443，如图7-19所示。[m
[31m-图7-19　自动转到https://localhost：8443[m
[31m-7.5　Favicon配置[m
[31m-[m
[31m-7.5.1　默认的Favicon[m
[31m-[m
[31m-     Spring Boot提供了一个默认的Favicon，每次访问应用的时[m
[31m-候都能看到，如图7-20所示。[m
[31m-[m
[31m-7.5.2　关闭Favicon[m
[31m-[m
[31m-     我们可以在application.properties中设置关闭Favicon，默认[m
[31m-为开启，如图7-21所示。[m
[31m-[m
[31m-       spring.mvc.favicon.enabled=false[m
[31m-[m
[31m-                                图7-20　默认的Favicon[m
[31m-                                 图7-21　关闭Favicon[m
[31m-[m
[31m-7.5.3　设置自己的Favicon[m
[31m-[m
[31m-     若需要设置自己的Favicon，则只需将自己的[m
[31m-favicon.ico（文件名不能变动）文件放置在类路径根目录、类[m
[31m-路径META-INF/resources/下、类路径resources/下、类路径[m
[31m-static/下或类路径public/下。这里将favicon.ico放置在[m
[31m-src/main/resources/static下，运行效果如图7-22所示。[m
[31m-[m
[31m-                                   图7-22　运行效果[m
[31m-7.6　WebSocket[m
[31m-[m
[31m-7.6.1　什么是WebSocket[m
[31m-[m
[31m-     WebSocket为浏览器和服务端提供了双工异步通信的功[m
[31m-能，即浏览器可以向服务端发送消息，服务端也可以向浏览器[m
[31m-发送消息。WebSocket需浏览器的支持，如IE 10+、Chrome[m
[31m-13+、Firefox 6+，这对我们现在的浏览器来说都不是问题。[m
[31m-[m
[31m-     WebSocket是通过一个socket来实现双工异步通信能力的。[m
[31m-但是直接使用WebSocket（或者SockJS：WebSocket协议的模[m
[31m-拟，增加了当浏览器不支持WebSocket的时候的兼容支持）协[m
[31m-议开发程序显得特别烦琐，我们会使用它的子协议STOMP，[m
[31m-它是一个更高级别的协议，STOMP协议使用一个基于帧[m
[31m-（frame）的格式来定义消息，与HTTP的request和response类[m
[31m-似（具有类似于@RequestMapping的@MessageMapping），我[m
[31m-们会在后面实战内容中观察STOMP的帧。[m
[31m-[m
[31m-7.6.2　Spring Boot提供的自动配置[m
[31m-[m
[31m-     Spring Boot对内嵌的Tomcat（7或者8）、Jetty9和Undertow[m
[31m-使用WebSocket提供了支持。配置源码存于[m
[31m-org.springframework.boot.autoconfigure.websocket下，如图7-23[m
[31m-所示。[m
[31m-                                图7-23　源码存放位置[m
[31m-[m
[31m-     Spring Boot为WebSocket提供的stater pom是spring-boot-[m
[31m-starter-websocket。[m
[31m-[m
[31m-7.6.3　实战[m
[31m-[m
[31m-     1.准备[m
[31m-     新建Spring Boot项目，选择Thymeleaf和Websocket依赖，[m
[31m-如图7-24所示。[m
[31m-                       图7-24　选择Thymeleaf和Websocket[m
[31m-[m
[31m-     2.广播式[m
[31m-[m
[31m-     广播式即服务端有消息时，会将消息发送给所有连接了当[m
[31m-前endpoint的浏览器。[m
[31m-[m
[31m-     （1）配置WebSocket，需要在配置类上使用[m
[31m-@EnableWebSocketMessageBroker开启WebSocket支持，并通[m
[31m-过继承AbstractWebSocketMessageBrokerConfigurer类，重写其[m
[31m-方法来配置WebSocket。[m
[31m-[m
[31m-     代码如下：[m
[31m-       package com.wisely.ch7_6;[m
[31m-[m
[31m-       import org.springframework.context.annotation.Configuration;[m
[31m-       import org.springframework.messaging.simp.config.MessageBrokerRegistry;[m
[31m-       import org.springframework.web.socket.config.annotation.AbstractWebSock[m
[31m-       import org.springframework.web.socket.config.annotation.EnableWebSocket[m
[31m-       import org.springframework.web.socket.config.annotation.StompEndpointRe[m
[31m-[m
[31m-       @Configuration[m
[31m-       @EnableWebSocketMessageBroker//1[m
[31m-       public class WebSocketConfig extends AbstractWebSocketMessageBrokerConf[m
[31m-[m
[31m-              @Override[m
[31m-              public void registerStompEndpoints(StompEndpointRegistry registry)[m
[31m-[m
[31m-                      registry.addEndpoint("/endpointWisely").withSockJS(); //3[m
[31m-              }[m
[31m-[m
[31m-              @Override[m
[31m-              public void configureMessageBroker(MessageBrokerRegistry registry)[m
[31m-[m
[31m-                      registry.enableSimpleBroker("/topic"); //5[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①通过@EnableWebSocketMessageBroker注解开启使用[m
[31m-STOMP协议来传输基于代理（message broker）的消息，这时[m
[31m-控制器支持使用@MessageMapping，就像使用[m
[31m-@RequestMapping一样。[m
[31m-[m
[31m-     ②注册STOMP协议的节点（endpoint），并映射的指定的[m
[31m-URL。[m
[31m-[m
[31m-     ③注册一个STOMP的endpoint，并指定使用SockJS协议。[m
[31m-[m
[31m-     ④配置消息代理（Message Broker）。[m
[31m-[m
[31m-     ⑤广播式应配置一个/topic消息代理。[m
[31m-（2）浏览器向服务端发送的消息用此类接受：[m
[31m-[m
[31m-package com.wisely.ch7_6.domain;[m
[31m-[m
[31m-public class WiselyMessage {[m
[31m-       private String name;[m
[31m-[m
[31m-       public String getName(){[m
[31m-              return name;[m
[31m-[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-（3）服务端向浏览器发送的此类的消息：[m
[31m-[m
[31m-package com.wisely.ch7_6.domain;[m
[31m-[m
[31m-public class WiselyResponse {[m
[31m-       private String responseMessage;[m
[31m-       public WiselyResponse(String responseMessage){[m
[31m-              this.responseMessage = responseMessage;[m
[31m-       }[m
[31m-       public String getResponseMessage(){[m
[31m-              return responseMessage;[m
[31m-       }[m
[31m-[m
[31m-}[m
[31m-[m
[31m-（4）演示控制器，代码如下：[m
[31m-[m
[31m-package com.wisely.ch7_6.web;[m
[31m-[m
[31m-import org.springframework.messaging.handler.annotation.MessageMapping;[m
[31m-import org.springframework.messaging.handler.annotation.SendTo;[m
[31m-import org.springframework.stereotype.Controller;[m
[31m-[m
[31m-import com.wisely.ch7_6.domain.WiselyMessage;[m
[31m-import com.wisely.ch7_6.domain.WiselyResponse;[m
[31m-[m
[31m-@Controller[m
[31m-public class WsController {[m
[31m-@MessageMapping("/welcome") //1[m
[31m-@SendTo("/topic/getResponse") //2[m
[31m-[m
[31m-       public WiselyResponse say(WiselyMessage message) throws Exception {[m
[31m-                     Thread.sleep(3000);[m
[31m-                     return new WiselyResponse("Welcome, " + message.getName() +[m
[31m-[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①当浏览器向服务端发送请求时，通过@MessageMapping[m
[31m-映射/welcome这个地址，类似于@RequestMapping。[m
[31m-[m
[31m-     ②当服务端有消息时，会对订阅了@SendTo中的路径的浏[m
[31m-览器发送消息。[m
[31m-[m
[31m-     （5）添加脚本。将stomp.min.js（STOMP协议的客户端脚[m
[31m-本）、sockjs.min.js（SockJS的客户端脚本）以及jQuery放置在[m
[31m-src/main/resources/static下。读者可在这一章的源码里找到这几[m
[31m-个脚本，或者自行下载。[m
[31m-[m
[31m-     （6）演示页面。在src/main/resources/templates下新建[m
[31m-ws.html，代码如下：[m
[31m-[m
[31m-<!DOCTYPE html>[m
[31m-[m
[31m-<html xmlns:th="http://www.thymeleaf.org">[m
[31m-[m
[31m-<head>[m
[31m-[m
[31m-       <meta charset="UTF-8" />[m
[31m-       <title>Spring Boot+WebSocket+广播式</title>[m
[31m-[m
[31m-</head>[m
[31m-[m
[31m-<body onload="disconnect()">[m
[31m-[m
[31m-<noscript><h2  style="color:  #ff0000">貌似你的浏览器不支持[m
[31m-[m
[31m-websocket</h2></noscript>[m
[31m-[m
[31m-<div>[m
[31m-[m
[31m-<div>[m
[31m-[m
[31m-               <button id="connect" onclick="connect();">连接[m
[31m-</button>[m
[31m-[m
[31m-              <button id="disconnect" disabled="disabled" onclick="disconnect[m
[31m-断开连接</button>[m
[31m-[m
[31m-</div>[m
[31m-[m
[31m-<div id="conversationDiv">[m
[31m-[m
[31m-                                 <label>输入你的名字</label>[m
[31m-[m
[31m-<input type="text" id="name" />[m
[31m-                      <button id="sendName" onclick="sendName();">发送[m
[31m-[m
[31m-</button>[m
[31m-[m
[31m-        <p id="response"></p>[m
[31m-[m
[31m-</div>[m
[31m-[m
[31m-</div>[m
[31m-[m
[31m-<script th:src="@{sockjs.min.js}"></script>[m
[31m-[m
[31m-<script th:src="@{stomp.min.js}"></script>[m
[31m-[m
[31m-<script th:src="@{jquery.js}"></script>[m
[31m-[m
[31m-<script type="text/javascript">[m
[31m-[m
[31m-var stompClient = null;[m
[31m-[m
[31m-function setConnected(connected) {[m
[31m-       document.getElementById('connect').disabled = connected;[m
[31m-       document.getElementById('disconnect').disabled = !connected;[m
[31m-       document.getElementById('conversationDiv').style.visibility = c[m
[31m-       $('#response').html();[m
[31m-[m
[31m-}[m
[31m-[m
[31m-       function connect() {[m
[31m-              var socket = new SockJS('/endpointWisely'); //1[m
[31m-              stompClient = Stomp.over(socket); //2[m
[31m-              stompClient.connect({}, function(frame) { //3[m
[31m-                     setConnected(true);[m
[31m-                     console.log('Connected: ' + frame);[m
[31m-                     stompClient.subscribe('/topic/getResponse', function(respno[m
[31m-[m
[31m-{ //4[m
[31m-                             showResponse(JSON.parse(respnose.body).responseMessage)[m
[31m-[m
[31m-                     });[m
[31m-              });[m
[31m-       }[m
[31m-       function disconnect() {[m
[31m-              if (stompClient != null) {[m
[31m-[m
[31m-                     stompClient.disconnect();[m
[31m-              }[m
[31m-              setConnected(false);[m
[31m-              console.log("Disconnected");[m
[31m-       }[m
[31m-[m
[31m-function sendName() {[m
[31m-       var name = $('#name').val();[m
[31m-       //5[m
[31m-                      stompClient.send("/welcome", {}, JSON.stringify({ 'name': name[m
[31m-              }[m
[31m-[m
[31m-              function showResponse(message) {[m
[31m-                         var response = $("#response");[m
[31m-                         response.html(message);[m
[31m-[m
[31m-              }[m
[31m-       </script>[m
[31m-       </body>[m
[31m-       </html>[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①连接SockJS的endpoint名称为“/endpointWisely”。[m
[31m-[m
[31m-     ②使用STOMP子协议的WebSocket客户端。[m
[31m-[m
[31m-     ③连接WebSocket服务端。[m
[31m-[m
[31m-     ④通过stompClient.subscribe订阅/topic/getResponse目标[m
[31m-（destination）发送的消息，这个是在控制器的@SendTo中定[m
[31m-义的。[m
[31m-[m
[31m-     ⑤通过stompClient.send向/welcome目标（destination）发送[m
[31m-消息，这个是在控制器的@MessageMapping中定义的。[m
[31m-[m
[31m-     （7）配置viewController，为ws.html提供便捷的路径映[m
[31m-射：[m
[31m-[m
[31m-       @Configuration[m
[31m-       public class WebMvcConfig extends WebMvcConfigurerAdapter{[m
[31m-[m
[31m-                @Override[m
[31m-                    public void addViewControllers(ViewControllerRegistry registry)[m
[31m-                           registry.addViewController("/ws").setViewName("/ws");[m
[31m-                    }[m
[31m-[m
[31m-       }[m
[31m-     （8）运行。我们预期的效果是：当一个浏览器发送一个[m
[31m-消息到服务端时，其他浏览器也能接收到从服务端发送来的这[m
[31m-个消息。[m
[31m-[m
[31m-     开启三个浏览器窗口，并访问http://localhost：8080/ws，分[m
[31m-别连接服务器。然后在一个浏览器中发送一条消息，其他浏览[m
[31m-器接收消息。[m
[31m-[m
[31m-     连接服务端，如图7-25所示。[m
[31m-[m
[31m-                                 图7-25　连接服务器[m
[31m-[m
[31m-     一个浏览器发送消息，如图7-26所示。[m
[31m-[m
[31m-                                   图7-26　发送消息[m
[31m-[m
[31m-     所有浏览器接收服务端发送的消息，如图7-27所示。[m
[31m-[m
[31m-                           图7-27　所有浏览器接收信息[m
[31m-[m
[31m-     我们在Chrome浏览器（在Chrome下按F12调出）下观察一[m
[31m-下STOMP的帧，如图7-28所示。[m
[31m-[m
[31m-                              图7-28　观察STOMP的帧[m
[31m-[m
[31m-     从上述截图可以观察得出，连接服务端的格式为：[m
[31m-[m
[31m-       CONNECT[m
[31m-       accept-version:1.1,1.0[m
[31m-       heart-beat:10000,10000[m
[31m-[m
[31m-     连接成功的返回为：[m
[31m-[m
[31m-       CONNECTED[m
[31m-       version:1.1[m
[31m-       heart-beat:0,0[m
[31m-[m
[31m-     订阅目标（destination）/topic/getResponse：[m
[31m-[m
[31m-       SUBSCRIBE[m
[31m-       id:sub-0[m
[31m-       destination:/topic/getResponse[m
[31m-[m
[31m-     向目标（destination）/welcome发送消息的格式为：[m
[31m-[m
[31m-       SEND[m
[31m-       destination:/welcome[m
[31m-       content-length:14[m
[31m-       {\"name\":\"wyf\"}[m
[31m-     从目标（destination）/topic/getResponse接收的格式为：[m
[31m-[m
[31m-       MESSAGE[m
[31m-       destination:/topic/getResponse[m
[31m-       content-type:application/json;charset=UTF-8[m
[31m-       subscription:sub-0[m
[31m-       message-id:zxj4wyau-0[m
[31m-       content-length:35[m
[31m-       {\"responseMessage\":\"Welcome, wyf!\"}[m
[31m-[m
[31m-     3.点对点式[m
[31m-[m
[31m-     广播式有自己的应用场景，但是广播式不能解决我们一个[m
[31m-常见的场景，即消息由谁发送、由谁接收的问题。[m
[31m-[m
[31m-     本例中演示了一个简单的聊天室程序。例子中只有两个用[m
[31m-户，互相发送消息给彼此，因需要用户相关的内容，所以先在[m
[31m-这里引入最简单的Spring Security相关内容。[m
[31m-[m
[31m-     （1）添加Spring Security的starter pom：[m
[31m-[m
[31m-       <dependency>[m
[31m-                             <groupId>org.springframework.boot</groupId>[m
[31m-                                                           <artifactId>spring-boot-starter-[m
[31m-[m
[31m-       security</artifactId>[m
[31m-                      </dependency>[m
[31m-[m
[31m-     （2）Spring Security的简单配置。这里不对Spring Security[m
[31m-做过多解释，只解释对本项目有帮助的部分：[m
[31m-[m
[31m-       @Configuration[m
[31m-       @EnableWebSecurity[m
[31m-       public class WebSecurityConfig extends WebSecurityConfigurerAdapter{[m
[31m-[m
[31m-              @Override[m
[31m-              protected void configure(HttpSecurity http) throws Exception {[m
[31m-                      http[m
[31m-                                    .authorizeRequests()[m
[31m-                                    .antMatchers("/","/login").permitAll()//1[m
[31m-                                    .anyRequest().authenticated()[m
[31m-                                    .and()[m
[31m-                                    .formLogin()[m
[31m-                                    .loginPage("/login") //2[m
[31m-                                    .defaultSuccessUrl("/chat") //3[m
[31m-                                    .permitAll()[m
[31m-                                    .and()[m
[31m-                                    .logout()[m
[31m-                                    .permitAll();[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              //4[m
[31m-              @Override[m
[31m-              protected void configure(AuthenticationManagerBuilder auth) throws[m
[31m-[m
[31m-                       auth[m
[31m-                                    .inMemoryAuthentication()[m
[31m-                                    .withUser("wyf").password("wyf").roles("USER")[m
[31m-                                    .and()[m
[31m-                                    .withUser("wisely").password("wisely").roles("USER");[m
[31m-[m
[31m-              }[m
[31m-              //5[m
[31m-              @Override[m
[31m-              public void configure(WebSecurity web) throws Exception {[m
[31m-[m
[31m-                      web.ignoring().antMatchers("/resources/static/**");[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①设置Spring Security对/和/“login”路径不拦截。[m
[31m-[m
[31m-     ②设置Spring Security的登录页面访问的路径为/login。[m
[31m-[m
[31m-     ③登录成功后转向/chat路径。[m
[31m-[m
[31m-     ④在内存中分别配置两个用户wyf和wisely，密码和用户名[m
[31m-一致，角色是USER。[m
[31m-     ⑤/resources/static/目录下的静态资源，Spring Security不拦[m
[31m-截。[m
[31m-[m
[31m-     （3）配置WebSocket：[m
[31m-[m
[31m-       @Configuration[m
[31m-       @EnableWebSocketMessageBroker[m
[31m-       public class WebSocketConfig extends AbstractWebSocketMessageBrokerConf[m
[31m-[m
[31m-              @Override[m
[31m-              public void registerStompEndpoints(StompEndpointRegistry registry)[m
[31m-[m
[31m-                      registry.addEndpoint("/endpointWisely").withSockJS();[m
[31m-                      registry.addEndpoint("/endpointChat").withSockJS();//1[m
[31m-              }[m
[31m-[m
[31m-              @Override[m
[31m-              public void configureMessageBroker(MessageBrokerRegistry registry)[m
[31m-[m
[31m-                      registry.enableSimpleBroker("/queue","/topic"); //2[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①注册一个名为/endpointChat的endpoint。[m
[31m-[m
[31m-     ②点对点式应增加一个/queue消息代理。[m
[31m-[m
[31m-     （4）控制器。在WsController内添加如下代码：[m
[31m-[m
[31m-              @Autowired[m
[31m-              private SimpMessagingTemplate messagingTemplate;//1[m
[31m-[m
[31m-              @MessageMapping("/chat")[m
[31m-              public void handleChat(Principal principal, String msg) { //2[m
[31m-[m
[31m-                      if (principal.getName().equals("wyf")) {//3[m
[31m-                             messagingTemplate.convertAndSendToUser("wisely",[m
[31m-                                           "/queue/notifications", principal.getName() + "-[m
[31m-send:"                                        + msg); //4[m
[31m-          } else {[m
[31m-send:"[m
[31m-       }         messagingTemplate.convertAndSendToUser("wyf",[m
[31m-                               "/queue/notifications", principal.getName() + "-[m
[31m-[m
[31m-                                              + msg);[m
[31m-          }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①通过SimpMessagingTemplate向浏览器发送消息。[m
[31m-[m
[31m-     ②在Spring MVC中，可以直接在参数中获得principal，[m
[31m-pinciple中包含当前用户的信息。[m
[31m-[m
[31m-     ③这里是一段硬编码，如果发送人是wyf，则发送给[m
[31m-wisely；如果发送人是wisely，则发送给wyf，读者可以根据项[m
[31m-目实际需要改写此处代码。[m
[31m-[m
[31m-     ④通过messagingTemplate.convertAndSendToUser向用户发[m
[31m-送消息，第一个参数是接收消息的用户，第二个是浏览器订阅[m
[31m-的地址，第三个是消息本身。[m
[31m-[m
[31m-     （5）登录页面。在src/main/resources/templates下新建[m
[31m-login.html，代码如下：[m
[31m-[m
[31m-       <!DOCTYPE html>[m
[31m-       <html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymele[m
[31m-[m
[31m-                     xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-[m
[31m-       springsecurity3">[m
[31m-       <meta charset="UTF-8" />[m
[31m-       <head>[m
[31m-[m
[31m-              <title>登录页面</title>[m
[31m-       </head>[m
[31m-       <body>[m
[31m-<div th:if="${param.error}">[m
[31m-       无效的账号和密码[m
[31m-[m
[31m-</div>[m
[31m-[m
[31m-<div th:if="${param.logout}">[m
[31m-       你已注销[m
[31m-[m
[31m-</div>[m
[31m-[m
[31m-<form th:action="@{/login}" method="post">[m
[31m-[m
[31m-                               <div><label>                 账[m
[31m-[m
[31m-号 : <input type="text" name="username"/> </label></div>[m
[31m-[m
[31m-                               <div><label>                 密[m
[31m-[m
[31m-码: <input type="password" name="password"/> </label></div>[m
[31m-[m
[31m-<div><input type="submit" value="登陆"/></div>[m
[31m-[m
[31m-</form>[m
[31m-[m
[31m-</body>[m
[31m-[m
[31m-</html>[m
[31m-[m
[31m-     （6）聊天页面。在src/main/resources/templates下新建[m
[31m-chat.html，代码如下：[m
[31m-[m
[31m-       <!DOCTYPE html>[m
[31m-[m
[31m-       <html xmlns:th="http://www.thymeleaf.org">[m
[31m-       <meta charset="UTF-8" />[m
[31m-       <head>[m
[31m-[m
[31m-              <title>Home</title>[m
[31m-              <script th:src="@{sockjs.min.js}"></script>[m
[31m-              <script th:src="@{stomp.min.js}"></script>[m
[31m-              <script th:src="@{jquery.js}"></script>[m
[31m-       </head>[m
[31m-       <body>[m
[31m-       <p>[m
[31m-              聊天室[m
[31m-       </p>[m
[31m-[m
[31m-       <form id="wiselyForm">[m
[31m-              <textarea rows="4" cols="60" name="text"></textarea>[m
[31m-              <input type="submit"/>[m
[31m-[m
[31m-       </form>[m
[31m-[m
[31m-       <script th:inline="javascript">[m
[31m-              $('#wiselyForm').submit(function(e){[m
[31m-                      e.preventDefault();[m
[31m-                      var text = $('#wiselyForm').find('textarea[name="text"]').val()[m
[31m-                      sendSpittle(text);[m
[31m-              });[m
[31m-[m
[31m-              var sock = new SockJS("/endpointChat"); //1[m
[31m-              var stomp = Stomp.over(sock);[m
[31m-              stomp.connect('guest', 'guest', function(frame) {[m
[31m-[m
[31m-                      stomp.subscribe("/user/queue/notifications", handleNotification[m
[31m-              });[m
[31m-[m
[31m-              function handleNotification(message) {[m
[31m-                                                                               $('#output').append("[m
[31m-[m
[31m-       <b>Received: " + message.body + "</b><br/>")[m
[31m-              }[m
[31m-[m
[31m-              function sendSpittle(text) {[m
[31m-                      stomp.send("/chat", {}, text);//3[m
[31m-[m
[31m-              }[m
[31m-              $('#stop').click(function() {sock.close()});[m
[31m-       </script>[m
[31m-[m
[31m-       <div id="output"></div>[m
[31m-       </body>[m
[31m-       </html>[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①连接endpoint名称为“/endpointChat”的endpoint。[m
[31m-[m
[31m-     ②订阅/user/queue/notifications发送的消息，这里与在控制[m
[31m-器的messagingTemplate.convertAndSendToUser中定义的订阅地[m
[31m-址保持一致。这里多了一个/user，并且这个/user是必须的，使[m
[31m-用了/user才会发送消息到指定的用户。[m
[31m-[m
[31m-     （7）增加页面的viewController：[m
[31m-[m
[31m-       @Configuration[m
[31m-       publicclass WebMvcConfig extends WebMvcConfigurerAdapter{[m
[31m-[m
[31m-              @Override[m
[31m-              publicvoid addViewControllers(ViewControllerRegistry registry) {[m
[31m-              registry.addViewController("/ws").setViewName("/ws");[m
[31m-              registry.addViewController("/login").setViewName("/login");[m
[31m-              registry.addViewController("/chat").setViewName("/chat");[m
[31m-[m
[31m-                    }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     （8）运行。我们预期的效果是：两个用户登录系统，可[m
[31m-以互发消息。但是一个浏览器的用户会话session是共享的，我[m
[31m-们可以在谷歌浏览器设置两个独立的用户，从而实现用户会话[m
[31m-session隔离，如图7-29所示。[m
[31m-[m
[31m-     现在分别在两个用户下的浏览器访问：http://localhost：[m
[31m-8080/login，并登录，如图7-30所示。[m
[31m-[m
[31m-     wyf用户向wisely用户发送消息，如图7-31所示。[m
[31m-[m
[31m-     wisely用户向wyf用户发送消息如图7-32所示。[m
[31m-         图7-29　两个独立的用户[m
[31m-             图7-30　分别登录[m
[31m-[m
[31m-图7-31　wyf用户向wisely用户发送消息[m
[31m-图7-32　wisely用户向wyf用户发送消息[m
[31m-7.7　基于Bootstrap和AngularJS的现代Web[m
[31m-应用[m
[31m-[m
[31m-     现代的B/S系统软件有下面几个特色。[m
[31m-[m
[31m-     1.单页面应用[m
[31m-[m
[31m-     单页面应用（single-page application，简称SPA）指的是一[m
[31m-种类似于原生客户端软件的更流畅的用户体验的页面。在单页[m
[31m-面应用中，所有的资源（HTML、JavaScript、CSS）都是按需[m
[31m-动态加载到页面上的，且不需要服务端控制页面的转向。[m
[31m-[m
[31m-     2.响应式设计[m
[31m-[m
[31m-     响应式设计（Responsive web design，简称RWD）指的是[m
[31m-不同的设备（电脑、平板、手机）访问相同的页面的时候，得[m
[31m-到不同的页面视图，而得到的视图是适应当前屏幕的。当然就[m
[31m-算在电脑上，我们通过拖动浏览器窗口的大小，也能得到合适[m
[31m-的视图。[m
[31m-[m
[31m-     3.数据导向[m
[31m-[m
[31m-     数据导向是对于页面导向而言的，页面上的数据获得是通[m
[31m-过消费后台的REST服务来实现的，而不是通过服务器渲染的[m
[31m-动态页面（如JSP）来实现的，一般数据交换使用的格式是[m
[31m-JSON。[m
[31m-[m
[31m-     本节将针对Bootstrap和AngularJS进行快速入门式的引导，[m
[31m-如需深入学习，请参考官网或相关专题书籍。[m
[31m-7.7.1　Bootstrap[m
[31m-[m
[31m-     1.什么是Bootstrap[m
[31m-     Bootstrap官方定义：Bootstrap是开发响应式和移动优先的[m
[31m-Web应用的最流行的HTML、CSS、JavaScript框架。[m
[31m-     Boostrap实现了只使用一套代码就可以在不同的设备显示[m
[31m-你想要的视图的功能。Bootstrap还为我们提供了大量美观的[m
[31m-HTML元素前端组件和jQuery插件。[m
[31m-     2.下载并引入Bootstrap[m
[31m-     下载地址：http://getbootstrap.com/getting-started/，如图7-[m
[31m-33所示。[m
[31m-[m
[31m-                                   图7-33　下载页面[m
[31m-[m
[31m-     下载的压缩包的目录结构如图7-34所示。[m
[31m-                             图7-34　目录结构[m
[31m-[m
[31m-最简单的Bootstrap页面模板如下：[m
[31m-[m
[31m-<!DOCTYPE html>[m
[31m-<html lang="zh-cn">[m
[31m-[m
[31m-   <head>[m
[31m-       <meta charset="utf-8">[m
[31m-       <meta http-equiv="X-UA-Compatible" content="IE=edge">[m
[31m-                      <meta name="viewport" content="width=device-[m
[31m-[m
[31m-width, initial-scale=1">[m
[31m-       <!-- 上面3个meta标签必须是head的头三个标签，其余的head内标签在此[m
[31m-[m
[31m-3个之后[m
[31m-The above 3 meta tags *must* come first in the head; any other head con[m
[31m-->[m
[31m-[m
[31m-       <title>Bootstrap基本模板</title>[m
[31m-       <!-- Bootstrap的CSS -->[m
[31m-       <link href="bootstrap/css/bootstrap.min.css" rel="stylesheet">[m
[31m-[m
[31m-       <!-- HTML5 shim[m
[31m-[m
[31m- and Respond.js用来让IE 8支持HTML 5元素和媒体查询 -->[m
[31m-[m
[31m-       <!--[if lt IE 9]>[m
[31m-          <script src[m
[31m-[m
[31m-="js[m
[31m-       /html5shiv.min.js"></script>[m
[31m-                  <script src[m
[31m-[m
[31m-       ="js[m
[31m-[m
[31m-       /respond.min.js"></script>[m
[31m-              <![endif[m
[31m-[m
[31m-       ]-->[m
[31m-           </head>[m
[31m-           <body>[m
[31m-              <h1>你好, Bootstrap!</h1>[m
[31m-              <!-- jQuery是Bootstrap脚本插件必需的 -->[m
[31m-              <script src="js/jquery.min.js"></script>[m
[31m-              <!-- 包含所有编译的插件 -->[m
[31m-              <script src="bootstrap/js/bootstrap.min.js"></script>[m
[31m-           </body>[m
[31m-[m
[31m-       </html>[m
[31m-[m
[31m-     3.CSS支持[m
[31m-     Bootstrap的CSS样式为基础的HTML元素提供了美观的样[m
[31m-式，此外还提供了一个高级的网格系统用来做页面布局。[m
[31m-     （1）布局网格[m
[31m-     在Bootstrap里，行使用的样式为row，列使用col-md-数[m
[31m-字，此数字范围为1～12，所有列加起来的和也是12，代码如[m
[31m-下：[m
[31m-[m
[31m-              <div class="row">[m
[31m-                      <div class="col-md-1">.col-md-1</div>[m
[31m-                      <div class="col-md-1">.col-md-1</div>[m
[31m-                      <div class="col-md-1">.col-md-1</div>[m
[31m-                      <div class="col-md-1">.col-md-1</div>[m
[31m-                      <div class="col-md-1">.col-md-1</div>[m
[31m-                      <div class="col-md-1">.col-md-1</div>[m
[31m-                      <div class="col-md-1">.col-md-1</div>[m
[31m-                      <div class="col-md-1">.col-md-1</div>[m
[31m-                      <div class="col-md-1">.col-md-1</div>[m
[31m-                      <div class="col-md-1">.col-md-1</div>[m
[31m-                      <div class="col-md-1">.col-md-1</div>[m
[31m-                      <div class="col-md-1">.col-md-1</div>[m
[31m-[m
[31m-              </div>[m
[31m-              <div class="row">[m
[31m-[m
[31m-                      <div class="col-md-8">.col-md-8</div>[m
[31m-                      <div class="col-md-4">.col-md-4</div>[m
[31m-              </div>[m
[31m-              <div class="row">[m
[31m-                      <div class="col-md-4">.col-md-4</div>[m
[31m-                      <div class="col-md-4">.col-md-4</div>[m
[31m-                      <div class="col-md-4">.col-md-4</div>[m
[31m-              </div>[m
[31m-              <div class="row">[m
[31m-                      <div class="col-md-6">.col-md-6</div>[m
[31m-                      <div class="col-md-6">.col-md-6</div>[m
[31m-              </div>[m
[31m-[m
[31m-     布局效果如图7-35所示。[m
[31m-                                   图7-35　布局效果[m
[31m-[m
[31m-     （2）html元素[m
[31m-[m
[31m-     Bootstrap为html元素提供了大量的样式，如表单元素、按[m
[31m-钮、图标等。更多内容请查看：http://getbootstrap.com/css/。[m
[31m-[m
[31m-     4.页面组件支持[m
[31m-[m
[31m-     Bootstrap为我们提供了大量的页面组件，包括字体图标、[m
[31m-下拉框、导航条、进度条、缩略图等，更多请阅读[m
[31m-http://getbootstrap.com/components/。[m
[31m-[m
[31m-     5.Javascript支持[m
[31m-[m
[31m-     Bootstrap为我们提供了大量的JavaScript插件，包含模式对[m
[31m-话框、标签页、提示、警告等，更多内容请查看[m
[31m-http://getbootstrap.com/javascript/。[m
[31m-[m
[31m-7.7.2　AngularJS[m
[31m-[m
[31m-     1.什么是AngularJS[m
[31m-[m
[31m-     AngularJS官方定义：AngularJS是HTML开发本应该的样[m
[31m-子，它是用来设计开发Web应用的。[m
[31m-[m
[31m-     AngularJS使用声名式模板+数据绑定（类似于JSP、[m
[31m-Thymeleaf）、MVW（Model-View-Whatever）、[m
[31m-MVVM（Model-View-ViewModel）、MVC（Model-View-[m
[31m-Controller）、依赖注入和测试，但是这一切的实现却只借助纯[m
[31m-客户端的JavaScript。[m
[31m-[m
[31m-     HTML一般是用来声明静态页面的，但是通常情况下我们[m
[31m-希望页面是基于数据动态生成的，这也是我们很多服务端模板[m
[31m-引擎出现的原因；而AngularJS可以只通过前端技术就实现动[m
[31m-态的页面。[m
[31m-[m
[31m-     2.下载并引入AngularJS[m
[31m-     AngularJS下载地址：https://angularjs.org/，如图7-36所示。[m
[31m-[m
[31m-                                   图7-36　下载页面[m
[31m-[m
[31m-     最简单的AngularJS页面：[m
[31m-[m
[31m-       <!doctype html>[m
[31m-       <html ng-app><!-- 1 -->[m
[31m-[m
[31m-           <head>[m
[31m-              <script src="js/angular.min.js"></script><!-- 2 -->[m
[31m-[m
[31m-           </head>[m
[31m-           <body>[m
[31m-[m
[31m-              <div>[m
[31m-                  <label>名字:</label>[m
[31m-                   <input type="text" ng-model="yourName" placeholder="輸[m
[31m-[m
[31m-       入你的名字"><!-- 3 -->[m
[31m-                  <hr>[m
[31m-                  <h1>你好 {{yourName}}!</h1><!-- 4 -->[m
[31m-[m
[31m-              </div>[m
[31m-           </body>[m
[31m-       </html>[m
[31m-[m
[31m-     代码解释[m
[31m-     ①ng-app所作用的范围是AngularJS起效的范围，本例是整[m
[31m-个页面有效。[m
[31m-     ②载入AngularJS的脚本。[m
[31m-     ③ng-model定义整个AngularJS的前端数据模型，模型的名[m
[31m-称为yourName，模型的值来自你输入的值若输入的值改变，[m
[31m-则数据模型值也会改变。[m
[31m-     ④使用{{模型名}}来读取模型中的值。[m
[31m-     效果如图7-37所示。[m
[31m-[m
[31m-                                   图7-37　运行效果[m
[31m-[m
[31m-     3.模块、控制器和数据绑定[m
[31m-     我们对MVC的概念已经烂熟于心了，但是平时的MVC都[m
[31m-是服务端的MVC，这里用AngularJS实现了纯页面端的MVC，[m
[31m-即实现了视图模板、数据模型、代码控制的分离。[m
[31m-     再来看看数据绑定，数据绑定是将视图和数据模型绑定在[m
[31m-一起。如果视图变了，则模型的值就变了；如果模型值变了，[m
[31m-则视图也会跟着改变。[m
[31m-     AngularJS为了分离代码达到复用的效果，提供了一个[m
[31m-module（模块）。定义一个模块需使用下面的代码。[m
[31m-[m
[31m-     无依赖模块：[m
[31m-[m
[31m-       angular.module('firstModule',[]);[m
[31m-[m
[31m-     有依赖模块：[m
[31m-[m
[31m-       angular.module('firstModule',['moduleA','moduleB']);[m
[31m-[m
[31m-     我们看到了V就是我们的页面元素，M就是我们的ng-[m
[31m-model，那C呢？我们可以通过下面的代码来定义控制器，页[m
[31m-面使用ng-controller来和其关联：[m
[31m-[m
[31m-       angular.module('firstModule',[])[m
[31m-              .controller('firstController',function(){[m
[31m-              ...[m
[31m-[m
[31m-       };[m
[31m-       );[m
[31m-[m
[31m-       <div ng-controller="firstController">[m
[31m-       ...[m
[31m-       </div>[m
[31m-[m
[31m-     4.Scope和Event[m
[31m-     （1）Scope[m
[31m-     Scope是AngularJS的内置对象，用$Scope来获得。在Scope[m
[31m-中定义的数据是数据模型，可以通过{{模型名}}在视图上获[m
[31m-得。Scope主要是在编码中需要对数据模型进行处理的时候使[m
[31m-用，Scope的作用范围与在页面声明的范围一致（如在[m
[31m-controller内使用，scope的作用范围是页面声明ng-controller标[m
[31m-签元素的作用范围）。[m
[31m-[m
[31m-     定义：[m
[31m-[m
[31m-       $scope.greeting='Hello'[m
[31m-[m
[31m-     获取：[m
[31m-[m
[31m-       {{greeting}}[m
[31m-[m
[31m-     （2）Event[m
[31m-     因为Scope的作用范围不同，所以不同的Scope之间若要交[m
[31m-互的话需要通过事件（Event）来完成。[m
[31m-     1）冒泡事件（Emit）冒泡事件负责从子Scope向上发送事[m
[31m-件，示例如下。[m
[31m-     子Scope发送：[m
[31m-[m
[31m-       $scope.$emit('EVENT_NAME_EMIT ', 'message');[m
[31m-[m
[31m-     父Scope接受：[m
[31m-       $scope.$on(''EVENT_NAME_EMIT', function(event, data) {[m
[31m-       ...[m
[31m-       })[m
[31m-[m
[31m-     2）广播事件（Broadcast）。广播事件负责从父Scope向下[m
[31m-发送事件，示例如下。[m
[31m-[m
[31m-     父Scope发送：[m
[31m-[m
[31m-       $scope.$broadcast('EVENT_NAME_BROAD ', 'message');[m
[31m-[m
[31m-     子scope接受[m
[31m-[m
[31m-       $scope.$on(''EVENT_NAME_BROAD', function(event, data) {[m
[31m-       ...[m
[31m-       })[m
[31m-[m
[31m-     5.多视图和路由[m
[31m-     多视图和路由是AngularJS实现单页面应用的技术关键，[m
[31m-AngularJS内置了一个$routeProvider对象来负责页面加载和页[m
[31m-面路由转向。[m
[31m-     需要注意的是，1.2.0之后的AngularJS将路由功能移出，所[m
[31m-以使用路由功能要另外引入angular-route.js[m
[31m-     例如：[m
[31m-[m
[31m-       angular.module('firstModule').config(function($routeProvider) {[m
[31m-       $routeProvider.when('/view1', { //1[m
[31m-[m
[31m-              controller: 'Controller1', //2[m
[31m-              templateUrl: 'view1.html', //3[m
[31m-       }).when('/view2', {[m
[31m-[m
[31m-              controller: 'Controller2',[m
[31m-              templateUrl: 'view2.html',[m
[31m-       });[m
[31m-       })[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①此处定义的是某个页面的路由名称。[m
[31m-[m
[31m-     ②此处定义的是当前页面使用的控制器。[m
[31m-[m
[31m-     ③此处定义的要加载的真实页面。[m
[31m-[m
[31m-     在页面上可以用下面代码来使用我们定义的路由：[m
[31m-[m
[31m-       <ul>[m
[31m-              <li><a href="#/view1">view1</a></li>[m
[31m-              <li><a href="#/view2">view2</a></li>[m
[31m-[m
[31m-       </ul>[m
[31m-       <ng-view></ng-view> <!-- 此处为加载进来的页面显示的位置-->[m
[31m-[m
[31m-     6.依赖注入[m
[31m-[m
[31m-     依赖注入是AngularJS的一大酷炫功能。可以实现对代码的[m
[31m-解耦，在代码里可以注入AngularJS的对象或者我们自定义的[m
[31m-对象。下面示例是在控制器中注入$scope，注意使用依赖注入[m
[31m-的代码格式。[m
[31m-[m
[31m-             angular.module('firstModule')[m
[31m-              .controller("diController", ['$scope',[m
[31m-[m
[31m-       function ($scope) {[m
[31m-                                      ...[m
[31m-[m
[31m-                      }]);[m
[31m-     7.Service和Factory[m
[31m-[m
[31m-     AngularJS为我们内置了一些服务，如$location、[m
[31m-$timeout、$rootScope（请读者自行学习相关的知识）。很多时[m
[31m-候我们需要自己定制一些服务，AngularJS为我们提供了[m
[31m-Service和Factory。[m
[31m-[m
[31m-     Service和Factory的区别是：使用Service的话，AngularJS会[m
[31m-使用new来初始化对象；而使用Factory会直接获得对象。[m
[31m-[m
[31m-     （1）Service[m
[31m-[m
[31m-     定义：[m
[31m-[m
[31m-       angular.module('firstModule').service('helloService',function()[m
[31m-       {[m
[31m-[m
[31m-              this.sayHello=function(name){[m
[31m-                      alert('Hello '+name);[m
[31m-[m
[31m-              }[m
[31m-       });[m
[31m-[m
[31m-     注入调用：[m
[31m-[m
[31m-             angular.module('firstModule')[m
[31m-              .controller("diController", ['$scope', 'helloService',[m
[31m-[m
[31m-       function ($scope,helloService) {[m
[31m-                                      helloService.sayHello('wyf');[m
[31m-[m
[31m-                      }]);[m
[31m-[m
[31m-     （2）Factory[m
[31m-[m
[31m-     定义：[m
[31m-       angular.module('firstModule').service('helloFactory',function()[m
[31m-       {[m
[31m-[m
[31m-              return{[m
[31m-              sayHello:function(name){[m
[31m-[m
[31m-                             alert('Hello '+name);[m
[31m-                      }[m
[31m-              }[m
[31m-       });[m
[31m-[m
[31m-     注入调用：[m
[31m-[m
[31m-             angular.module('firstModule')[m
[31m-              .controller("diController", ['$scope', 'helloFactory',[m
[31m-[m
[31m-       function ($scope, helloFactory) {[m
[31m-                                      helloFactory.sayHello('wyf');[m
[31m-[m
[31m-                      }]);[m
[31m-[m
[31m-     8.http操作[m
[31m-[m
[31m-     AngularJS内置了$http对象用来进行Ajax的操作：[m
[31m-[m
[31m-       $http.get(url)[m
[31m-       $http.post(url,data)[m
[31m-       $http.put(url,data)[m
[31m-       $http.delete(url)[m
[31m-       $http.head(url)[m
[31m-[m
[31m-     9.自定义指令[m
[31m-[m
[31m-     AngularJS内置了大量的指令（directive），如ng-repeat、[m
[31m-ng-show、ng-model等。即使用一个简短的指令可实现一个前[m
[31m-端组件。[m
[31m-[m
[31m-     比方说，有一个日期的js/jQuery插件，使用AngularJS封装[m
[31m-后，在页面上调用此插件可以通过指令来实现，例如：[m
[31m-[m
[31m-       元素指令: <date-picker></date-picker>[m
[31m-       属性指令: <input type="text" date-picker/>[m
[31m-       样式指令: <input type="text" class="date-picker"/>[m
[31m-       注释指令 : <!--directive:date-picker-->[m
[31m-[m
[31m-     定义指令：[m
[31m-[m
[31m-       angular.module('myApp',[m
[31m-       []).directive('helloWorld', function() {[m
[31m-       return {[m
[31m-[m
[31m-              restrict: 'AE',//支持使用属性、元素[m
[31m-              replace: true,[m
[31m-              template: '<h3>Hello, World!</h3>'[m
[31m-       };[m
[31m-       });[m
[31m-[m
[31m-     调用指令，元素标签：[m
[31m-[m
[31m-       <hello-world/>[m
[31m-       <hello:world/>[m
[31m-[m
[31m-     或者属性方式：[m
[31m-[m
[31m-       <div hello-world />[m
[31m-[m
[31m-7.7.3　实战[m
[31m-     在前面两节，我们快速介绍了Bootstrap和AngularJS，本节[m
[31m-我们将它们和Spring Boot串起来做个例子。[m
[31m-[m
[31m-     在例子中，我们使用Bootstrap制作导航，使用AngularJS实[m
[31m-现导航切换页面的路由功能，并演示AngularJS通过$http服务[m
[31m-和Spring Boot提供的REST服务，最后演示用指令封装jQuery[m
[31m-UI的日期选择器。[m
[31m-[m
[31m-     1.新建Spring Boot项目[m
[31m-[m
[31m-     初始化一个Spring Boot项目，依赖只需选择Web（spring-[m
[31m-boot-starter-web）。[m
[31m-[m
[31m-     项目信息：[m
[31m-[m
[31m-       groupId：com.wisely[m
[31m-       arctifactId:ch7_7[m
[31m-       package: com.wisely.ch7_7[m
[31m-[m
[31m-     准备Bootstrap、AngularJS、jQuery、jQueryUI相关的资源[m
[31m-到src/main/resources/static下，结构如图7-38所示。[m
[31m-                                      图7-38　结构[m
[31m-[m
[31m-     另外要说明的是，本例的页面都是静态页面，所以全部放[m
[31m-置在/static目录下。[m
[31m-[m
[31m-     2.制作导航[m
[31m-[m
[31m-     页面位置：src/main/resources/static/action.html：[m
[31m-[m
[31m-       <!DOCTYPE html>[m
[31m-       <html lang="zh-cn" ng-app="actionApp">[m
[31m-       <head>[m
[31m-<meta charset="utf-8">[m
[31m-<meta http-equiv="X-UA-Compatible" content="IE=edge">[m
[31m-<meta name="viewport" content="width=device-width, initial-[m
[31m-scale=1">[m
[31m-<title>实战</title>[m
[31m-[m
[31m-<link href="bootstrap/css/bootstrap.min.css" rel="stylesheet">[m
[31m-<link href="jqueryui/jquery-ui.min.css" rel="stylesheet">[m
[31m-<style type="text/css">[m
[31m-[m
[31m-.content {[m
[31m-   padding: 100px 15px;[m
[31m-   text-align: center;[m
[31m-[m
[31m-}[m
[31m-</style>[m
[31m-[m
[31m-<!--[if lt IE 9]>[m
[31m-          <script src="js/html5shiv.min.js"></script>[m
[31m-          <script src="js/respond.min.js"></script>[m
[31m-[m
[31m-       <![endif]-->[m
[31m-</head>[m
[31m-<body>[m
[31m-<!-- 1 -->[m
[31m-[m
[31m-       <nav class="navbar navbar-inverse navbar-fixed-top">[m
[31m-          <div class="container">[m
[31m-[m
[31m-              <div id="navbar" class="collapse navbar-collapse">[m
[31m-                  <ul class="nav navbar-nav">[m
[31m-                     <li><a href="#/oper">后台交互</a></li>[m
[31m-                     <li><a href="#/directive">自定义指令</a></li>[m
[31m-                  </ul>[m
[31m-[m
[31m-              </div>[m
[31m-          </div>[m
[31m-       </nav>[m
[31m-[m
[31m-       <!-- 2 -->[m
[31m-         <div class="content">[m
[31m-              <ng-view></ng-view>[m
[31m-[m
[31m-</div>[m
[31m-<!-- 3 -->[m
[31m-[m
[31m-       <script src="js/jquery.min.js"></script>[m
[31m-       <script src="jqueryui/jquery-ui.min.js"></script>[m
[31m-       <script src="bootstrap/js/bootstrap.min.js"></script>[m
[31m-       <script src="js/angular.min.js"></script>[m
[31m-       <script src="js/angular-route.min.js"></script>[m
[31m-       <script src="js-action/app.js"></script>[m
[31m-       <script src="js-action/directives.js"></script>[m
[31m-       <script src="js-action/controllers.js"></script>[m
[31m-       </body>[m
[31m-       </html>[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①使用Bootstrap定义的导航，并配合AngularJS的路由，通[m
[31m-过路由名称#/oper和#/directive切换视图；[m
[31m-[m
[31m-     ②通过<ng-view></ng-view>展示载入的页面。[m
[31m-[m
[31m-     ③加载本例所需的脚本，其中jquery-ui.min.js的脚本是为我[m
[31m-们定制指令所用；app.js定义AngularJS的模块和路由；[m
[31m-directives.js为自定义的指令；controllers.js是控制器定义之处。[m
[31m-[m
[31m-     3.模块和路由定义[m
[31m-[m
[31m-     页面位置：src/main/resources/static/js-action/app.js：[m
[31m-[m
[31m-       var actionApp = angular.module('actionApp',[m
[31m-       ['ngRoute']); //1[m
[31m-[m
[31m-       actionApp.config(['$routeProvider' , function($routeProvider) {//2[m
[31m-              $routeProvider.when('/oper', { //3[m
[31m-                      controller: 'View1Controller', //4[m
[31m-                      templateUrl: 'views/view1.html', //5[m
[31m-              }).when('/directive', {[m
[31m-                      controller: 'View2Controller',[m
[31m-                      templateUrl: 'views/view2.html',[m
[31m-              });[m
[31m-[m
[31m-       }]);[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①定义模块actionApp，并依赖于路由模块ngRout。[m
[31m-②配置路由，并注入$routeProvider来配置。[m
[31m-③/oper为路由名称。[m
[31m-④controller定义的是路由的控制器名称。[m
[31m-⑤templateUrl定义的是视图的真正地址。[m
[31m-4.控制器定义[m
[31m-脚本位置：src/main/resources/static/js-action/controllers.js：[m
[31m-[m
[31m-//1[m
[31m-actionApp.controller('View1Controller', ['$rootScope', '$scope', '$http[m
[31m-[m
[31m-       //2[m
[31m-       $scope.$on('$viewContentLoaded', function() {[m
[31m-[m
[31m-              console.log('页面加载完成');[m
[31m-       });[m
[31m-       //3[m
[31m-       $scope.search = function(){//3.1[m
[31m-[m
[31m-          personName = $scope.personName; //3.2[m
[31m-          $http.get('search',{ //3.3[m
[31m-[m
[31m-                                      params:{personName:personName}//3.4[m
[31m-                }).success(function(data){ //3.5[m
[31m-[m
[31m-                     $scope.person=data; //3.6[m
[31m-                });[m
[31m-[m
[31m-       };[m
[31m-}]);[m
[31m-[m
[31m-actionApp.controller('View2Controller', ['$rootScope', '$scope',  funct[m
[31m-[m
[31m-       $scope.$on('$viewContentLoaded', function() {[m
[31m-              console.log('页面加载完成');[m
[31m-[m
[31m-       });[m
[31m-[m
[31m-}]);[m
[31m-[m
[31m-代码解释[m
[31m-①定义控制器View1Controller，并注入$rootScope、$scope[m
[31m-和$http。[m
[31m-[m
[31m-     ②使用$scope.$on监听$viewContentLoaded事件，可以在页[m
[31m-面内容加载完成后进行一些操作。[m
[31m-[m
[31m-     ③这段代码是这个演示的核心代码，请结合下面的Viewl[m
[31m-的界面一起理解：[m
[31m-[m
[31m-     在scope内定义一个方法search，在页面上通过ng-click调[m
[31m-     用。[m
[31m-     通过$scope.personName获取页面定义的ng-[m
[31m-     model=“personName”的值。[m
[31m-     使用$http.get向服务端地址search发送get请求。[m
[31m-     使用params增加请求参数。[m
[31m-     用success方法作为请求成功后的回调。[m
[31m-     将服务端返回的数据data通过$scope.person赋给模型[m
[31m-     person，这样页面视图上可以通过{{person.name}}、[m
[31m-     {{person.age}}、{{person.address}}来调用，且模型person[m
[31m-     值改变后，视图是自动更新的。[m
[31m-[m
[31m-     5.View1的界面（演示与服务端交互）[m
[31m-[m
[31m-     页面位置：src/main/resources/static/views/view1.html。[m
[31m-[m
[31m-           <div class="row">[m
[31m-                   <label for="attr" class="col-md-2 control-label">名称[m
[31m-[m
[31m-       </label>[m
[31m-       <div class="col-md-2">[m
[31m-[m
[31m-                  <!-- 1 -->[m
[31m-                                <input type="text" class="form-control" ng-[m
[31m-[m
[31m-       model="personName">[m
[31m-              </div>[m
[31m-[m
[31m-       <div class="col-md-1">[m
[31m-       <!-- 2 -->[m
[31m-[m
[31m-                <button class="btn btn-primary" ng-click="search()">查询[m
[31m-       </button>[m
[31m-   </div>[m
[31m-</div>[m
[31m-[m
[31m-<div class="row">[m
[31m-[m
[31m-<div class="col-md-4">[m
[31m-[m
[31m-        <ul class="list-group">[m
[31m-[m
[31m-           <!-- 3 -->[m
[31m-[m
[31m-                         <li                              class="list-group-item">名[m
[31m-                                                          class="list-group-item">年[m
[31m-字： {{person.name}}</li>                                   class="list-group-item">地[m
[31m-[m
[31m-                         <li[m
[31m-[m
[31m-龄： {{person.age}}</li>[m
[31m-[m
[31m-                                                     <li[m
[31m-址： {{person.address}}</li>[m
[31m-[m
[31m-        </ul>[m
[31m-[m
[31m-</div>[m
[31m-[m
[31m-</div>[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①定义数据模型ng-model=“personName”。[m
[31m-[m
[31m-     ②通过ng-click=“search（）”调用控制器中定义的方法。[m
[31m-[m
[31m-     ③通过{{person.name}}、{{person.age}}、[m
[31m-{{person.address}}访问控制器的scope里定义的person模型，模[m
[31m-型和视图是绑定的。[m
[31m-[m
[31m-     6.服务端代码[m
[31m-[m
[31m-     传值对象Javabean：[m
[31m-[m
[31m-       package com.wisely.ch7_7;[m
[31m-[m
[31m-       public class Person {[m
[31m-              private String name;[m
[31m-              private Integer age;[m
[31m-              private String address;[m
[31m-       public Person() {[m
[31m-              super();[m
[31m-[m
[31m-       }[m
[31m-       public Person(String name, Integer age, String address) {[m
[31m-[m
[31m-              super();[m
[31m-              this.name = name;[m
[31m-              this.age = age;[m
[31m-              this.address = address;[m
[31m-       }[m
[31m-       public String getName() {[m
[31m-              return name;[m
[31m-       }[m
[31m-       public void setName(String name) {[m
[31m-              this.name = name;[m
[31m-       }[m
[31m-       public Integer getAge() {[m
[31m-              return age;[m
[31m-       }[m
[31m-       public void setAge(Integer age) {[m
[31m-              this.age = age;[m
[31m-       }[m
[31m-       public String getAddress() {[m
[31m-              return address;[m
[31m-       }[m
[31m-       public void setAddress(String address) {[m
[31m-              this.address = address;[m
[31m-       }[m
[31m-[m
[31m-}[m
[31m-[m
[31m-控制器：[m
[31m-[m
[31m-package com.wisely.ch7_7;[m
[31m-[m
[31m-import org.springframework.boot.SpringApplication;[m
[31m-import org.springframework.boot.autoconfigure.SpringBootApplication;[m
[31m-import org.springframework.http.MediaType;[m
[31m-import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-import org.springframework.web.bind.annotation.RestController;[m
[31m-[m
[31m-@RestController[m
[31m-       @SpringBootApplication[m
[31m-       public class Ch77Application {[m
[31m-[m
[31m-                                           @RequestMapping(value="/search",produces=[m
[31m-       {MediaType.APPLICATION_JSON_VALUE})[m
[31m-[m
[31m-              public Person search(String personName){[m
[31m-[m
[31m-                      return new Person(personName, 32, "hefei");[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              public static void main(String[] args) {[m
[31m-                      SpringApplication.run(Ch77Application.class, args);[m
[31m-[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     这里我们只是模拟一个查询，即接受前台传入的[m
[31m-personName，然后返回Person类，因为我们使用的是[m
[31m-@RestController，且返回值类型是Person，所以Spring MVC会[m
[31m-自动将对象输出为JSON。[m
[31m-[m
[31m-     7.自定义指令[m
[31m-[m
[31m-     脚本位置：src/main/resources/static/js-action/directives.js：[m
[31m-[m
[31m-       actionApp.directive('datePicker',function(){//1[m
[31m-              return {[m
[31m-                      restrict: 'AC', //2[m
[31m-                      link:function(scope,elem,attrs) { //3[m
[31m-                             elem.datepicker();//4[m
[31m-                      }[m
[31m-              };[m
[31m-[m
[31m-       });[m
[31m-[m
[31m-     代码解释[m
[31m-     ①定义一个指令名为datePicker。[m
[31m-[m
[31m-     ②限制为属性指令和样式指令。[m
[31m-[m
[31m-     ③使用link方法来定义指令，在link方法内可使用当前[m
[31m-scope、当前元素及元素属性。[m
[31m-[m
[31m-     ④初始化jqueryui的datePicker（jquery的写法是$[m
[31m-（‘#id’）.datePicker（））。[m
[31m-[m
[31m-     通过上面的代码我们就定制了一个封装jqueryui的[m
[31m-datePicker的指令，本例只是为了演示的目的，主流的脚本框[m
[31m-架已经被很多人封装过了，有兴趣的读者可以访问[m
[31m-http://ngmodules.org/网站，这个网站包含了大量AngularJS的第[m
[31m-三方模块、插件和指令。[m
[31m-[m
[31m-     8.View2的页面（演示自定义指令）[m
[31m-[m
[31m-     页面地址：src/main/resources/static/views/view2.html：[m
[31m-[m
[31m-           <div class="row">[m
[31m-                <label for="attr" class="col-md-2 control-label">属性形式[m
[31m-[m
[31m-       </label>[m
[31m-       <div class="col-md-2">[m
[31m-[m
[31m-                  <!-- 1 -->[m
[31m-                  <input type="text" class="form-control" date-picker>[m
[31m-              </div>[m
[31m-           </div>[m
[31m-[m
[31m-           <div class="row">[m
[31m-              <label for="style" class="col-md-2 control-label">样式形式[m
[31m-[m
[31m-       </label>[m
[31m-       <div class="col-md-2">[m
[31m-[m
[31m-                  <!-- 2 -->[m
[31m-                  <input type="text" class="form-control date-picker" >[m
[31m-              </div>[m
[31m-           </div>[m
[31m-代码解释[m
[31m-①使用属性形式调用指令。[m
[31m-②使用样式形式调用指令。[m
[31m-9.运行[m
[31m-菜单及路由切换如图7-39所示。[m
[31m-[m
[31m-                        图7-39　菜单及路由交换[m
[31m-[m
[31m-与后台交互如图7-40所示。[m
[31m-                           图7-40　与后台交互[m
[31m-[m
[31m-自定义指令如图7-41所示。[m
[31m-[m
[31m-                           图7-41　自定义指令[m
[31m-第8章　Spring Boot的数据访问[m
[31m-[m
[31m-     Spring Data项目是Spring用来解决数据访问问题的一揽子[m
[31m-解决方案，Spring Data是一个伞形项目，包含了大量关系型数[m
[31m-据库及非关系型数据库的数据访问解决方案。Spring Data使我[m
[31m-们可以快速且简单地使用普通的数据访问技术及新的数据访问[m
[31m-技术。[m
[31m-[m
[31m-     Spring Data包含的子项目如表8-1所示。[m
[31m-[m
[31m-                          表8-1　SpringData包括的子项目[m
[31m-     Spring Data为我们使用统一的API来对上述的数据存储技[m
[31m-术进行数据访问操作提供了支持。这是Spring通过提供Spring[m
[31m-Data Commons项目来实现的，它是上述各种Spring Data项目的[m
[31m-依赖。Spring Data Commons让我们在使用关系型或非关系型[m
[31m-数据访问技术时都使用基于Spring的统一标准，该标准包含[m
[31m-CRUD（创建、获取、更新、删除）、查询、排序和分页的相[m
[31m-关的操作。[m
[31m-[m
[31m-此处介绍下Spring Data Commons的一个重要概念：Spring[m
[31m-[m
[31m-Data Repository抽象。使用Spring Data Repository可以极大地减[m
[31m-[m
[31m-少数据访问层的代码。既然是数据访问操作的统一标准，那肯[m
[31m-[m
[31m-定是定义了各种各样和数据访问相关的接口，Spring      Data[m
[31m-[m
[31m-Repository抽象的根接口是Repository接口：[m
[31m-[m
[31m-package org.springframework.data.repository;[m
[31m-import java.io.Serializable;[m
[31m-public interface Repository<T, ID extends Serializable> {[m
[31m-}[m
[31m-     从源码中可以看出，它接受领域类（JPA为实体类）和领[m
[31m-域类的id类型作为类型参数。[m
[31m-[m
[31m-     它的子接口CrudRepository定义了和CRUD操作相关的内[m
[31m-容：[m
[31m-[m
[31m-       package org.springframework.data.repository;[m
[31m-       import java.io.Serializable;[m
[31m-       @NoRepositoryBean[m
[31m-       public interface CrudRepository<T, ID extends Serializable> extends Rep[m
[31m-[m
[31m-              <S extends T> S save(S entity);[m
[31m-              <S extends T> Iterable<S> save(Iterable<S> entities);[m
[31m-              T findOne(ID id);[m
[31m-              boolean exists(ID id);[m
[31m-              Iterable<T> findAll();[m
[31m-              Iterable<T> findAll(Iterable<ID> ids);[m
[31m-              long count();[m
[31m-              void delete(ID id);[m
[31m-              void delete(T entity);[m
[31m-              void delete(Iterable<? extends T> entities);[m
[31m-              void deleteAll();[m
[31m-       }[m
[31m-[m
[31m-     CrudRepository的子接口PagingAndSortingRepository定义了[m
[31m-与分页和排序操作相关的内容：[m
[31m-[m
[31m-       package org.springframework.data.repository;[m
[31m-       import java.io.Serializable;[m
[31m-       import org.springframework.data.domain.Page;[m
[31m-       import org.springframework.data.domain.Pageable;[m
[31m-       import org.springframework.data.domain.Sort;[m
[31m-[m
[31m-       @NoRepositoryBean[m
[31m-       public interface PagingAndSortingRepository<T, ID extends Serializable>[m
[31m-[m
[31m-              Iterable<T> findAll(Sort sort);[m
[31m-              Page<T> findAll(Pageable pageable);[m
[31m-       }[m
[31m-     不同的数据访问技术也提供了不同的Repository，如Spring[m
[31m-Data JPA有JpaRepository、Spring Data MongoDB有[m
[31m-MongoRepository。[m
[31m-[m
[31m-     Spring Data项目还给我们提供了一个激动人心的功能，即[m
[31m-可以根据属性名进行计数、删除、查询方法等操作，例如：[m
[31m-[m
[31m-       public interface PersonRepository extends Repository<Person, Long> {[m
[31m-              //按照年龄计数[m
[31m-              Long countByAge(Integer age);[m
[31m-              //按照名字删除[m
[31m-              Long deleteByName(String name);[m
[31m-              //按照名字查询[m
[31m-              List<Person> findByName(String name);[m
[31m-              //按照名字和地址查询[m
[31m-              List<Person> findByNameAndAddress(String name,String address);[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     我们将在8.2节对Spring Data提供的简化数据访问操作进行[m
[31m-更为详细的讲解。[m
[31m-[m
[31m-     本章将学习Spring Data JPA、Spring Data MongoDB、[m
[31m-Spring Data REST、Spring Data Redis。通过对这些Spring Data[m
[31m-项目的学习，并按照Spring Data提供的统一标准，当你有需要[m
[31m-的时候，也会快速掌握Spring Data的其他项目。[m
[31m-8.1　引入Docker[m
[31m-[m
[31m-     大家也许很奇怪为什么本书在此处要引入Docker，Docker[m
[31m-究竟是什么，它能干什么？[m
[31m-[m
[31m-     Docker这两年大受追捧，风光无二。Docker是一个轻量级[m
[31m-容器技术，类似于虚拟机技术（xen、kvm、vmware、[m
[31m-virtual）。Docker是直接运行在当前操作系统（Linux）之上，[m
[31m-而不是运行在虚拟机中，但是也实现了虚拟机技术的资源隔[m
[31m-离，性能远远高于虚拟机技术。[m
[31m-[m
[31m-     Docker支持将软件编译成一个镜像（image），在这个镜像[m
[31m-里做好对软件的各种配置，然后发布这个镜像，使用者可以运[m
[31m-行这个镜像，运行中的镜像称之为容器（container），容器的[m
[31m-启动是非常快的，一般都是以秒为单位。这个有点像我们平时[m
[31m-安装ghost操作系统？系统安装好后软件都有了，虽然完全不[m
[31m-是一种东西，但是思路是类似的。[m
[31m-[m
[31m-     目前各大主流云计算平台都支持Docker容器技术，包括阿[m
[31m-里云、百度云平台（资源隔离通过Docker实现）、Cloud[m
[31m-Foundry（和Spring一家公司的，目前最成熟也最稳定）、[m
[31m-HeroKu、DigitalOcean、OpenShift（JBoss的）、Apache[m
[31m-Stratos、Apache MesOS（批处理平台，支持搭建基于Docker的[m
[31m-云平台）、Deis（开源PaaS平台）；连微软也会在下一个版本[m
[31m-的Windows Server及其云平台Azure上支持Docker，这样看来[m
[31m-Docker大有统一云计算的趋势。[m
[31m-[m
[31m-     这里的云计算平台一般指的是PaaS（平台即服务），它是[m
[31m-一个这样的云计算：平台提供了存储、数据库、网络、负载均[m
[31m-衡、自动扩展等功能，你只需将你的程序交给云计算平台就可[m
[31m-以了。你的程序可以是用不同的编程语言开发的，而使用的[m
[31m-Docker的云计算平台就是用Docker来实现以上功能及不同程序[m
[31m-之间的隔离的。[m
[31m-[m
[31m-     目前主流的软件以及非主流的软件大部分都有人将其封装[m
[31m-成Docker镜像，我们只需下载Docker镜像，然后运行镜像就可[m
[31m-以快速获得已做好配置可运行的软件。[m
[31m-[m
[31m-     从本章开始，我们的数据库将使用Oracle XE、需安装[m
[31m-Redis作为缓存和NoSQL数据库的演示、需安装MongoDB进行[m
[31m-NoSQL数据库演示。[m
[31m-[m
[31m-     在第9章需要安装ActiveMQ以及RabbitMQ进行异步消息的[m
[31m-演示。在第10章我们会演示基于Docker的Spring Boot的部署。[m
[31m-使用Docker后我们将不用手动下载、安装和配置这些软件。[m
[31m-[m
[31m-     另外要特别指出的是，Docker并不是为开发测试方便而提[m
[31m-供的小工具，而是可以用于实际生产环境的一种极好的部署方[m
[31m-式。[m
[31m-[m
[31m-     当然，如果你觉得目前没有迫切学习Docker的必要，可以[m
[31m-略过此节，并自行下载安装本书示例中所需要的软件，不过这[m
[31m-么简单易用的技术还是强烈建议学习一下。[m
[31m-[m
[31m-     当然，本书中涉及的Docker内容主要是为了方便我们开发[m
[31m-测试所需安装的软件，不会涉及Docker所有的内容，当然也不[m
[31m-失于学习Docker入门的好材料。通过学习本书的Docker内容，[m
[31m-可以快速入门Docker，然后按照自己的需求看是否需要继续深[m
[31m-入学习。[m
[31m-[m
[31m-8.1.1　Docker的安装[m
[31m-     因为Docker的运行原理是基于Linux的，所以Docker只能在[m
[31m-Linux下运行。不要紧张，这只能说明在真正的生产环节下，[m
[31m-基于Docker的部署只能在Linux上，但是我们在开发测试的时[m
[31m-候，Docker是可以在Windows以及Mac OS X系统下的，运行的[m
[31m-原理是启动一个VirtualBox虚拟机，在此虚拟机里运行[m
[31m-Docker。[m
[31m-[m
[31m-     1.Linux下安装[m
[31m-[m
[31m-     CentOS安装命令：[m
[31m-[m
[31m-       sudo yum update[m
[31m-       sudo yum install docker[m
[31m-[m
[31m-     Ubuntu：[m
[31m-[m
[31m-       sudo apt-get update[m
[31m-       sudo apt-get docker.io[m
[31m-[m
[31m-     2.Windows下安装[m
[31m-[m
[31m-     Windows下运行Docker是通过这个Boot2Docker这个软件来[m
[31m-实现的，这个软件包含了一个VirtualBox。在Windows下的[m
[31m-Docker只适合于开发测试，不适合于生产环境。[m
[31m-[m
[31m-     Boot2Docker下载地址：[m
[31m-https://github.com/boot2docker/windows-installer/releases/latest。[m
[31m-[m
[31m-     因在Windows下运行的Docker是基于VirtualBox虚拟机软[m
[31m-件，因此在安装前请确认电脑的BIOS设置中的CPU虚拟化技[m
[31m-术支持已经开启。[m
[31m-     在我们目前测试的版本（1.7.0）中，Boot2Docker暂时不支[m
[31m-持Windows 10系统。[m
[31m-[m
[31m-     双击docker-install.exe开始安装，如图8-1所示。[m
[31m-[m
[31m-                                    图8-1　开始安装[m
[31m-[m
[31m-     选择完整安装，其中，MSYS-git UNIX tools是在Windows[m
[31m-下运行UNIX（Linux）命令的工具，如图8-2所示。[m
[31m-                                    图8-2　完整安装[m
[31m-[m
[31m-     勾选“Reboot Windows at end of installation（选择安装完成[m
[31m-后重启电脑）”选项，如图8-3所示。[m
[31m-[m
[31m-图8-3　勾选“Reboot Windows at the end of installation（安装完成后重启[m
[31m-                                       电脑）选项[m
[31m-     安装“通用串行总线控制器”，如图8-4所示。[m
[31m-[m
[31m-                         图8-4　安装“通用串行总控制器”[m
[31m-[m
[31m-     安装完成后，自动重启电脑。启动Docker，选择桌面图标[m
[31m-Boot2Docker Start，如图8-5所示。[m
[31m-[m
[31m-                        图8-5　桌面图标Boot2Docker Start[m
[31m-[m
[31m-     安装成功验证，输入下面命令验证Docker版本，如图8-6所[m
[31m-示。[m
[31m-       docker -v[m
[31m-[m
[31m-                               图8-6　验证Docker版本[m
[31m-[m
[31m-     此时VirtualBox运行了一个虚拟机。打开VirtualBox软件，[m
[31m-如图8-7所示。[m
[31m-                                图8-7　VirtualBox软件[m
[31m-[m
[31m-8.1.2　Docker常用命令及参数[m
[31m-[m
[31m-     1.Docker镜像命令[m
[31m-     基于Docker镜像是可以自己编译的，我们将在10.3节讲解[m
[31m-如何编译自己的Docker镜像，本节我们讲述与Docker镜像操作[m
[31m-相关的命令。[m
[31m-[m
[31m-     通常情况下，Docker的镜像都放置在Docker官网的Docker[m
[31m-Hub上，地址是https://registry.hub.docker.com，如图8-8所示。[m
[31m-                                  图8-8　Docker Hub[m
[31m-[m
[31m-     （1）Docker镜像检索[m
[31m-     除了可以在https://registry.hub.docker.com网站检索镜像以[m
[31m-外，还可以用下面命令检索：[m
[31m-[m
[31m-       docker search 镜像名[m
[31m-[m
[31m-     检索Redis，输入：[m
[31m-[m
[31m-       docker search redis[m
[31m-[m
[31m-     （2）镜像下载[m
[31m-     下载镜像通过下面命令实现：[m
[31m-       docker pull 镜像名[m
[31m-[m
[31m-     下载Redis镜像，运行：[m
[31m-[m
[31m-       docker pull redis[m
[31m-[m
[31m-     这根据据网络情况可能要花费一段时间。[m
[31m-     （3）镜像列表[m
[31m-     查看本地镜像列表，如图8-9所示，通过下面命令：[m
[31m-[m
[31m-       docker images[m
[31m-[m
[31m-                                    图8-9　镜像列表[m
[31m-[m
[31m-     其中REPOSITORY是镜像名；TAG是软件版本，latest为最[m
[31m-新版；IMAGE ID是当前镜像的唯一标识；CREATED是当前[m
[31m-镜像创建时间；VIRTUAL SIZE是当前镜像的大小。[m
[31m-[m
[31m-     （4）镜像删除[m
[31m-     删除指定镜像通过下面命令：[m
[31m-[m
[31m-       docker rmi image-id[m
[31m-     删除所有镜像通过下面命令：[m
[31m-[m
[31m-       docker rmi $(docker images -q)[m
[31m-[m
[31m-     2.Docker容器命令[m
[31m-     （1）容器基本操作[m
[31m-     最简单的运行镜像为容器的命令如下：[m
[31m-[m
[31m-       docker run --name container-name -d image-name[m
[31m-[m
[31m-     运行一个容器只要通过Docker run命令即可实现，其中，--[m
[31m-name参数是为容器取得名称；-d表示detached，意味着执行完[m
[31m-这句命令后控制台将不会被阻碍，可继续输入命令操作；最后[m
[31m-的image-name是要使用哪个镜像来运行容器。[m
[31m-[m
[31m-     我们来运行一个Redis容器：[m
[31m-[m
[31m-       docker run --name test-redis -d redis[m
[31m-[m
[31m-     Docker会为我们的容器生成唯一的标识。[m
[31m-     （2）容器列表[m
[31m-     通过下面命令，查看运行中的容器列表，如图8-10所示。[m
[31m-[m
[31m-       docker ps[m
[31m-                                   图8-10　容器列表[m
[31m-[m
[31m-     其中CONTAINER ID是在启动的时候生成的ID；IMAGE[m
[31m-是该容器使用的镜像；COMMAND是容器启动时调用的命[m
[31m-令；CREATED是容器创建时间；STATUS是当前容器的状[m
[31m-态；PORTS是容器系统所使用的端口号，Redis默认使用6379[m
[31m-端口；NAMES是刚才给容器定义的名称。[m
[31m-[m
[31m-     通过下列命令可查看运行和停止状态的容器：[m
[31m-[m
[31m-       docker ps -a[m
[31m-[m
[31m-     （3）停止和启动容器[m
[31m-     1）停止容器[m
[31m-     停止容器通过下面的命令：[m
[31m-[m
[31m-       docker stop container-name/container-id[m
[31m-[m
[31m-     我们可以通过容器名称或者容器id来停止容器，以停止上[m
[31m-面的Redis容器为例：[m
[31m-[m
[31m-       docker stop test-redis[m
[31m-     此时运行中的容器列表为空。查看所有容器命令，可看出[m
[31m-此时的STATUS为退出。[m
[31m-[m
[31m-     2）启动容器[m
[31m-     启动容器通过下面命令：[m
[31m-[m
[31m-       docker start container-name/container-id[m
[31m-[m
[31m-     再次启动我们刚才停止的容器：[m
[31m-[m
[31m-       docker start test-redis[m
[31m-[m
[31m-     此时查看容器列表如图8-11所示。[m
[31m-[m
[31m-                           图8-11　启动刚才停止的容器[m
[31m-[m
[31m-     3）端口映射[m
[31m-     Docker容器中运行的软件所使用的端口，在本机和本机的[m
[31m-局域网是不能访问的，所以我们需要将Docker容器中的端口映[m
[31m-射到当前主机的端口上，这样我们在本机和本机所在的局域网[m
[31m-就能够访问该软件了。[m
[31m-     Docker的端口映射是通过一个-p参数来实现的。我们以刚[m
[31m-才的Redis为例，映射容器的6379端口到本机的6378端口，命[m
[31m-令如下：[m
[31m-       docker run -d -p 6378:6379 --name port-redis redis[m
[31m-[m
[31m-     目前在Windows下运行的Docker其实是运行在VirtualBox虚[m
[31m-拟机中的，即我们当前的本机并不是我们当前的开发机器，而[m
[31m-是VirtualBox虚拟机，所以我们还需要再做一次端口映射，将[m
[31m-VirtualBox虚拟的端口映射到当前的开发机器。这部分内容将[m
[31m-在实际部署软件的时候进行演示。[m
[31m-[m
[31m-     4）删除容器[m
[31m-     删除单个容器，可通过下面的命令：[m
[31m-[m
[31m-       docker rm container-id[m
[31m-[m
[31m-     删除所有容器，可通过下面的命令：[m
[31m-[m
[31m-       docker rm $(docker ps -a -q)[m
[31m-[m
[31m-     5）容器日志[m
[31m-     查看当前容器日志，可通过下面的命令：[m
[31m-[m
[31m-       docker logs container-name/container-id[m
[31m-[m
[31m-     我们查看下上面一个容器的日志，如图8-12所示，命令如[m
[31m-下：[m
[31m-       docker logs port-redis[m
[31m-[m
[31m-                                 图8-12　容器的日志[m
[31m-[m
[31m-     6）登录容器[m
[31m-     运行中的容器其实是一个功能完备的Linux操作系统，所以[m
[31m-我们可以像常规的系统一样登录并访问容器。[m
[31m-     我们可以使用下面命令，登录访问当前容器，登录后我们[m
[31m-可以在容器中进行常规的Linux系统操作命令，还可以使用exit[m
[31m-命令退出登录。[m
[31m-[m
[31m-       docker exec -it container-id/container-name bash[m
[31m-[m
[31m-8.1.3　下载本书所需的Docker镜像[m
[31m-[m
[31m-     有些需要下载的镜像还是比较大的，所以在此处先下载下[m
[31m-来，以备后面使用。[m
[31m-     Oracle xe、MongoDB、Redis、和ActiveMQRabbit MQ以及[m
[31m-带有管理界面的RabbitMQ的镜像分别如下：RabbitMQ以及带[m
[31m-有管理界面的RabbitMQ：[m
[31m-[m
[31m-       docker pull wnameless/oracle-xe-11g[m
[31m-       docker pull mongo[m
[31m-       docker pull redis:2.8.21[m
[31m-       docker pull cloudesire/activemq[m
[31m-       docker pull rabbitmq[m
[31m-       docker pull rabbitmq:3-management[m
[31m-[m
[31m-     下载完成后，查看Docker镜像列表，如8-13所示。[m
[31m-[m
[31m-                              图8-13　Docker镜像列表[m
[31m-[m
[31m-8.1.4　异常处理[m
[31m-[m
[31m-     若出现命令不能执行的错误，则直接使用下面命令登录[m
[31m-VirtualBox虚拟机执行命令：[m
[31m-[m
[31m-       boot2docker ssh[m
[31m-[m
[31m-     在登录虚拟机后，再执行常规命令，如图8-14所示。[m
[31m-图8-14　登录虚拟机[m
[31m-8.2　Spring Data JPA[m
[31m-[m
[31m-8.2.1　点睛Spring Data JPA[m
[31m-[m
[31m-     1.什么是Spring Data JPA[m
[31m-[m
[31m-     在介绍Spring Data JPA的时候，我们首先认识下[m
[31m-Hibernate。Hibernate是数据访问解决技术的绝对霸主，使用[m
[31m-O/R映射（Object-Relational Mapping）技术实现数据访问，[m
[31m-O/R映射即将领域模型类和数据库的表进行映射，通过程序操[m
[31m-作对象而实现表数据操作的能力，让数据访问操作无须关注数[m
[31m-据库相关的技术。[m
[31m-[m
[31m-     随着Hibernate的盛行，Hibernate主导了EJB 3.0的JPA规[m
[31m-范，JPA即Java Persistence API。JPA是一个基于O/R映射的标[m
[31m-准规范（目前最新版本是JPA 2.1）。所谓规范即只定义标准[m
[31m-规则（如注解、接口），不提供实现，软件提供商可以按照标[m
[31m-准规范来实现，而使用者只需按照规范中定义的方式来使用，[m
[31m-而不用和软件提供商的实现打交道。JPA的主要实现由[m
[31m-Hibernate、EclipseLink和OpenJPA等，这也意味着我们只要使[m
[31m-用JPA来开发，无论是哪一个开发方式都是一样的。[m
[31m-[m
[31m-     Spring Data JPA是Spring Data的一个子项目，它通过提供[m
[31m-基于JPA的Repository极大地减少了JPA作为数据访问方案的代[m
[31m-码量。[m
[31m-[m
[31m-     2.定义数据访问层[m
[31m-[m
[31m-     使用Spring Data JPA建立数据访问层十分简单，只需定义[m
[31m-一个继承JpaRepository的接口即可，定义如下：[m
[31m-[m
[31m-       public interface PersonRepository extends JpaRepository<Person, Long> {[m
[31m-              //定义数据访问操作的方法[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     继承JpaRepository接口意味着我们默认已经有了下面的数[m
[31m-据访问操作方法：[m
[31m-[m
[31m-       @NoRepositoryBean[m
[31m-       public interface JpaRepository<T, ID extends Serializable> extends Pagi[m
[31m-[m
[31m-              List<T> findAll();[m
[31m-              List<T> findAll(Sort sort);[m
[31m-              List<T> findAll(Iterable<ID> ids);[m
[31m-              <S extends T> List<S> save(Iterable<S> entities);[m
[31m-              void flush();[m
[31m-              <S extends T> S saveAndFlush(S entity);[m
[31m-              void deleteInBatch(Iterable<T> entities);[m
[31m-              void deleteAllInBatch();[m
[31m-              T getOne(ID id);[m
[31m-       }[m
[31m-[m
[31m-     3.配置使用Spring Data JPA[m
[31m-[m
[31m-     在Spring环境中，使用Spring Data JPA可通过[m
[31m-@EnableJpaRepositories注解来开启Spring Data JPA的支持，[m
[31m-@EnableJpaRepositories接收的value参数用来扫描数据访问层[m
[31m-所在包下的数据访问的接口定义。[m
[31m-[m
[31m-       @Configuration[m
[31m-       @EnableJpaRepositories("com.wisely.repos")[m
[31m-       public class JpaConfiguration {[m
[31m-[m
[31m-              @Bean[m
[31m-              public EntityManagerFactory entityManagerFactory() {[m
[31m-[m
[31m-                      //...[m
[31m-              }[m
[31m-                  //还需配置DataSource、PlatformTransactionManager等相关必须[m
[31m-[m
[31m-       bean[m
[31m-       }[m
[31m-[m
[31m-     4.定义查询方法[m
[31m-[m
[31m-     在讲解查询方法前，假设我们有一张数据表叫PERSON，[m
[31m-有ID（Number）、NAME（Varchar2）、AGE（Number）、[m
[31m-ADDRESS（Varchar2）几个字段；对应的实体类叫Person，分[m
[31m-别有id（Long）、name（String）、age（Integer）、[m
[31m-address（String）。下面我们就以这个简单的实体查询作为演[m
[31m-示。[m
[31m-[m
[31m-     （1）根据属性名查询[m
[31m-[m
[31m-     Spring Data JPA支持通过定义在Repository接口中的方法名[m
[31m-来定义查询，而方法名是根据实体类的属性名来确定的。[m
[31m-[m
[31m-     1）常规查询。根据属性名来定义查询方法，示例如下：[m
[31m-[m
[31m-       public interface PersonRepository extends JpaRepository<Person, Long> {[m
[31m-              /**[m
[31m-                *[m
[31m-                * 通过名字相等查询，参数为name[m
[31m-                * 相当于JPQL:select p from Person p where p.name=?1[m
[31m-                */[m
[31m-              List<Person> findByName(String name);[m
[31m-              /**[m
[31m-                *[m
[31m-                * 通过名字like查询，参数为name[m
[31m-                 * 相当于JPQL：select p from Person p where p.name like ?[m
[31m-[m
[31m-       1[m
[31m-                */[m
[31m-[m
[31m-              List<Person> findByNameLike(String name);[m
[31m-              /**[m
[31m-[m
[31m-                *[m
[31m-                * 通过名字和地址查询,参数为name和address[m
[31m-                     * 相当于JPQL：select p from Person p where p.name=?[m
[31m-       1 and p.address=?2[m
[31m-[m
[31m-                */[m
[31m-              List<Person> findByNameAndAddress(String name,String address);[m
[31m-       }[m
[31m-[m
[31m-     从代码可以看出，这里使用了findBy、Like、And这样的关[m
[31m-键字。其中findBy可以用find、read、readBy、query、[m
[31m-queryBy、get、getBy来代替。[m
[31m-[m
[31m-     而Like和and这类查询关键字，如表8-2所示：[m
[31m-[m
[31m-                                  表8-2　查询关键字[m
[31m-[m
[31m-     2）限制结果数量。结果数量是用top和first关键字来实现[m
[31m-的，例如：[m
[31m-[m
[31m-       public interface PersonRepository extends JpaRepository<Person, Long> {[m
[31m-              /**[m
[31m-                *[m
[31m-                * 获得符合查询条件的前10条数据[m
[31m-                *[m
[31m-                */[m
[31m-[m
[31m-              List<Person> findFirst10ByName(String name);[m
[31m-[m
[31m-              /**[m
[31m-                *[m
[31m-                * 获得符合查询条件的前30条数据[m
[31m-                *[m
[31m-                */[m
[31m-[m
[31m-              List<Person> findTop30ByName(String name);[m
[31m-       }[m
[31m-[m
[31m-     （2）使用JPA的NamedQuery查询[m
[31m-[m
[31m-     Spring Data JPA支持用JPA的NameQuery来定义查询方法，[m
[31m-即一个名称映射一个查询语句。定义如下：[m
[31m-[m
[31m-       @Entity[m
[31m-       @NamedQuery(name = "Person.findByName",[m
[31m-[m
[31m-              query = "select p from Person p where p.name=?1")[m
[31m-       public class Person {[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     使用如下语句：[m
[31m-[m
[31m-       public interface PersonRepository extends JpaRepository<Person, Long> {[m
[31m-              /**[m
[31m-                *[m
[31m-                 * 这时我们使用的是NamedQuery里定义的查询语句，而不是根据方法名称[m
[31m-[m
[31m-       查询[m
[31m-                *[m
[31m-                */[m
[31m-[m
[31m-              List<Person> findByName(String name);[m
[31m-       }[m
[31m-[m
[31m-     （3）使用@Query查询[m
[31m-     1）使用参数索引。Spring Data JPA还支持用@Query注解[m
[31m-在接口的方法上实现查询，例如：[m
[31m-[m
[31m-       public interface PersonRepository extends JpaRepository<Person, Long> {[m
[31m-              @Query("select p from Person p where p.address=?1")[m
[31m-              List<Person> findByAddress(String address);[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     2）使用命名参数。上面的例子是使用参数的索引号来查[m
[31m-询的，在Spring Data JPA里还支持在语句里用名称来匹配查询[m
[31m-参数，例如：[m
[31m-[m
[31m-       public interface PersonRepository extends JpaRepository<Person, Long> {[m
[31m-              @Query("select p from Person p where p.address= :address")[m
[31m-              List<Person> findByAddress(@Param("address") String address);[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     3）更新查询。Spring Data JPA支持@Modifying和@Query[m
[31m-注解组合来事件更新查询，例如：[m
[31m-[m
[31m-       public interface PersonRepository extends JpaRepository<Person, Long> {[m
[31m-              @Modifying[m
[31m-[m
[31m-       @Transactional[m
[31m-              @Query("update Person p set p.name=?1")[m
[31m-              int setName(String name);[m
[31m-[m
[31m-       }[m
[31m-     其中返回值int表示更新语句影响的行数。[m
[31m-[m
[31m-     （4）Specification[m
[31m-[m
[31m-     JPA提供了基于准则查询的方式，即Criteria查询。而Spring[m
[31m-Data JPA提供了一个Specification（规范）接口让我们可以更方[m
[31m-便地构造准则查询，Specification接口定义了一个toPredicate方[m
[31m-法用来构造查询条件。[m
[31m-[m
[31m-     1）定义。我们的接口类必需实现JpaSpecificationExecutor[m
[31m-接口，代码如下：[m
[31m-[m
[31m-       public interface PersonRepository extends JpaRepository<Person, Long>,[m
[31m-                                                                                       JpaSpecificationExecutor<Pe[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     然后需要定义Criterial查询，代码如下：[m
[31m-[m
[31m-       import javax.persistence.criteria.CriteriaBuilder;[m
[31m-       import javax.persistence.criteria.CriteriaQuery;[m
[31m-       import javax.persistence.criteria.Predicate;[m
[31m-       import javax.persistence.criteria.Root;[m
[31m-[m
[31m-       import org.springframework.data.jpa.domain.Specification;[m
[31m-[m
[31m-       import com.wisely.domain.Person;[m
[31m-[m
[31m-       public class CustomerSpecs {[m
[31m-[m
[31m-              public static Specification<Person> personFromHefei() {[m
[31m-                      return new Specification<Person>() {[m
[31m-[m
[31m-                             @Override[m
[31m-                             public Predicate toPredicate(Root<Person> root, CriteriaQue[m
[31m-       > query, CriteriaBuilder cb) {[m
[31m-[m
[31m-                                            return cb.equal(root.get("address"), "合[m
[31m-肥");             }[m
[31m-          };[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-     我们使用Root来获得需要查询的属性，通过CriteriaBuilder[m
[31m-构造查询条件，本例的含义是查出所有来自合肥的人。[m
[31m-[m
[31m-     注意：CriteriaBuilder、CriteriaQuery、Predicate、Root都是[m
[31m-来自JPA的接口。[m
[31m-[m
[31m-     CriteriaBuilder包含的条件构造有：exists、and、or、not、[m
[31m-conjunction、disjunction、isTrue、isFalse、isNull、isNotNull、[m
[31m-equal、notEqual、greaterThan、greaterThanOrEqualTo、[m
[31m-lessThan、lessThanOrEqualTo、between等，详细请查看[m
[31m-CriteriaBuilder的API。[m
[31m-[m
[31m-     2）使用。静态导入：[m
[31m-[m
[31m-       import static com.wisely.specs.CustomerSpecs.*;[m
[31m-[m
[31m-注入personRepository的Bean后：[m
[31m-[m
[31m-List<Person> people = personRepository.findAll(personFromHefei());[m
[31m-[m
[31m-（5）排序与分页[m
[31m-Spring Data JPA充分考虑了在实际开发中所必需的排序和[m
[31m-分页的场景，为我们提供了Sort类以及Page接口和Pageable接[m
[31m-口。[m
[31m-[m
[31m-     1）定义：[m
[31m-[m
[31m-       package com.wisely.repos;[m
[31m-       import java.util.List;[m
[31m-       import org.springframework.data.domain.Page;[m
[31m-       import org.springframework.data.domain.Pageable;[m
[31m-       import org.springframework.data.domain.Sort;[m
[31m-       import org.springframework.data.jpa.repository.JpaRepository;[m
[31m-       import org.springframework.data.jpa.repository.Modifying;[m
[31m-       import org.springframework.data.jpa.repository.Query;[m
[31m-       import org.springframework.data.repository.query.Param;[m
[31m-       import com.wisely.domain.Person;[m
[31m-       public interface PersonRepository extends JpaRepository<Person, Long> {[m
[31m-[m
[31m-              List<Person> findByName(String name,Sort sort);[m
[31m-              Page<Person> findByName(String name,Pageable pageable);[m
[31m-       }[m
[31m-[m
[31m-     2）使用排序：[m
[31m-[m
[31m-       List<Person> people = personRepository.findByName("xx", new Sort(Direct[m
[31m-[m
[31m-     3）使用分页：[m
[31m-[m
[31m-       Page<Person> people2 = personRepository.findByName("xx", new PageReques[m
[31m-[m
[31m-     其中Page接口可以获得当前页面的记录、总页数、总记录[m
[31m-数、是否有上一页或下一页等。[m
[31m-[m
[31m-5.自定义Repository的实现[m
[31m-[m
[31m-Spring              Data提供了和CrudRepository、[m
[31m-[m
[31m-PagingAndSortingRepository；Spring Data JPA也提供了[m
[31m-[m
[31m-JpaRepository。如果我们想把自己常用的数据库操作封装起[m
[31m-[m
[31m-来，像JpaRepository一样提供给我们领域类的Repository接口使[m
[31m-[m
[31m-用，应该怎么操做呢？[m
[31m-[m
[31m-（1）定义自定义Repository接口：[m
[31m-[m
[31m-@NoRepositoryBean//1[m
[31m-public interface CustomRepository<T, ID extends Serializable>extends Pa[m
[31m-[m
[31m-       public void doSomething(ID id);//3[m
[31m-[m
[31m-}[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①@NoRepositoryBean指明当前这个接口不是我们领域类[m
[31m-的接口（如PersonRepository。[m
[31m-[m
[31m-     ②我们自定义的Repository实现PagingAndSortingRepository[m
[31m-接口，具备分页和排序的能力。[m
[31m-[m
[31m-     ③要定义的数据操作方法在接口中的定义。[m
[31m-[m
[31m-     （2）定义接口实现：[m
[31m-[m
[31m-       public class CustomRepositoryImpl <T, ID extends Serializable>[m
[31m-                                           extends SimpleJpaRepository<T, ID> implements Cust[m
[31m-              private final EntityManager entityManager;//2[m
[31m-[m
[31m-              public CustomRepositoryImpl(Class<T> domainClass, EntityManager ent[m
[31m-                      super(domainClass, entityManager);[m
[31m-                      this.entityManager = entityManager;[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              @Override[m
[31m-              public void doSomething(ID id) {[m
[31m-[m
[31m-                      // 4[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①首先要实现CustomRepository接口，继承[m
[31m-SimpleJpaRepository类让我们可以使用其提供的方法（如[m
[31m-findAll）。[m
[31m-[m
[31m-     ②让数据操作方法中可以使用entityManager。[m
[31m-[m
[31m-     ③CustomRepositoryImpl的构造函数，需当前处理的领域类[m
[31m-类型和entityManager作为构造参数，在这里也给我们的[m
[31m-entityManager赋值了。[m
[31m-[m
[31m-     ④在此处定义数据访问操作，如调用findAll方法并构造一[m
[31m-些查询条件。[m
[31m-[m
[31m-     （3）自定义RepositoryFactoryBean。自定义[m
[31m-JpaRepositoryFactoryBean替代默认RepositoryFactoryBean，我[m
[31m-们会获得一个RepositoryFactory，RepositoryFactory将会注册我[m
[31m-们自定义的Repository的实现：[m
[31m-[m
[31m-       public class CustomRepositoryFactoryBean<T extends JpaRepository<S, ID>[m
[31m-          extends JpaRepositoryFactoryBean<T, S, ID> {// 1[m
[31m-[m
[31m-   @Override[m
[31m-   protected RepositoryFactorySupport createRepositoryFactory(EntityMa[m
[31m-[m
[31m-          return new CustomRepositoryFactory(entityManager);[m
[31m-   }[m
[31m-[m
[31m-   private static class CustomRepositoryFactory extends JpaRepositoryF[m
[31m-[m
[31m-      public CustomRepositoryFactory(EntityManager entityManager) {[m
[31m-             super(entityManager);[m
[31m-[m
[31m-      }[m
[31m-[m
[31m-              @Override[m
[31m-              @SuppressWarnings({"unchecked"})[m
[31m-              protected <T, ID extends Serializable> SimpleJpaRepository<?, ?[m
[31m-> getTargetRepository([m
[31m-[m
[31m-                             RepositoryInformation information, EntityManager entity[m
[31m-                                     return new CustomRepositoryImpl<T, ID>[m
[31m-[m
[31m-((Class<T>) information.getDomainType(), entityManager);[m
[31m-[m
[31m-      }[m
[31m-[m
[31m-      @Override[m
[31m-[m
[31m-                 protected                   Class<?[m
[31m-[m
[31m-> getRepositoryBaseClass(RepositoryMetadata metadata) {// 5[m
[31m-[m
[31m-         return CustomRepositoryImpl.class;[m
[31m-[m
[31m-      }[m
[31m-[m
[31m-   }[m
[31m-[m
[31m-}[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①自定义RepositoryFactoryBean，继承[m
[31m-JpaRepositoryFactoryBean。[m
[31m-[m
[31m-     ②重写createRepositoryFactory方法，用当前的[m
[31m-CustomRepositoryFactory创建实例。[m
[31m-[m
[31m-     ③创建CustomRepositoryFactory，并继承[m
[31m-JpaRepositoryFactory。[m
[31m-[m
[31m-     ④重写getTargetRepository方法，获得当前自定义的[m
[31m-Repository实现。[m
[31m-[m
[31m-     ⑤重写getRepositoryBaseClass，获得当前自定义的[m
[31m-Repository实现的类型。[m
[31m-[m
[31m-     （4）开启自定义支持使用@EnableJpaRepositories的[m
[31m-repositoryFactoryBeanClass来指定FactoryBean即可，代码如[m
[31m-下：[m
[31m-[m
[31m-       @EnableJpaRepositories(repositoryFactoryBeanClass= CustomRepositoryFact[m
[31m-[m
[31m-8.2.2　Spring Boot的支持[m
[31m-[m
[31m-1.JDBC的自动配置[m
[31m-[m
[31m-spring-boot-starter-data-jpa依赖于spring-boot-starter-jdbc，[m
[31m-[m
[31m-而Spring  Boot对JDBC做了一些自动配置。源码放置在[m
[31m-[m
[31m-org.springframework.boot.autoconfigure.jdbc下，如图8-15所示。[m
[31m-        图8-15　JDBC源码位置[m
[31m-[m
[31m-     从源码分析可以看出，我们通过“spring.datasoure”为前缀[m
[31m-的属性自动配置dataSource；Spring Boot自动开启了注解事务[m
[31m-的支持（@EnableTransactionManagement）；还配置了一个[m
[31m-jdbcTemplate。[m
[31m-[m
[31m-     Spring Boot还提供了一个初始化数据的功能：放置在类路[m
[31m-径下的schema.sql文件会自动用来初始化表结构；放置在类路[m
[31m-径下的data.sql文件会自动用来填充表数据。[m
[31m-[m
[31m-2.对JPA的自动配置[m
[31m-[m
[31m-Spring       Boot对JPA的自动配置放置在[m
[31m-[m
[31m-org.springframework.boot.autoconfigure.orm.jpa下，如图8-16所[m
[31m-[m
[31m-示。[m
[31m-           图8-16　JPA的源码位置[m
[31m-[m
[31m-     从HibernateJpaAutoConfiguration可以看出，Spring Boot默[m
[31m-认JPA的实现者是Hibernate；HibernateJpaAutoConfiguration依[m
[31m-赖于DataSourceAutoConfiguration。[m
[31m-[m
[31m-     从JpaProperties的源码可以看出，配置JPA可以使用[m
[31m-spring.jpa为前缀的属性在application.properties中配置。[m
[31m-[m
[31m-     从JpaBaseConfiguration的源码中可以看出，Spring Boot为[m
[31m-我们配置了transactionManager、jpaVendorAdapter、[m
[31m-entityManagerFactory等Bean。JpaBaseConfiguration还有一个[m
[31m-getPackagesToScan方法，可以自动扫描注解有@Entity的实体[m
[31m-类。[m
[31m-[m
[31m-在Web项目中我们经常会遇到在控制器或者页面访问数据[m
[31m-[m
[31m-的时候出现会话连接已关闭的错误，这时候我们会配置一个[m
[31m-[m
[31m-Open EntityManager（Session）In View这个过滤器。令人惊喜[m
[31m-[m
[31m-的是，Spring                Boot为我们自动配置了[m
[31m-[m
[31m-OpenEntityManagerInViewInterceptor这个Bean，并注册到[m
[31m-[m
[31m-Spring MVC的拦截器中。[m
[31m-[m
[31m-3.对Spring Data JPA的自动配置[m
[31m-[m
[31m-     而Spring Boot对Spring Data JPA的自动配置放置在[m
[31m-org.springframework.boot.autoconfigure.data.jpa下，如图8-17所[m
[31m-示。[m
[31m-[m
[31m-                       图8-17　Spring Data JPA的自动配置[m
[31m-[m
[31m-     从JpaRepositoriesAutoConfiguration和[m
[31m-JpaRepositoriesAutoConfigureRegistrar源码可以看出，[m
[31m-JpaRepositoriesAutoConfiguration是依赖于[m
[31m-HibernateJpaAutoConfiguration配置的，且Spring Boot自动开启[m
[31m-了对Spring Data JPA的支持，即我们无须在配置类显示声明[m
[31m-@EnableJpaRepositories。[m
[31m-[m
[31m-     4.Spring Boot下的Spring Data JPA[m
[31m-     通过上面的分析可知，我们在Spring Boot下使用Spring[m
[31m-Data JPA，在项目的Maven依赖里添加spring-boot-stater-data-[m
[31m-jpa，然后只需定义DataSource、实体类和数据访问层，并在需[m
[31m-要使用数据访问的地方注入数据访问层的Bean即可，无须任何[m
[31m-额外配置。[m
[31m-[m
[31m-8.2.3　实战[m
[31m-[m
[31m-     在本节的实战里，我们将演示基于方法名的查询、基于[m
[31m-@Query的查询、分页及排序，最后我们将结合Specification和[m
[31m-自定义Repository实现来完成一个通用实体查询，即对于任意[m
[31m-类型的实体类的传值对象，只要对象有值的属性我们就进行自[m
[31m-动构造查询（字符型用like，其他类型用等于）。这里起一个[m
[31m-抛砖引玉的功能，感兴趣的读者可以继续扩展，如构造范围查[m
[31m-询及关联表查询等。[m
[31m-[m
[31m-1.安装Oracle XE[m
[31m-[m
[31m-     因大部分Java程序员在实际开发中一般使用的是Oracle，[m
[31m-所以此处选择用Oracle XE作为开发测试数据库。[m
[31m-[m
[31m-     Oracle XE是Oracle公司提供的免费开发测试用途的数据[m
[31m-库，可自由使用，功能和使用与Oracle完全一致，但数据大小[m
[31m-限制为4G。[m
[31m-[m
[31m-（1）非Docker安装[m
[31m-[m
[31m-不打算使用Docker安装Oracle  XE的读者请至[m
[31m-[m
[31m-http://www.oracle.com/technetwork/database/database-[m
[31m-technologies/express-edition/downloads/index.html下载Oracle XE[m
[31m-[m
[31m-安装。[m
[31m-[m
[31m-（2）Docker安装[m
[31m-[m
[31m-     我们在8.13节已经下载了Oracle XE的镜像，现在我们运行[m
[31m-启动一个Oracle XE的容器。[m
[31m-[m
[31m-运行命令：[m
[31m-[m
[31m-docker run -d -p 9090:8080 -p 1521:1521 wnameless/oracle-xe-[m
[31m-11g[m
[31m-[m
[31m-     将容器中的Oracle XE管理界面的8080端口映射为本机的[m
[31m-9090端口，将Oracle XE的1521端口映射为本机的1521端口。[m
[31m-[m
[31m-     本容器提供如下的安装信息：[m
[31m-       hostname:localhost[m
[31m-       端口:1521[m
[31m-       SID: XE[m
[31m-       username:system/sys[m
[31m-       password:oracle[m
[31m-[m
[31m-     管理界面访问：[m
[31m-[m
[31m-       url:http://localhost:9090/apex[m
[31m-       workspace:internal[m
[31m-       username:admin[m
[31m-       password:oracle[m
[31m-[m
[31m-     （3）端口映射[m
[31m-[m
[31m-     我们在8.1节曾经提到，容器暴露的端口只是映射到[m
[31m-VirtualBox虚拟机上，而本机要访问容器的话需要我们把[m
[31m-VirtualBox的虚拟机的端口映射到当前开发机器上。这确实有[m
[31m-点麻烦，但是在生产环境我们一般都是基于Linux部署Docker[m
[31m-的，所以不会存在这个问题。[m
[31m-[m
[31m-     下面我们演示将VirtualBox虚拟机的端口映射到当前开发[m
[31m-机器。[m
[31m-[m
[31m-     打开VirtualBox软件，如图8-18所示。[m
[31m-                            图8-18　打开VirtualBox软件[m
[31m-[m
[31m-     选中boot2docker-vm，单击“设置”按钮，或者右击，在右[m
[31m-键菜单中选中“设置”，打开虚拟机设置页面，如图8-19所示。[m
[31m-[m
[31m-                           图8-19　打开虚拟机设置页面[m
[31m-[m
[31m-     单击“网络”，页面下方出现了“端口转发”按钮，如图8-20[m
[31m-所示。[m
[31m-                               图8-20　“端口转发”按钮[m
[31m-[m
[31m-     单击“端品转发”按钮，弹出“端口转发规则”界面，将我们[m
[31m-刚才曝露到虚拟机的9090及1521端口映射为开发机的9090及[m
[31m-1521端口，如图8-21所示。[m
[31m-[m
[31m-                    图8-21　将虚拟机端口映射为开发机端口[m
[31m-[m
[31m-     做了如上设置后，我们即可通过本机9090及1521端口正确[m
[31m-访问Oracle XE容器里的端口了。[m
[31m-[m
[31m-     （4）管理[m
[31m-     通过上面的设置之后，我们就可以像操作普通的Oracle数[m
[31m-据库一样操作Oracle XE了。我们可以通过访问XE的管理界[m
[31m-面：http://localhost：9090/apex登录管理数据库；或者在开发[m
[31m-机器安装Oracle Client，管理并安装一个数据库管理工具（如[m
[31m-PL/SQL Developer）来管理数据库。[m
[31m-[m
[31m-     利用我们的管理工具（如PL/SQL Developer）创建一个用[m
[31m-户，作为我们程序使用的数据库账号，账号密码皆为boot。[m
[31m-[m
[31m-     3.新建Spring Boot项目[m
[31m-[m
[31m-     搭建Spring Boot项目，依赖选择JPA（spring-boot-starter-[m
[31m-data-jpa）和Web（spring-boot-starter-web）。[m
[31m-[m
[31m-     项目信息：[m
[31m-[m
[31m-       groupId：com.wisely[m
[31m-       arctifactId:ch8_2[m
[31m-       package: com.wisely.ch8_2[m
[31m-[m
[31m-     因为我们使用的是Oracle XE数据库，所以需要使用Oracle[m
[31m-的JDBC驱动，而Maven中心库没有Oracle JDBC的驱动下载，[m
[31m-因此我们需要通过Maven命令，自己打包Oracle的JDBC驱动到[m
[31m-本地库。[m
[31m-[m
[31m-     在Oracle官网下载[m
[31m-ojdbc6.jar（http://www.oracle.com/technetwork/database/enterprise-[m
[31m-edition/jdbc-112010-090769.html），当然一般我们都有这个jar[m
[31m-包。[m
[31m-[m
[31m-     通过在控制台执行下面命令，将ojdbc6.jar安装到本地库：[m
[31m-mvn install:install-file -DgroupId=com.oracle  "-[m
[31m-                                               "-[m
[31m-DartifactId=ojdbc6"  "-Dversion=11.2.0.2.0"[m
[31m-[m
[31m-Dpackaging=jar" "-Dfile=E:\ojdbc6.jar"[m
[31m-[m
[31m-     说明：[m
[31m-[m
[31m-     -DgroupId=com.oracle：指定当前包的groupId为[m
[31m-com.oracle。[m
[31m-[m
[31m-     -DartifactId=ojdbc6：指定当前包的artifactfactId为ojdbc6。[m
[31m-     -Dversion=11.2.0.2.0：指定当前包version为11.2.0.2.0。[m
[31m-     -Dfile=E：\ojdbc6.jar：指定要打包的jar的文件位置。[m
[31m-     此时ojdbc6被打包到本地库，如图8-22所示。[m
[31m-[m
[31m-                          图8-22　ojdbc6被打包到本地库[m
[31m-[m
[31m-     这时我们只需在Spring Boot项目中的pom.xml加入下面坐[m
[31m-标即可引入ojdbc6：[m
[31m-[m
[31m-                      <dependency>[m
[31m-                             <groupId>com.oracle</groupId>[m
[31m-                             <artifactId>ojdbc6</artifactId>[m
[31m-                             <version>11.2.0.2.0</version>[m
[31m-[m
[31m-                      </dependency>[m
[31m-     添加google guava依赖，它包含大量Java常用的工具类：[m
[31m-[m
[31m-                      <dependency>[m
[31m-                             <groupId>com.google.guava</groupId>[m
[31m-                             <artifactId>guava</artifactId>[m
[31m-                             <version>18.0</version>[m
[31m-[m
[31m-                      </dependency>[m
[31m-[m
[31m-     新建一个data.sql文件放置在src/main/resources下，内容为[m
[31m-向表格增加一些数据，数据插入完成后请删除或对此文件改[m
[31m-名：[m
[31m-[m
[31m-       insert into person(id,name,age,address) values(hibernate_sequence.nextv[m
[31m-       云飞',32,'合肥');[m
[31m-       insert into person(id,name,age,address) values(hibernate_sequence.nextv[m
[31m-       京');[m
[31m-       insert into person(id,name,age,address) values(hibernate_sequence.nextv[m
[31m-[m
[31m-       ',30,'上海');[m
[31m-       insert into person(id,name,age,address) values(hibernate_sequence.nextv[m
[31m-[m
[31m-       ',29,'南京');[m
[31m-       insert into person(id,name,age,address) values(hibernate_sequence.nextv[m
[31m-[m
[31m-       ',28,'武汉');[m
[31m-       insert into person(id,name,age,address) values(hibernate_sequence.nextv[m
[31m-',27,'合肥');[m
[31m-[m
[31m-4.配置基本属性[m
[31m-在application.properties里配置数据源和jpa的相关属性。[m
[31m-[m
[31m-spring.datasource.driverClassName=oracle.jdbc.OracleDriver[m
[31m-spring.datasource.url=jdbc[m
[31m-[m
[31m-\:oracle\:thin\:@localhost[m
[31m-[m
[31m-\:1521\:xe[m
[31m-[m
[31m-spring.datasource.username=boot[m
[31m-spring.datasource.password=boot[m
[31m-#1[m
[31m-spring.jpa.hibernate.ddl-auto=update[m
[31m-#2[m
[31m-spring.jpa.show-sql=true[m
[31m-#3[m
[31m-spring.jackson.serialization.indent_output=true[m
[31m-[m
[31m-代码解释[m
[31m-     上面代码第一段是用来配置数据源，第二段是用来配置[m
[31m-jpa，更多配置内容请查看附录A.3[m
[31m-以“spring.datasource”和“spring.jpa”为前缀的属性配置。[m
[31m-[m
[31m-     ①hibernate提供了根据实体类自动维护数据库表结构的功[m
[31m-能，可通过spring.jpa.hibernate.ddl-auto来配置，有下列可选[m
[31m-项：[m
[31m-[m
[31m-     create：启动时删除上一次生成的表，并根据实体类生成[m
[31m-     表，表中数据会被清空。[m
[31m-     create-drop：启动时根据实体类生成表，sessionFactory关[m
[31m-     闭时表会被删除。[m
[31m-     update：启动时会根据实体类生成表，当实体类属性变动[m
[31m-     的时候，表结构也会更新，在初期开发阶段使用此选项。[m
[31m-     validate：启动时验证实体类和数据表是否一致，在我们数[m
[31m-     据结构稳定时采用此选项。[m
[31m-     none：不采取任何措施。[m
[31m-[m
[31m-     ②spring.jpa.show-sql用来设置hibernate操作的时候在控制[m
[31m-台显示其真实的sql语句。[m
[31m-[m
[31m-     ③让控制器输出的json字符串格式更美观。[m
[31m-[m
[31m-     5.定义映射实体类[m
[31m-[m
[31m-     Hibernate支持自动将实体类映射为数据表格：[m
[31m-[m
[31m-       package com.wisely.domain;[m
[31m-[m
[31m-       import javax.persistence.Entity;[m
[31m-       import javax.persistence.GeneratedValue;[m
[31m-       import javax.persistence.Id;[m
[31m-[m
[31m-       @Entity //1[m
[31m-       @NamedQuery(name = "Person.withNameAndAddressNamedQuery",[m
[31m-       query = "select p from Person p where p.name=?[m
[31m-       1 and address=?2")[m
[31m-       public class Person {[m
[31m-[m
[31m-              @Id //2[m
[31m-              @GeneratedValue //3[m
[31m-              private Long id;[m
[31m-[m
[31m-              private String name;[m
[31m-[m
[31m-              private Integer age;[m
[31m-[m
[31m-              private String address;[m
[31m-[m
[31m-              public Person() {[m
[31m-                      super();[m
[31m-[m
[31m-              }[m
[31m-              public Person(Long id, String name, Integer age, String address) {[m
[31m-[m
[31m-                      super();[m
[31m-                      this.id = id;[m
[31m-                      this.name = name;[m
[31m-                      this.age = age;[m
[31m-                      this.address = address;[m
[31m-              }[m
[31m-[m
[31m-              // 省略setter、getter[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①@Entity注解指明这是一个和数据库表映射的实体类。[m
[31m-[m
[31m-     ②@Id注解指明这个属性映射为数据库的主键。[m
[31m-[m
[31m-     ③@GeneratedValue注解默认使用主键生成方式为自增，[m
[31m-hibernate会为我们自动生成一个名为HIBERNATE_SEQUENCE[m
[31m-的序列。[m
[31m-[m
[31m-     在此例中使用的注解也许和你平时经常使用的注解实体类[m
[31m-不大一样，比如没有使用@Table（实体类映射表名）、[m
[31m-@Column（属性映射字段名）注解。这是因为我们是采用正[m
[31m-向工程通过实体类生成表结构，而不是通过逆向工程从表结构[m
[31m-生成数据库。[m
[31m-[m
[31m-     在这里你可能注意到，我们没有通过@Column注解来注解[m
[31m-普通属性，@Column是用来映射属性名和字段名，不注解的[m
[31m-时候hibernate会自动根据属性名生成数据表的字段名。如属性[m
[31m-名name映射成字段NAME；多字母属性如testName会自动映射[m
[31m-为TEST_NAME。表名的映射规则也如此。[m
[31m-[m
[31m-     6.定义数据访问接口[m
[31m-[m
[31m-       package com.wisely.dao;[m
[31m-[m
[31m-       import java.util.List;[m
[31m-[m
[31m-       import org.springframework.data.jpa.repository.JpaRepository;[m
[31m-       import org.springframework.data.jpa.repository.Query;[m
[31m-[m
[31m-       import com.wisely.domain.Person;[m
[31m-[m
[31m-       public interface PersonRepository extends JpaRepository<Person, Long> {[m
[31m-              //1[m
[31m-              List<Person> findByAddress(String name);[m
[31m-              //2[m
[31m-              Person findByNameAndAddress(String name,String address);[m
[31m-              //3[m
[31m-              @Query("select p from Person p where p.name= :name and p.address= :[m
[31m-              Person withNameAndAddressQuery(@Param("name")String name,[m
[31m-                                                                                         @Param("address")String ad[m
[31m-              //4[m
[31m-              List<Person> withNameAndAddressNamedQuery(String name,String addres[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①使用方法名查询，接受一个name参数，返回值为列表。[m
[31m-     ②使用方法名查询，接受name和address，返回值为单个对[m
[31m-象。[m
[31m-[m
[31m-     ③使用@Query查询，参数按照名称绑定。[m
[31m-[m
[31m-     ④使用@NamedQuery查询，请注意我们在实体类中做的[m
[31m-@NamedQuery的定义。[m
[31m-[m
[31m-     7.运行[m
[31m-[m
[31m-     在本例中没有复杂的业务逻辑，我们将PersonRepository注[m
[31m-入到控制器中，以简化演示。[m
[31m-[m
[31m-       package com.wisely.web;[m
[31m-[m
[31m-       import java.util.List;[m
[31m-[m
[31m-       import org.springframework.beans.factory.annotation.Autowired;[m
[31m-       import org.springframework.data.domain.Page;[m
[31m-       import org.springframework.data.domain.PageRequest;[m
[31m-       import org.springframework.data.domain.Sort;[m
[31m-       import org.springframework.data.domain.Sort.Direction;[m
[31m-       import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-       import org.springframework.web.bind.annotation.RestController;[m
[31m-[m
[31m-       import com.wisely.dao.PersonRepository;[m
[31m-       import com.wisely.domain.Person;[m
[31m-[m
[31m-       @RestController[m
[31m-       public class DataController {[m
[31m-[m
[31m-              //1 Spring Data JPA已自动为你注册bean，所以可自动注入[m
[31m-              @Autowired[m
[31m-              PersonRepository personRepository;[m
[31m-              /**[m
[31m-[m
[31m-                * 保存[m
[31m-                * save支持批量保存：<S extends T> Iterable[m
[31m-[m
[31m-       <S> save(Iterable[m
[31m-<S> entities);[m
[31m-         *[m
[31m-         * 删除：[m
[31m-         *支持使用id删除对象、批量删除以及删除全部：[m
[31m-         * void delete(ID id);[m
[31m-         * void delete(T entity);[m
[31m-         * void delete(Iterable[m
[31m-[m
[31m-<? extends T> entities);[m
[31m-         * void deleteAll();[m
[31m-         *[m
[31m-         */[m
[31m-[m
[31m-       @RequestMapping("/save")[m
[31m-       public Person save(String name,String address,Integer age)[m
[31m-{[m
[31m-[m
[31m-              Person p = personRepository.save(new Person(null, name, age, ad[m
[31m-[m
[31m-              return p;[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-       /**[m
[31m-         * 测试findByAddress[m
[31m-         */[m
[31m-[m
[31m-       @RequestMapping("/q1")[m
[31m-       public List<Person> q1(String address){[m
[31m-[m
[31m-              List<Person> people = personRepository.findByAddress(address);[m
[31m-[m
[31m-              return people;[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-       /**[m
[31m-         * 测试findByNameAndAddress[m
[31m-         */[m
[31m-[m
[31m-       @RequestMapping("/q2")[m
[31m-       public Person q2(String name,String address){[m
[31m-       Person people = personRepository.findByNameAndAddress(name, add[m
[31m-[m
[31m-       return people;[m
[31m-[m
[31m-}[m
[31m-[m
[31m-/**[m
[31m- * 测试withNameAndAddressQuery[m
[31m- */[m
[31m-[m
[31m-@RequestMapping("/q3")[m
[31m-public Person q3(String name,String address){[m
[31m-[m
[31m-       Person p = personRepository.withNameAndAddressQuery(name, addre[m
[31m-[m
[31m-       return p;[m
[31m-[m
[31m-}[m
[31m-[m
[31m-/**[m
[31m- * 测试withNameAndAddressNamedQuery[m
[31m- */[m
[31m-[m
[31m-@RequestMapping("/q4")[m
[31m-public Person q4(String name,String address){[m
[31m-[m
[31m-       Person p = personRepository.withNameAndAddressNamedQuery(name,[m
[31m-[m
[31m-       return p;[m
[31m-[m
[31m-}[m
[31m-[m
[31m-/**[m
[31m- * 测试排序[m
[31m- */[m
[31m-[m
[31m-@RequestMapping("/sort")[m
[31m-public List<Person> sort(){[m
[31m-[m
[31m-       List<Person> people = personRepository.findAll(new Sort(Directi[m
[31m-[m
[31m-       return people;[m
[31m-[m
[31m-}[m
[31m-[m
[31m-/**[m
[31m- * 测试分页[m
[31m- */[m
[31m-[m
[31m-@RequestMapping("/page")[m
[31m-public Page<Person> page(){[m
[31m-                      Page<Person> pagePeople = personRepository.findAll(new PageRequ[m
[31m-                      return pagePeople;[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     下面分别访问地址测试运行效果。[m
[31m-     访问http://localhost：8080/save？name=dd&address=上海[m
[31m-&age=25，如图8-23所示。[m
[31m-[m
[31m-    图8-23　访问http://localhost：8080/save？name=dd&address=上海[m
[31m-                                         &age=25[m
[31m-[m
[31m-     访问http://localhost：8080/q1？address=合肥，如图8-24所[m
[31m-示。[m
[31m-           图8-24　访问：http://localhost：8080/q1？address=合肥[m
[31m-[m
[31m-     访问http://localhost：8080/q2？address=合肥&name=汪云[m
[31m-飞，如图8-25所示。[m
[31m-[m
[31m-   图8-25　访问http://localhost：8080/q2？address=合肥&name=汪云飞[m
[31m-[m
[31m-     访问http://localhost：8080/q3？address=合肥&name=汪云[m
[31m-飞，如图8-26所示。[m
[31m-[m
[31m-   图8-26　访问http://localhost：8080/q3？address=合肥&name=汪云飞[m
[31m-[m
[31m-     访问http://localhost：8080/q4？address=合肥&name=汪云[m
[31m-飞，如图8-27所示。[m
[31m-图8-27　访问http://localhost：8080/q4？address=合肥&name=汪云飞[m
[31m-[m
[31m-  访问http://localhost：8080/sort，如图8-28所示。[m
[31m-[m
[31m-                   图8-28　访问http://localhost：8080/sort[m
[31m-[m
[31m-  访问http://localhost：8080/page，如图8-29所示。[m
[31m-                     图8-29　访问http://localhost：8080/page[m
[31m-[m
[31m-     7.自定义Repository实现[m
[31m-[m
[31m-     上面的实战演示已经包含了Spring Boot和Spring Data JPA[m
[31m-组合的绝大多数功能。下面我们将结合Specification和自定义[m
[31m-Repository实现来定制一个自动模糊查询。即对于任意的实体[m
[31m-对象进行查询，对象里有几个值我们就查几个值，当值为字符[m
[31m-型时我们就自动like查询，其余的类型使用自动等于查询，没[m
[31m-有值我们就查询全部。[m
[31m-[m
[31m-     （1）定义Specification：[m
[31m-[m
[31m-       package com.wisely.specs;[m
[31m-[m
[31m-       import static com.google.common.collect.Iterables.toArray;[m
[31m-[m
[31m-       import java.lang.reflect.Field;[m
[31m-       import java.util.ArrayList;[m
[31m-       import java.util.List;[m
[31m-import javax.persistence.EntityManager;[m
[31m-import javax.persistence.criteria.CriteriaBuilder;[m
[31m-import javax.persistence.criteria.CriteriaQuery;[m
[31m-import javax.persistence.criteria.Predicate;[m
[31m-import javax.persistence.criteria.Root;[m
[31m-import javax.persistence.metamodel.Attribute;[m
[31m-import javax.persistence.metamodel.EntityType;[m
[31m-import javax.persistence.metamodel.SingularAttribute;[m
[31m-[m
[31m-import org.springframework.data.jpa.domain.Specification;[m
[31m-import org.springframework.util.ReflectionUtils;[m
[31m-import org.springframework.util.StringUtils;[m
[31m-[m
[31m-public class CustomerSpecs {[m
[31m-[m
[31m-       public static <T> Specification<T> byAuto(final EntityManager entit[m
[31m-[m
[31m-              final Class<T> type = (Class<T>) example.getClass();//2[m
[31m-[m
[31m-              return new Specification<T>() {[m
[31m-[m
[31m-                     @Override[m
[31m-                     public Predicate toPredicate(Root<T> root, CriteriaQuery<?[m
[31m-> query, CriteriaBuilder cb) {[m
[31m-[m
[31m-                              List<Predicate> predicates = new ArrayList<>[m
[31m-(); //3[m
[31m-[m
[31m-                             EntityType<T> entity = entityManager.getMetamodel().ent[m
[31m-[m
[31m-                                                                      for (Attribute<T, ?[m
[31m-> attr : entity.getDeclaredAttributes()) {//5[m
[31m-[m
[31m-                                    Object attrValue = getValue(example, attr); //6[m
[31m-                                    if (attrValue != null) {[m
[31m-[m
[31m-                                           if (attr.getJavaType() == String.class) { //7[m
[31m-                                                  if (!StringUtils.isEmpty(attrValue)) { //8[m
[31m-                                                          predicates.add(cb.like(root.get(attribu[m
[31m-                                                                        pattern((String) attrValue)));[m
[31m-                                                  }[m
[31m-[m
[31m-                                           } else {[m
[31m-       predicates.add(cb.equal(root.get(attribute(entity, attr.getName(),[m
[31m-[m
[31m-                                                                 attrValue)); //10[m
[31m-                                           }[m
[31m-                                    }[m
[31m-[m
[31m-                             }[m
[31m-                             return predicates.isEmpty() ? cb.conjunction() : cb.and[m
[31m-                     }[m
[31m-> attr) {  /**[m
[31m-            * 12[m
[31m-            */[m
[31m-[m
[31m-           private <T> Object getValue(T example, Attribute<T, ?[m
[31m-[m
[31m-                  return ReflectionUtils.getField((Field) attr.getJavaMem[m
[31m-           }[m
[31m-[m
[31m-           /**[m
[31m-            * 13[m
[31m-            */[m
[31m-[m
[31m-           private <E, T> SingularAttribute<T, E> attribute(EntityType[m
[31m-                         Class<E> fieldClass) {[m
[31m-[m
[31m-                  return entity.getDeclaredSingularAttribute(fieldName, f[m
[31m-           }[m
[31m-[m
[31m-      };[m
[31m-[m
[31m-   }[m
[31m-[m
[31m-   /**[m
[31m-    * 14[m
[31m-    */[m
[31m-[m
[31m-   static private String pattern(String str) {[m
[31m-          return "%" + str + "%";[m
[31m-[m
[31m-   }[m
[31m-[m
[31m-}[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①定义一个返回值为Specification的方法byAuto，这里使用[m
[31m-的是泛型T，所以这个Specification是可以用于任意的实体类[m
[31m-的。它接受的参数是entityManager和当前的包含值作为查询条[m
[31m-件的实体类对象。[m
[31m-[m
[31m-     ②获得当前实体类对象类的类型。[m
[31m-[m
[31m-     ③新建Predicate列表存储构造的查询条件。[m
[31m-     ④获得实体类的EntityType，我们可以从EntityType获得实[m
[31m-体类的属性。[m
[31m-[m
[31m-     ⑤对实体类的所有属性做循环。[m
[31m-[m
[31m-     ⑥获得实体类对象某一个属性的值。[m
[31m-[m
[31m-     ⑦当前属性值为字符类型的时候。[m
[31m-[m
[31m-     ⑧若当前字符不为空的情况下。[m
[31m-[m
[31m-     ⑨构造当前属性like（前后%）属性值查询条件，并添加到[m
[31m-条件列表中。[m
[31m-[m
[31m-     ⑩其余情况下，构造属性和属性值equal查询条件，并添加[m
[31m-到条件列表中。[m
[31m-[m
[31m-     ⑪将条件列表转换成Predicate。[m
[31m-[m
[31m-     ⑫通过反射获得实体类对象对应属性的属性值。[m
[31m-[m
[31m-     ⑬获得实体类的当前属性的SingularAttribute，[m
[31m-SingularAttribute包含的是实体类的某个单独属性。[m
[31m-[m
[31m-     ⑭构造like的查询模式，即前后加%。[m
[31m-[m
[31m-     （2）定义接口：[m
[31m-[m
[31m-       package com.wisely.support;[m
[31m-[m
[31m-       import java.io.Serializable;[m
[31m-[m
[31m-       import org.springframework.data.domain.Page;[m
[31m-       import org.springframework.data.domain.Pageable;[m
[31m-       import org.springframework.data.jpa.repository.JpaRepository;[m
[31m-       import org.springframework.data.jpa.repository.JpaSpecificationExecutor[m
[31m-       import org.springframework.data.repository.NoRepositoryBean;[m
[31m-       @NoRepositoryBean[m
[31m-       public interface CustomRepository<T, ID extends Serializable>extends Jp[m
[31m-       {[m
[31m-[m
[31m-              Page<T> findByAuto(T example,Pageable pageable);[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     此例中的接口继承了JpaRepository，让我们具备了[m
[31m-JpaRepository所提供的方法；继承了JpaSpecificationExecutor，[m
[31m-让我们具备使用Specification的能力。[m
[31m-[m
[31m-     （3）定义实现：[m
[31m-[m
[31m-       package com.wisely.support;[m
[31m-[m
[31m-       import java.io.Serializable;[m
[31m-[m
[31m-       import javax.persistence.EntityManager;[m
[31m-[m
[31m-       import org.springframework.data.domain.Page;[m
[31m-       import org.springframework.data.domain.Pageable;[m
[31m-       import org.springframework.data.jpa.repository.support.SimpleJpaReposit[m
[31m-[m
[31m-       import static com.wisely.specs.CustomerSpecs.*;[m
[31m-[m
[31m-       public class CustomRepositoryImpl <T, ID extends Serializable>[m
[31m-                                           extends SimpleJpaRepository<T, ID> implements Cust[m
[31m-[m
[31m-              private final EntityManager entityManager;[m
[31m-[m
[31m-              public CustomRepositoryImpl(Class<T> domainClass, EntityManager ent[m
[31m-                      super(domainClass, entityManager);[m
[31m-                      this.entityManager = entityManager;[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              @Override[m
[31m-              public Page<T> findByAuto(T example, Pageable pageable) {[m
[31m-                      return findAll(byAuto(entityManager, example),pageable);[m
[31m-[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     此类继承JpaRepository的实现类SimpleJpaRepository，让我[m
[31m-们可以使用SimpleJpaRepository的方法；此类当然还要实现我[m
[31m-们自定义的接口CustomRepository。[m
[31m-[m
[31m-     findByAuto方法使用byAuto Specification构造的条件查询，[m
[31m-并提供分页功能。[m
[31m-[m
[31m-     （4）定义repositoryFactoryBean：[m
[31m-[m
[31m-       package com.wisely.support;[m
[31m-[m
[31m-       import java.io.Serializable;[m
[31m-[m
[31m-       import javax.persistence.EntityManager;[m
[31m-[m
[31m-       import org.springframework.data.jpa.repository.JpaRepository;[m
[31m-       import org.springframework.data.jpa.repository.support.JpaRepositoryFac[m
[31m-       import org.springframework.data.jpa.repository.support.JpaRepositoryFac[m
[31m-       import org.springframework.data.jpa.repository.support.SimpleJpaReposit[m
[31m-       import org.springframework.data.repository.core.RepositoryInformation;[m
[31m-       import org.springframework.data.repository.core.RepositoryMetadata;[m
[31m-       import org.springframework.data.repository.core.support.RepositoryFacto[m
[31m-[m
[31m-       public class CustomRepositoryFactoryBean<T extends JpaRepository<S, ID>[m
[31m-                      extends JpaRepositoryFactoryBean<T, S, ID> {[m
[31m-[m
[31m-              @Override[m
[31m-              protected RepositoryFactorySupport createRepositoryFactory(EntityMa[m
[31m-[m
[31m-                      return new CustomRepositoryFactory(entityManager);[m
[31m-              }[m
[31m-[m
[31m-              private static class CustomRepositoryFactory extends JpaRepositoryF[m
[31m-      public CustomRepositoryFactory(EntityManager entityManager) {[m
[31m-             super(entityManager);[m
[31m-[m
[31m-      }[m
[31m-[m
[31m-              @Override[m
[31m-              @SuppressWarnings({"unchecked"})[m
[31m-              protected <T, ID extends Serializable> SimpleJpaRepository<?, ?[m
[31m-> getTargetRepository([m
[31m-[m
[31m-                             RepositoryInformation information, EntityManager entity[m
[31m-                                     return new CustomRepositoryImpl<T, ID>[m
[31m-[m
[31m-((Class<T>) information.getDomainType(), entityManager);[m
[31m-[m
[31m-      }[m
[31m-[m
[31m-      @Override[m
[31m-[m
[31m-                 protected                   Class<?[m
[31m-[m
[31m-> getRepositoryBaseClass(RepositoryMetadata metadata) {[m
[31m-[m
[31m-         return CustomRepositoryImpl.class;[m
[31m-[m
[31m-      }[m
[31m-[m
[31m-   }[m
[31m-[m
[31m-}[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     在8.2.1中我们对定义RepositoryFactoryBean做了讲解，这[m
[31m-里的代码大可以作为模板代码使用，只需修改和定义实现类相[m
[31m-关的代码即可。[m
[31m-[m
[31m-     （5）使用：[m
[31m-[m
[31m-       package com.wisely.dao;[m
[31m-[m
[31m-       import java.util.List;[m
[31m-[m
[31m-       import org.springframework.data.jpa.repository.Query;[m
[31m-       import org.springframework.data.repository.query.Param;[m
[31m-[m
[31m-       import com.wisely.domain.Person;[m
[31m-       import com.wisely.support.CustomRepository;[m
[31m-       public interface PersonRepository extends CustomRepository<Person, Long[m
[31m-[m
[31m-              List<Person> findByAddress(String address);[m
[31m-              Person findByNameAndAddress(String name,String address);[m
[31m-              @Query("select p from Person p where p.name= :name and p.address= :[m
[31m-              Person withNameAndAddressQuery(@Param("name")String name,@Param("ad[m
[31m-              Person withNameAndAddressNamedQuery(String name,String address);[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     只需让实体类Repository继承我们自定义的Repository接[m
[31m-口，即可使用我们在自定义Respository中实现的功能。[m
[31m-[m
[31m-       package com.wisely.web;[m
[31m-[m
[31m-       import java.util.List;[m
[31m-[m
[31m-       import org.springframework.beans.factory.annotation.Autowired;[m
[31m-       import org.springframework.data.domain.Page;[m
[31m-       import org.springframework.data.domain.PageRequest;[m
[31m-       import org.springframework.data.domain.Sort;[m
[31m-       import org.springframework.data.domain.Sort.Direction;[m
[31m-       import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-       import org.springframework.web.bind.annotation.RestController;[m
[31m-[m
[31m-       import com.wisely.dao.PersonRepository;[m
[31m-       import com.wisely.domain.Person;[m
[31m-[m
[31m-       @RestController[m
[31m-       public class DataController {[m
[31m-[m
[31m-              @RequestMapping("/auto")[m
[31m-              public Page<Person> auto(Person person){[m
[31m-[m
[31m-                      Page<Person> pagePeople = personRepository.findByAuto(person, n[m
[31m-[m
[31m-                      return pagePeople;[m
[31m-[m
[31m-              }[m
[31m-       }[m
[31m-     代码解释[m
[31m-[m
[31m-     控制器中接受一个Person对象，当Person的name有值时，[m
[31m-会自动对name进行like查询；当age有值时，会进行等于查询；[m
[31m-当Person中有多个值不为空的时候，会自动构造多个查询条[m
[31m-件；当Person所有值为空的时候，默认查询出所有记录。[m
[31m-[m
[31m-     此处需要特别指出的是，在实体类中定义的数据类型要用[m
[31m-包装类型（Long、Integer），而不能使用原始数据类型[m
[31m-（long、int）。因为在Spring MVC中，使用原始数据类型会自[m
[31m-动初始化为0，而不是空，导致我们构造条件失败。[m
[31m-[m
[31m-     （6）配置：[m
[31m-[m
[31m-       package com.wisely;[m
[31m-[m
[31m-       import org.springframework.beans.factory.annotation.Autowired;[m
[31m-       import org.springframework.boot.SpringApplication;[m
[31m-       import org.springframework.boot.autoconfigure.SpringBootApplication;[m
[31m-       import org.springframework.data.jpa.repository.config.EnableJpaReposito[m
[31m-[m
[31m-       import com.wisely.dao.PersonRepository;[m
[31m-       import com.wisely.support.CustomRepositoryFactoryBean;[m
[31m-[m
[31m-       @SpringBootApplication[m
[31m-       @EnableJpaRepositories(repositoryFactoryBeanClass = CustomRepositoryFac[m
[31m-       public class Ch82Application {[m
[31m-[m
[31m-              @Autowired[m
[31m-              PersonRepository personRepository;[m
[31m-[m
[31m-              public static void main(String[] args) {[m
[31m-                      SpringApplication.run(Ch82Application.class, args);[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-     在配置类上配置@EnableJpaRepositories，并指定[m
[31m-repositoryFactoryBeanClass，让我们自定义的Repository实现起[m
[31m-效。[m
[31m-[m
[31m-     如果我们不需要自定义Repository实现，则在Spring Data[m
[31m-JPA里无须添加@EnableJpaRepositories注解，因为[m
[31m-@SpringBootApplication包含的@EnableAutoConfiguration注解[m
[31m-已经开启了对Spring Data JPA的支持。[m
[31m-[m
[31m-     7.运行[m
[31m-[m
[31m-     访问http://localhost：8080/auto，无构造查询条件，查询全[m
[31m-部，如图8-30所示。[m
[31m-                              图8-30　无构造查询条件[m
[31m-[m
[31m-     访问http://localhost：8080/auto？address=肥，构造address[m
[31m-的like查询，如图8-31所示。[m
[31m-                           图8-31　构造address的like查询[m
[31m-[m
[31m-     访问http://localhost：8080/auto？address=肥&name=云[m
[31m-&age=32，构造address的like查询、name的like查询以及age的[m
[31m-equal查询，如图8-32所示。[m
[31m-[m
[31m-  图8-32　构造address的like查询、name的like查询以及age的equal查询[m
[31m-8.3　Spring Data REST[m
[31m-[m
[31m-8.3.1　点睛Spring Data REST[m
[31m-[m
[31m-     （1）什么是Spring Data REST[m
[31m-[m
[31m-     Spring Data JPA是基于Spring Data的repository之上，可以[m
[31m-将repository自动输出为REST资源。目前Spring Data REST支持[m
[31m-将Spring Data JPA、Spring Data MongoDB、Spring Data[m
[31m-Neo4j、Spring Data GemFire以及Spring Data Cassandra的[m
[31m-repository自动转换成REST服务。[m
[31m-[m
[31m-     （2）Spring MVC中配置使用Spring Data REST[m
[31m-[m
[31m-     Spring Data REST的配置是定义在[m
[31m-RepositoryRestMvcConfiguration（org.springframework.data.rest.webmvc.co[m
[31m-配置类中已经配置好了，我们可以通过继承此类或者直接在自[m
[31m-己的配置类上@Import此配置类。[m
[31m-[m
[31m-     1）继承方式演示：[m
[31m-[m
[31m-       @Configuration[m
[31m-       public class MyRepositoryRestMvcConfiguration extends RepositoryRestMvc[m
[31m-[m
[31m-              @Override[m
[31m-              public RepositoryRestConfiguration config() {[m
[31m-[m
[31m-                      return super.config();[m
[31m-              }[m
[31m-[m
[31m-              //其他可重写以config开头的方法[m
[31m-       }[m
[31m-     2）导入方式演示：[m
[31m-[m
[31m-       @Configuration[m
[31m-       @Import(RepositoryRestMvcConfiguration.class)[m
[31m-       public class AppConfig {[m
[31m-       }[m
[31m-[m
[31m-     因在Spring MVC中使用Spring Data REST和在Spring Boot[m
[31m-中使用方式是一样的，因此我们将在实战环节讲解Spring Data[m
[31m-REST。[m
[31m-[m
[31m-8.3.2　Spring Boot的支持[m
[31m-[m
[31m-     Spring Boot对Spring Data REST的自动配置放置在Rest中，[m
[31m-如图8-33所示。[m
[31m-[m
[31m-              图8-33　Restk[m
[31m-[m
[31m-通过SpringBootRepositoryRestMvcConfiguration类的源码我[m
[31m-[m
[31m-们可以得出，Spring  Boot已经为我们自动配置了[m
[31m-[m
[31m-RepositoryRestConfiguration，所以在Spring Boot中使用Spring[m
[31m-[m
[31m-Data REST只需引入spring-boot-starter-data-rest的依赖，无须任[m
[31m-[m
[31m-何配置即可使用。[m
[31m-[m
[31m-Spring        Boot通过在application.properties中配置[m
[31m-[m
[31m-以“spring.data.rest”为前缀的属性来配置[m
[31m-[m
[31m-RepositoryRestConfiguration，如图8-34所示。[m
[31m-                    图8-34　配置RepositoryRestConfiguration[m
[31m-[m
[31m-8.3.3　实战[m
[31m-[m
[31m-     （1）新建Spring Boot项目。[m
[31m-     新建Spring Boot项目，依赖为JPA（spring-boot-starter-data-[m
[31m-jpa）和Rest Repositories（spring-boot-starter-data-rest）。[m
[31m-     项目信息：[m
[31m-[m
[31m-       groupId：com.wisely[m
[31m-       arctifactId:ch8_3[m
[31m-       package: com.wisely.ch8_3[m
[31m-[m
[31m-     添加Oracle JDBC驱动，并在application.properties配置相关[m
[31m-属性，与上例保持一致。[m
[31m-[m
[31m-     （2）实体类：[m
[31m-[m
[31m-       package com.wisely.ch8_3.domain;[m
[31m-       import javax.persistence.Entity;[m
[31m-       import javax.persistence.GeneratedValue;[m
[31m-       import javax.persistence.Id;[m
[31m-@Entity[m
[31m-public class Person {[m
[31m-[m
[31m-       @Id[m
[31m-       @GeneratedValue[m
[31m-       private Long id;[m
[31m-[m
[31m-       private String name;[m
[31m-[m
[31m-       private Integer age;[m
[31m-[m
[31m-       private String address;[m
[31m-[m
[31m-       public Person() {[m
[31m-              super();[m
[31m-[m
[31m-       }[m
[31m-       public Person(Long id, String name, Integer age, String address) {[m
[31m-[m
[31m-              super();[m
[31m-              this.id = id;[m
[31m-              this.name = name;[m
[31m-              this.age = age;[m
[31m-              this.address = address;[m
[31m-       }[m
[31m-//省略getter、setter[m
[31m-}[m
[31m-[m
[31m-（3）实体类的Repository：[m
[31m-[m
[31m-package com.wisely.ch8_3.dao;[m
[31m-[m
[31m-import org.springframework.data.jpa.repository.JpaRepository;[m
[31m-[m
[31m-import com.wisely.ch8_3.domain.Person;[m
[31m-[m
[31m-public interface PersonRepository extends JpaRepository<Person, Long> {[m
[31m-[m
[31m-       Person findByNameStartsWith(String name);[m
[31m-[m
[31m-}[m
[31m-[m
[31m-（4）安装Chrome插件Postman REST Client。[m
[31m-     Postman是一个支持REST的客户端，我们可以用它来测试[m
[31m-我们的REST资源。[m
[31m-[m
[31m-     本节将会Postman插件放在源码中，下面讲解Postman在[m
[31m-Chrome下的安装方式，这与在Chrome浏览器下安装其他插件[m
[31m-是一致的。Postman插件放置于本节示例的src/main/resources目[m
[31m-录下。[m
[31m-[m
[31m-     本书使用的Chrome版本是43.0，Postman版本是3.0.4。新[m
[31m-版本的Chrome限制非Chrome应用商店的插件安装。下面来安[m
[31m-装Postman插件。[m
[31m-[m
[31m-     ①用解压缩软件打开postman.crx，并解压到任意目录，如[m
[31m-图8-35所示。[m
[31m-                              图8-35　打开postman.crx[m
[31m-[m
[31m-     ②将_metadata文件夹名称修改为metadata。[m
[31m-[m
[31m-     打开Chrome软件，设置→扩展程序，打开“开发者模式”，[m
[31m-并从“加载正在开发的扩展程序...”加载我们刚才解压的目录，[m
[31m-如图8-36所示。[m
[31m-                                 图8-36　加载Postman[m
[31m-[m
[31m-     安装完成后的效果如图8-37所示。[m
[31m-[m
[31m-                                   图8-37　加载完成[m
[31m-[m
[31m-     ③在Chrome地址栏输入“chrome：//apps”，可看到[m
[31m-Postman，如图8-38所示。[m
[31m-                   图8-38　通过Chrome查看Postman[m
[31m-[m
[31m-或者通过Chrome提供的快捷方式打开，如图8-39所示。[m
[31m-        图8-39　通过Chrome提供的快捷方式打开Postman[m
[31m-[m
[31m-Postman的界面如图8-40所示。[m
[31m-                                 图8-40　Postman界面[m
[31m-[m
[31m-     5.REST服务测试[m
[31m-[m
[31m-     在这里我们使用Postman测试REST资源服务。[m
[31m-[m
[31m-     （1）jQuery[m
[31m-[m
[31m-     在实际开发中，在jQuery我们使用$.ajax方法的type属性来[m
[31m-修改提交方法：[m
[31m-[m
[31m-       $.ajax({[m
[31m-                               type: "GET",[m
[31m-                               dataType: "json",[m
[31m-                               url: "http://localhost:8080/persons ",[m
[31m-                               success: function(data){[m
[31m-                                    alert(data);[m
[31m-                               }[m
[31m-[m
[31m-                       });[m
[31m-[m
[31m-     （2）AngularJS[m
[31m-[m
[31m-     在实际开发中，可以使用$http对象来操作：[m
[31m-       $http.get(url)[m
[31m-       $http.post(url,data)[m
[31m-       $http.put(url,data)[m
[31m-       $http.delete(url)[m
[31m-[m
[31m-     （3）列表[m
[31m-     在实际开发中，在Postman中使用GET访问http://localhost：[m
[31m-8080/persons，获得列表数据，如图8-41所示。[m
[31m-[m
[31m-                                图8-41　获得列表数据[m
[31m-[m
[31m-     （4）获取单一对象[m
[31m-     在Postman中使用GET访问http://localhost：8080/1，获得id[m
[31m-为1的对象，如图8-42所示。[m
[31m-                              图8-42　获得id为1的对象[m
[31m-[m
[31m-     （5）查询[m
[31m-[m
[31m-     在上面的自定义实体类Repository中定义了[m
[31m-findByNameStartsWith方法，若想此方法也暴露为REST资源，[m
[31m-需做如下修改：[m
[31m-[m
[31m-       public interface PersonRepository extends JpaRepository<Person, Long> {[m
[31m-[m
[31m-              @RestResource(path = "nameStartsWith", rel = "nameStartsWith")[m
[31m-              Person findByNameStartsWith(@Param("name")String name);[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     此时在Postman中使用GET访问http://localhost：[m
[31m-8080/persons/search/nameStartsWith？name=汪，可实现查询操[m
[31m-作，如图8-43所示。[m
[31m-[m
[31m-     （6）分页[m
[31m-[m
[31m-     在Postman中使用GET访问http://localhost：8080/persons/？[m
[31m-page=1&size=2，page=1即第二页，size=2即每页数量为2，如[m
[31m-图8-44所示。[m
[31m-                              图8-43　回应现查询操作[m
[31m-[m
[31m-                                      图8-44　分布[m
[31m-[m
[31m-     从返回结果可以看出，我们不仅能获得当前分页的对象，[m
[31m-而且还给出了我们上一页、下一页、第一页、最后一页的[m
[31m-REST资源路径。[m
[31m-[m
[31m-     （7）排序[m
[31m-     在Postman中使用GET访问localhost：8080/persons/？[m
[31m-sort=age，desc，即按照age属性倒序，如图8-45所示。[m
[31m-                                      图8-45　排序[m
[31m-[m
[31m-     （8）保存[m
[31m-[m
[31m-     向http://localhost：8080/persons发起POST请求，将我们要[m
[31m-保存的数据放置在请求体中，数据类型设置为JSON，JSON内[m
[31m-容如图8-46所示。[m
[31m-[m
[31m-       {"name":"cc","address":"成都","age":24}[m
[31m-                                      图8-46　保存[m
[31m-[m
[31m-     通过输出可以看出，保存成功后，我们的新数据的id为[m
[31m-21。[m
[31m-[m
[31m-     （9）更新[m
[31m-[m
[31m-     现在我们更新新增的id为21的数据，用PUT方式访问[m
[31m-http://localhost：8080/persons/21，并修改提交的数据，如图8-[m
[31m-47所示。[m
[31m-[m
[31m-       {"name":"cc2","address":"成都","age":23}[m
[31m-                                      图8-47　更新[m
[31m-[m
[31m-     从输出我们可以看出，数据更新已成功。[m
[31m-[m
[31m-     （10）删除[m
[31m-[m
[31m-     在这一步我们删除刚才新增的id为21的数据，使用[m
[31m-DELETE方式访问http://localhost：8080/persons/21，如图8-48[m
[31m-所示。[m
[31m-                                      图8-48　删除[m
[31m-[m
[31m-     此时再用GET方式访问http://localhost：8080/persons/21，[m
[31m-如图8-49所示。[m
[31m-[m
[31m-                                   图8-49　获取失败[m
[31m-[m
[31m-     返回结果为404 Not Found，说明所访问的REST资源不存[m
[31m-在。[m
[31m-     6.定制[m
[31m-[m
[31m-     （1）定制根路径[m
[31m-[m
[31m-     在上面的实战例子中，我们访问的REST资源的路径是在[m
[31m-根目录下的，即http://localhost：8080/persons，如果我们需要[m
[31m-定制根路径的话，只需在Spring Boot的application.properties下[m
[31m-增加如下定义即可：[m
[31m-[m
[31m-       spring.data.rest.base-path= /api[m
[31m-[m
[31m-     此时REST资源的路径变成了http://localhost：[m
[31m-8080/api/persons。[m
[31m-[m
[31m-     （2）定制节点路径[m
[31m-[m
[31m-     上例实战中，我们的节点路径为http://localhost：[m
[31m-8080/persons，这是Spring Data REST的默认规则，就是在实体[m
[31m-类之后加“s”来形成路径。我们知道person的复数是people而不[m
[31m-是persons，在类似的情况下要对映射的名称进行修改的话，我[m
[31m-们需要在实体类Repository上使用@RepositoryRestResource注[m
[31m-解的path属性进行修改，代码如下：[m
[31m-[m
[31m-       @RepositoryRestResource(path = "people")[m
[31m-       public interface PersonRepository extends JpaRepository<Person, Long> {[m
[31m-[m
[31m-              @RestResource(path = "nameStartsWith", rel = "nameStartsWith")[m
[31m-              Person findByNameStartsWith(@Param("name")String name);[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     此时我们访问REST服务的地址变为：http://localhost：[m
[31m-8080/api/people。[m
[31m-8.4　声名式事务[m
[31m-[m
[31m-8.4.1　Spring的事务机制[m
[31m-[m
[31m-     所有的数据访问技术都有事务处理机制，这些技术提供了[m
[31m-API用来开启事务、提交事务来完成数据操作，或者在发生错[m
[31m-误的时候回滚数据。[m
[31m-[m
[31m-     而Spring的事务机制是用统一的机制来处理不同数据访问[m
[31m-技术的事务处理。Spring的事务机制提供了一个[m
[31m-PlatformTransactionManager接口，不同的数据访问技术的事务[m
[31m-使用不同的接口实现，如表8-3所示。[m
[31m-[m
[31m-                            表8-3　数据访问技术及实现[m
[31m-[m
[31m-     在程序中定义事务管理器的代码如下：[m
[31m-[m
[31m-         @Bean[m
[31m-         public PlatformTransactionManager transactionManager() {[m
[31m-[m
[31m-              JpaTransactionManager transactionManager = new JpaTransactionManage[m
[31m-              transactionManager.setDataSource(dataSource());[m
[31m-              return transactionManager;[m
[31m-         }[m
[31m-8.4.2　声名式事务[m
[31m-[m
[31m-     Spring支持声名式事务，即使用注解来选择需要使用事务[m
[31m-的方法，它使用@Transactional注解在方法上表明该方法需要[m
[31m-事务支持。这是一个基于AOP的实现操作，读者可以重温1.3.3[m
[31m-节中使用注解式的拦截方式来理解Spring的声名式事务。被注[m
[31m-解的方法在被调用时，Spring开启一个新的事务，当方法无异[m
[31m-常运行结束后，Spring会提交这个事务。[m
[31m-[m
[31m-@Transactional                  id, String name) {[m
[31m-[m
[31m-public void saveSomething(Long[m
[31m-       //数据库操作[m
[31m-[m
[31m-}[m
[31m-[m
[31m-     在此处需要特别注意的是，此@Transactional注解来自[m
[31m-org.springframework.transaction.annotation包，而不是[m
[31m-javax.transaction。[m
[31m-[m
[31m-     Spring提供了一个@EnableTransactionManagement注解在配[m
[31m-置类上来开启声名式事务的支持。使用了[m
[31m-@EnableTransactionManagement后，Spring容器会自动扫描注[m
[31m-解@Transactional的方法和类。@EnableTransactionManagement[m
[31m-的使用方式如下：[m
[31m-[m
[31m-       @Configuration[m
[31m-       @EnableTransactionManagement[m
[31m-       public class AppConfig {[m
[31m-[m
[31m-       }[m
[31m-8.4.3　注解事务行为[m
[31m-[m
[31m-     @Transactional有如表8-4所示的属性来定制事务行为。[m
[31m-[m
[31m-                            表8-4　@Transactional的属性[m
[31m-[m
[31m-8.4.4　类级别使用@Transactional[m
[31m-[m
[31m-     @Transactional不仅可以注解在方法上，也可以注解在类[m
[31m-上。当注解在类上的时候意味着此类的所有public方法都是开[m
[31m-启事务的。如果类级别和方法级别同时使用了@Transactional[m
[31m-注解，则使用在类级别的注解会重载方法级别的注解。[m
[31m-[m
[31m-8.4.5　Spring Data JPA的事务支持[m
[31m-[m
[31m-     Spring Data JPA对所有的默认方法都开启了事务支持，且[m
[31m-查询类事务默认启用readOnly=true属性。[m
[31m-[m
[31m-     这些我们在SimpleJpaRepository的源码中可以看到，下面[m
[31m-就来看看缩减的SimpleJpaRepository的源码：[m
[31m-[m
[31m-       @Repository[m
[31m-       @Transactional(readOnly = true)[m
[31m-       public class SimpleJpaRepository<T, ID extends Serializable> implements[m
[31m-[m
[31m-                      JpaSpecificationExecutor<T> {[m
[31m-[m
[31m-              @Transactional[m
[31m-              public void delete(ID id) {}[m
[31m-              @Transactional[m
[31m-              public void delete(T entity) {}[m
[31m-              @Transactional[m
[31m-              public void delete(Iterable<? extends T> entities) {}[m
[31m-              @Transactional[m
[31m-              public void deleteInBatch(Iterable<T> entities) {}[m
[31m-              @Transactional[m
[31m-              public void deleteAll() {}[m
[31m-              @Transactional[m
[31m-              public void deleteAllInBatch() {}[m
[31m-              public T findOne(ID id) {}[m
[31m-              @Override[m
[31m-              public T getOne(ID id) {}[m
[31m-              public boolean exists(ID id) {}[m
[31m-              public List<T> findAll() {}[m
[31m-              public List<T> findAll(Iterable<ID> ids) {}[m
[31m-              public List<T> findAll(Sort sort) {}[m
[31m-              public Page<T> findAll(Pageable pageable) {}[m
[31m-              public T findOne(Specification<T> spec) {}[m
[31m-              public List<T> findAll(Specification<T> spec) {}[m
[31m-              public Page<T> findAll(Specification<T> spec, Pageable pageable) {}[m
[31m-              public List<T> findAll(Specification<T> spec, Sort sort) {}[m
[31m-              public long count() {}[m
[31m-              public long count(Specification<T> spec) {}[m
[31m-              @Transactional[m
[31m-              public <S extends T> S save(S entity) {}[m
[31m-[m
[31m-              @Transactional[m
[31m-              public <S extends T> S saveAndFlush(S entity) {}[m
[31m-              @Transactional[m
[31m-              public <S extends T> List<S> save(Iterable<S> entities) {}[m
[31m-              @Transactional[m
[31m-              public void flush() {}[m
[31m-       }[m
[31m-[m
[31m-     从源码我们可以看出，SimpleJpaRepository在类级别定义[m
[31m-了@Transactional（readOnly=true），而在和save、delete相关[m
[31m-的操作重写了@Transactional属性，此时readOnly属性是false，[m
[31m-其余查询操作readOnly仍然为false。[m
[31m-[m
[31m-8.4.6　Spring Boot的事务支持[m
[31m-[m
[31m-     1.自动配置的事务管理器[m
[31m-[m
[31m-     在使用JDBC作为数据访问技术的时候，Spring Boot为我们[m
[31m-定义了PlatformTransactionManager的实现[m
[31m-DataSourceTransactionManager的Bean；配置见[m
[31m-org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManager[m
[31m-类中的定义：[m
[31m-[m
[31m-              @Bean[m
[31m-              @ConditionalOnMissingBean[m
[31m-              @ConditionalOnBean(DataSource.class)[m
[31m-              public PlatformTransactionManager transactionManager() {[m
[31m-[m
[31m-                      return new DataSourceTransactionManager(this.dataSource);[m
[31m-}[m
[31m-[m
[31m-     在使用JPA作为数据访问技术的时候，Spring Boot为我们[m
[31m-了定义一个PlatformTransactionManager的实现[m
[31m-JpaTransactionManager的Bean；配置见[m
[31m-org.springframework.boot.autoconfigure.orm.jpa.JpaBaseConfiguration.class[m
[31m-类中的定义：[m
[31m-[m
[31m-              @Bean[m
[31m-              @ConditionalOnMissingBean(PlatformTransactionManager.class)[m
[31m-              public PlatformTransactionManager transactionManager() {[m
[31m-[m
[31m-                      return new JpaTransactionManager();[m
[31m-              }[m
[31m-[m
[31m-2.自动开启注解事务的支持[m
[31m-[m
[31m-Spring  Boot专门用于配置事务的类为：[m
[31m-[m
[31m-org.springframework.boot.autoconfigure.transaction.TransactionAutoConfigur[m
[31m-[m
[31m-此配置类依赖于JpaBaseConfiguration和DataSource[m
[31m-[m
[31m-TransactionManagerAutoConfiguration。[m
[31m-[m
[31m-     而在DataSourceTransactionManagerAutoConfiguration配置[m
[31m-里还开启了对声名式事务的支持，代码如下：[m
[31m-[m
[31m-@ConditionalOnMissingBean(AbstractTransactionManagementConfiguratio[m
[31m-@Configuration[m
[31m-@EnableTransactionManagement[m
[31m-protected static class TransactionManagementConfiguration {[m
[31m-[m
[31m-}[m
[31m-所以在Spring                  Boot中，无须显示开启使用[m
[31m-[m
[31m-@EnableTransactionManagement注解。[m
[31m-[m
[31m-8.4.7　实战[m
[31m-[m
[31m-     在实际使用中，使用Spring Boot默认的配置就能满足我们[m
[31m-绝大多数需求。在本节的实战里，我们将演示如何使用[m
[31m-@Transactional使用异常导致数据回滚和使用异常让数据不回[m
[31m-滚。[m
[31m-[m
[31m-     1.新建Spring Boot项目[m
[31m-[m
[31m-     新建Spring Boot项目，依赖为JPA（spring-boot-starter-data-[m
[31m-jpa）和Web（spring-boot-starter-web）。[m
[31m-[m
[31m-     项目信息：[m
[31m-[m
[31m-groupId：com.wisely[m
[31m-arctifactId:ch8_4[m
[31m-package: com.wisely.ch8_4[m
[31m-[m
[31m-     添加Oracle JDBC驱动，并在application.properties配置相关[m
[31m-属性，与上例保持一致。[m
[31m-[m
[31m-     2.实体类[m
[31m-[m
[31m-       import javax.persistence.Entity;[m
[31m-       import javax.persistence.GeneratedValue;[m
[31m-       import javax.persistence.Id;[m
[31m-[m
[31m-       @Entity[m
[31m-       public class Person {[m
[31m-[m
[31m-              @Id[m
[31m-       @GeneratedValue[m
[31m-       private Long id;[m
[31m-       private String name;[m
[31m-       private Integer age;[m
[31m-       private String address;[m
[31m-       public Person() {[m
[31m-[m
[31m-              super();[m
[31m-       }[m
[31m-       public Person(Long id, String name, Integer age, String address) {[m
[31m-[m
[31m-              super();[m
[31m-              this.id = id;[m
[31m-              this.name = name;[m
[31m-              this.age = age;[m
[31m-              this.address = address;[m
[31m-       }[m
[31m-       //省略getter、setter[m
[31m-}[m
[31m-[m
[31m-3.实体类Repository[m
[31m-[m
[31m-import org.springframework.data.jpa.repository.JpaRepository;[m
[31m-import com.wisely.ch8_4.domain.Person;[m
[31m-public interface PersonRepository extends JpaRepository<Person, Long> {[m
[31m-[m
[31m-}[m
[31m-[m
[31m-4.业务服务Service[m
[31m-（1）服务接口：[m
[31m-[m
[31m-package com.wisely.ch8_4.service;[m
[31m-import com.wisely.ch8_4.domain.Person;[m
[31m-[m
[31m-public interface DemoService {[m
[31m-       public Person savePersonWithRollBack(Person person);[m
[31m-       public Person savePersonWithoutRollBack(Person person);[m
[31m-[m
[31m-}[m
[31m-[m
[31m-（2）服务实现：[m
[31m-[m
[31m-package com.wisely.ch8_4.service.impl;[m
[31m-[m
[31m-import org.springframework.beans.factory.annotation.Autowired;[m
[31m-import org.springframework.stereotype.Service;[m
[31m-import org.springframework.transaction.annotation.Transactional;[m
[31m-[m
[31m-import com.wisely.ch8_4.dao.PersonRepository;[m
[31m-import com.wisely.ch8_4.domain.Person;[m
[31m-import com.wisely.ch8_4.service.DemoService;[m
[31m-@Service[m
[31m-public class DemoServiceImpl implements DemoService {[m
[31m-[m
[31m-       @Autowired[m
[31m-       PersonRepository personRepository; //1[m
[31m-[m
[31m-                                                             @Transactional(rollbackFor=[m
[31m-{IllegalArgumentException.class}) //2[m
[31m-[m
[31m-       public Person savePersonWithRollBack(Person person){[m
[31m-              Person p =personRepository.save(person);[m
[31m-[m
[31m-              if(person.getName().equals("汪云飞")){[m
[31m-                       throw new IllegalArgumentException("汪云飞已存在，[m
[31m-[m
[31m-数据将回滚"); //3[m
[31m-              }[m
[31m-              return p;[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-                                                         @Transactional(noRollbackFor=[m
[31m-{IllegalArgumentException.class}) //4[m
[31m-[m
[31m-       public Person savePersonWithoutRollBack(Person person){[m
[31m-              Person p =personRepository.save(person);[m
[31m-[m
[31m-              if(person.getName().equals("汪云飞")){[m
[31m-                          throw new IllegalArgumentException("汪云飞虽已存[m
[31m-       在，数据将不会回滚");[m
[31m-                      }[m
[31m-                      return p;[m
[31m-[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①可以直接注入我们的RersonRepository的Bean。[m
[31m-[m
[31m-     ②使用@Transactional注解的rollbackFor属性，指定特定异[m
[31m-常时，数据回滚。[m
[31m-[m
[31m-     ③硬编码手动触发异常。[m
[31m-[m
[31m-     ④使用@Transactional注解的noRollbackFor属性，指定特定[m
[31m-异常时，数据回滚。[m
[31m-[m
[31m-     5.控制器[m
[31m-[m
[31m-       package com.wisely.ch8_4.web;[m
[31m-[m
[31m-       import org.springframework.beans.factory.annotation.Autowired;[m
[31m-       import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-       import org.springframework.web.bind.annotation.RestController;[m
[31m-[m
[31m-       import com.wisely.ch8_4.domain.Person;[m
[31m-       import com.wisely.ch8_4.service.DemoService;[m
[31m-[m
[31m-       @RestController[m
[31m-       public class MyController {[m
[31m-[m
[31m-              @Autowired[m
[31m-              DemoService demoService;[m
[31m-[m
[31m-              @RequestMapping("/rollback")[m
[31m-              public Person rollback(Person person){ //1[m
[31m-[m
[31m-                      return demoService.savePersonWithRollBack(person);[m
[31m-              }[m
[31m-              @RequestMapping("/norollback")[m
[31m-              public Person noRollback(Person person){//2[m
[31m-[m
[31m-                      return demoService.savePersonWithoutRollBack(person);[m
[31m-[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-     ①测试回滚情况。[m
[31m-     ②测试不回滚情况。[m
[31m-     6.运行[m
[31m-     为了更清楚地理解回滚，我们以debug（调试模式）启动[m
[31m-程序。并在DemoServiceImpl的savePersonWithRollBack方法打[m
[31m-上断点。[m
[31m-     （1）回滚[m
[31m-     访问http://localhost：8080/rollback？name=汪云飞[m
[31m-&age=32，调试至savePersonWithRollBack方法，如图8-50所[m
[31m-示。[m
[31m-                                      图8-50　回滚[m
[31m-[m
[31m-     我们可以发现数据已保存且获得id为27。继续执行抛出异[m
[31m-常，将导致数据回滚，如图8-51所示。[m
[31m-[m
[31m-                                   图8-51　数据回滚[m
[31m-[m
[31m-     我们查看数据库，并没有新增数据，如图8-52所示。[m
[31m-                                 图8-52　未新增数据[m
[31m-[m
[31m-     （2）不回滚[m
[31m-     访问http://localhost：8080/norollback？name=汪云飞[m
[31m-&age=32，虽然我们也抛出了异常，如图8-53所示。但数据并[m
[31m-没有回滚，且数据库还新增了一条记录，如图8-54所示。[m
[31m-[m
[31m-                                 图8-53　数据不回滚[m
[31m-图8-54　新增了一条数据[m
[31m-8.5　数据缓存Cache[m
[31m-[m
[31m-     我们知道一个程序的瓶颈在于数据库，我们也知道内存的[m
[31m-速度是大大快于硬盘的速度的。当我们需要重复地获取相同的[m
[31m-数据的时候，我们一次又一次的请求数据库或者远程服务，导[m
[31m-致大量的时间耗费在数据库查询或者远程方法调用上，导致程[m
[31m-序性能的恶化，这便是数据缓存要解决的问题。[m
[31m-[m
[31m-8.5.1　Spring缓存支持[m
[31m-[m
[31m-     Spring定义了org.springframework.cache.CacheManager和[m
[31m-org.springframework.cache.Cache接口用来统一不同的缓存的技[m
[31m-术。其中，CacheManager是Spring提供的各种缓存技术抽象接[m
[31m-口，Cache接口包含缓存的各种操作（增加、删除、获得缓[m
[31m-存，我们一般不会直接和此接口打交道）。[m
[31m-[m
[31m-     1.Spring支持的CacheManager[m
[31m-[m
[31m-     针对不同的缓存技术，需要实现不同的CacheManager，[m
[31m-Spring定义了如表8-5所示的CacheManager实现。[m
[31m-[m
[31m-                              表8-5　CacheManager实现[m
[31m-     在我们使用任意一个实现的CacheManager的时候，需注册[m
[31m-实现的CacheManager的Bean，例如：[m
[31m-[m
[31m-       @Bean[m
[31m-       public EhCacheCacheManager cacheManager(CacheManager ehCacheCacheManage[m
[31m-[m
[31m-              return new EhCacheCacheManager(ehCacheCacheManager);[m
[31m-       }[m
[31m-[m
[31m-     当然，每种缓存技术都有很多的额外配置，但配置[m
[31m-cacheManager是必不可少的。[m
[31m-[m
[31m-     2.声名式缓存注解[m
[31m-     Spring提供了4个注解来声明缓存规则（又是使用注解式的[m
[31m-AOP的一个生动例子）。这四个注解如表8-6所示。[m
[31m-[m
[31m-                               表8-6　声明式缓存注意[m
[31m-[m
[31m-     @Cacheable、@CachePut、@CacheEvit都有value属性，指[m
[31m-定的是要使用的缓存名称；key属性指定的是数据在缓存中的[m
[31m-存储的键。[m
[31m-[m
[31m-     3.开启声名式缓存支持[m
[31m-     开启声名式缓存支持十分简单，只需在配置类上使用[m
[31m-@EnableCaching注解即可，例如：[m
[31m-@Configuration[m
[31m-@EnableCaching[m
[31m-public class AppConfig {[m
[31m-[m
[31m-}[m
[31m-[m
[31m-8.5.2　Spring Boot的支持[m
[31m-[m
[31m-     在Spring中使用缓存技术的关键是配置CacheManager，而[m
[31m-Spring Boot为我们自动配置了多个CacheManager的实现。[m
[31m-[m
[31m-Spring  Boot的CacheManager的自动配置放置在[m
[31m-[m
[31m-org.springframework.boot.autoconfigure.cache包中，如图8-55所[m
[31m-[m
[31m-示。[m
[31m-                        图8-55　CacheManager的自动配置[m
[31m-[m
[31m-     通过图8-56我们可以看出，Spring Boot为我们自动配置了[m
[31m-EhCacheCacheConfiguration（使用EhCache）、[m
[31m-GenericCacheConfiguration（使用Collection）、[m
[31m-GuavaCacheConfiguration（使用Guava）、[m
[31m-HazelcastCacheConfiguration（使用Hazelcast）、[m
[31m-InfinispanCacheConfiguration（使用Infinispan）、[m
[31m-JCacheCacheConfiguration（使用JCache）、[m
[31m-NoOpCacheConfiguration（不使用存储）、[m
[31m-RedisCacheConfiguration（使用Redis）、[m
[31m-SimpleCacheConfiguration（使用ConcurrentMap）。在不做任[m
[31m-何额外配置的情况下，默认使用的是[m
[31m-SimpleCacheConfiguration，即使用      Boot支持[m
[31m-ConcurrentMapCacheManager。Spring[m
[31m-以“spring.cache”为前缀的属性来配置缓存。[m
[31m-[m
[31m-spring.cache.type= # 可选[m
[31m-[m
[31m-generic, ehcache, hazelcast, infinispan, jcache, redis, # guava, simple[m
[31m-spring.cache.cache-names= # 程序启动时创建缓存名称[m
[31m-spring.cache.ehcache.config= # ehcache配置文件地址[m
[31m-spring.cache.hazelcast.config= # hazelcast 配置文件地址[m
[31m-spring.cache.infinispan.config= # infinispan 配置文件地址[m
[31m-spring.cache.jcache.config= # jcache 配置文件地址[m
[31m-spring.cache.jcache.provider= #当多个 jcache实现在类路径中的时[m
[31m-候，指定jcache实现[m
[31m-[m
[31m-spring.cache.guava.spec= # guava specs[m
[31m-[m
[31m-     在Spring Boot环境下，使用缓存技术只需在项目中导入相[m
[31m-关缓存技术的依赖包，并在配置类使用@EnableCaching开启缓[m
[31m-存支持即可。[m
[31m-[m
[31m-8.5.3　实战[m
[31m-[m
[31m-     本例将以Spring Boot默认的ConcurrentMapCacheManager作[m
[31m-为缓存技术，演示@Cacheable、@CachePut、@CacheEvit，最[m
[31m-后使用EhCache、Guava来替换缓存技术。[m
[31m-[m
[31m-     1.新建Spring Boot项目[m
[31m-[m
[31m-     新建Spring Boot项目，依赖为Cache（spring-boot-starter-[m
[31m-cache）、JPA（spring-boot-starter-data-jpa）和Web（spring-[m
[31m-boot-starter-web）。[m
[31m-[m
[31m-     项目信息：[m
[31m-       groupId：com.wisely[m
[31m-       arctifactId:ch8_5[m
[31m-       package: com.wisely.ch8_5[m
[31m-[m
[31m-     添加Oracle JDBC驱动，并在application.properties配置相关[m
[31m-属性，与上例保持一致。[m
[31m-[m
[31m-     2.实体类[m
[31m-[m
[31m-       package com.wisely.ch8_5.domain;[m
[31m-[m
[31m-       import javax.persistence.Entity;[m
[31m-       import javax.persistence.GeneratedValue;[m
[31m-       import javax.persistence.Id;[m
[31m-[m
[31m-       @Entity[m
[31m-       public class Person {[m
[31m-[m
[31m-              @Id[m
[31m-              @GeneratedValue[m
[31m-              private Long id;[m
[31m-[m
[31m-              private String name;[m
[31m-[m
[31m-              private Integer age;[m
[31m-[m
[31m-              private String address;[m
[31m-[m
[31m-              public Person() {[m
[31m-                      super();[m
[31m-[m
[31m-              }[m
[31m-              public Person(Long id, String name, Integer age, String address) {[m
[31m-[m
[31m-                      super();[m
[31m-                      this.id = id;[m
[31m-                      this.name = name;[m
[31m-                      this.age = age;[m
[31m-                      this.address = address;[m
[31m-              }[m
[31m-              //省略getter、setter[m
[31m-       }[m
[31m-3.实体类Repository[m
[31m-[m
[31m-package com.wisely.ch8_5.dao;[m
[31m-import org.springframework.data.jpa.repository.JpaRepository;[m
[31m-import com.wisely.ch8_5.domain.Person;[m
[31m-public interface PersonRepository extends JpaRepository<Person, Long> {[m
[31m-[m
[31m-}[m
[31m-[m
[31m-4.业务服务[m
[31m-（1）接口：[m
[31m-[m
[31m-package com.wisely.ch8_5.service;[m
[31m-import com.wisely.ch8_5.domain.Person;[m
[31m-public interface DemoService {[m
[31m-[m
[31m-       public Person save(Person person);[m
[31m-       public void remove(Long id);[m
[31m-       public Person findOne(Person person);[m
[31m-}[m
[31m-[m
[31m-（2）实现类：[m
[31m-[m
[31m-package com.wisely.ch8_5.service.impl;[m
[31m-import org.springframework.beans.factory.annotation.Autowired;[m
[31m-import org.springframework.cache.annotation.CacheEvict;[m
[31m-import org.springframework.cache.annotation.CachePut;[m
[31m-import org.springframework.cache.annotation.Cacheable;[m
[31m-import org.springframework.stereotype.Service;[m
[31m-[m
[31m-import com.wisely.ch8_5.dao.PersonRepository;[m
[31m-import com.wisely.ch8_5.domain.Person;[m
[31m-import com.wisely.ch8_5.service.DemoService;[m
[31m-@Service[m
[31m-public class DemoServiceImpl implements DemoService {[m
[31m-[m
[31m-       @Autowired[m
[31m-       PersonRepository personRepository;[m
[31m-[m
[31m-   @Override[m
[31m-[m
[31m-   @CachePut(value = "people",key="#person.id") //1[m
[31m-[m
[31m-   public Person save(Person person) {[m
[31m-[m
[31m-      Person p = personRepository.save(person);[m
[31m-      System.out.println("为id、key为:"+p.getId()+"数据做了缓[m
[31m-[m
[31m-存");[m
[31m-[m
[31m-      return p;[m
[31m-[m
[31m-   }[m
[31m-[m
[31m-   @Override[m
[31m-[m
[31m-   @CacheEvict(value = "peopele") //2[m
[31m-[m
[31m-   public void remove(Long id) {[m
[31m-          System.out.println("删除了id、key为"+id+"的数据缓存");[m
[31m-[m
[31m-          personRepository.delete(id);[m
[31m-[m
[31m-   }[m
[31m-[m
[31m-   @Override[m
[31m-[m
[31m-   @Cacheable(value="people",key="#person.id") //3[m
[31m-[m
[31m-   public Person findOne(Person person) {[m
[31m-[m
[31m-      Person p = personRepository.findOne(person.getId());[m
[31m-      System.out.println("为id、key为:"+p.getId()+"数据做了缓[m
[31m-[m
[31m-存");[m
[31m-[m
[31m-      return p;[m
[31m-[m
[31m-   }[m
[31m-[m
[31m-}[m
[31m-[m
[31m-代码解释[m
[31m-①@CachePut缓存新增的或更新的数据到缓存，其中缓存[m
[31m-名称为people，数据的key是person的id。[m
[31m-[m
[31m-     ②@CacheEvict从缓存people中删除key为id的数据。[m
[31m-[m
[31m-     ③@Cacheable缓存key为person的id数据到缓存people中。[m
[31m-[m
[31m-     这里特别说明下，如果没有指定key，则方法参数作为key[m
[31m-保存到缓存中。[m
[31m-[m
[31m-     5.控制器[m
[31m-[m
[31m-       package com.wisely.ch8_5.web;[m
[31m-[m
[31m-       import org.springframework.beans.factory.annotation.Autowired;[m
[31m-       import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-       import org.springframework.web.bind.annotation.RestController;[m
[31m-[m
[31m-       import com.wisely.ch8_5.domain.Person;[m
[31m-       import com.wisely.ch8_5.service.DemoService;[m
[31m-[m
[31m-       @RestController[m
[31m-       public class CacheController {[m
[31m-[m
[31m-              @Autowired[m
[31m-              DemoService demoService;[m
[31m-[m
[31m-              @RequestMapping("/put")[m
[31m-              public Person put(Person person){[m
[31m-[m
[31m-                      return demoService.save(person);[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              @RequestMapping("/able")[m
[31m-              public Person cacheable(Person person){[m
[31m-[m
[31m-                      return demoService.findOne(person);[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              @RequestMapping("/evit")[m
[31m-              public String evit(Long id){[m
[31m-          demoService.remove(id);[m
[31m-          return "ok";[m
[31m-[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-6.开启缓存支持[m
[31m-[m
[31m-package com.wisely.ch8_5;[m
[31m-[m
[31m-import org.springframework.boot.SpringApplication;[m
[31m-import org.springframework.boot.autoconfigure.SpringBootApplication;[m
[31m-import org.springframework.cache.annotation.EnableCaching;[m
[31m-[m
[31m-@SpringBootApplication[m
[31m-@EnableCaching[m
[31m-public class Ch85Application {[m
[31m-[m
[31m-       public static void main(String[] args) {[m
[31m-              SpringApplication.run(Ch85Application.class, args);[m
[31m-[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     在Spring Boot中还是要使用@EnableCaching开启缓存支[m
[31m-持。[m
[31m-[m
[31m-     7.运行[m
[31m-[m
[31m-     当我们对数据做了缓存之后，数据的获得将从缓存中得[m
[31m-到，而不是从数据库中得到。当前的数据库的数据情况如图8-[m
[31m-56所示。[m
[31m-                          图8-56　当前数据库的数据情况[m
[31m-[m
[31m-     我们在每次运行测试情况下，都重启了应用程序。[m
[31m-     （1）测试@Cacheable[m
[31m-     第一次访问http://localhost：8080/able？id=1，第一次将调[m
[31m-用方法查询数据库，并将数据放到缓存people中。[m
[31m-     此时控制台输出如下：[m
[31m-[m
[31m-     页面输出如图8-57所示。[m
[31m-                                图8-57　页面输出结果[m
[31m-[m
[31m-     再次访问http://localhost：8080/able？id=1，此时控制台没[m
[31m-有再次输出Hibernate的查询语句，以及“为id、keywei：1数据[m
[31m-做了缓存”字样，表示没有调用这个方法，页面直接从数据缓[m
[31m-存中获得数据。[m
[31m-[m
[31m-     页面输出结果如图8-58所示。[m
[31m-[m
[31m-                                图8-58　页面输出结果[m
[31m-[m
[31m-     （2）测试@CachePut[m
[31m-     访问http://localhost：8080/put？name=cc&age=22&address=[m
[31m-成都，此时控制台输出如下：[m
[31m-[m
[31m-     页面输出如图8-59所示。[m
[31m-[m
[31m-                               图8-59　测试@CachePut[m
[31m-[m
[31m-     我们再次访问http://localhost：8080/able？id=62，控制台无[m
[31m-输出，从缓存直接获得数据，页面显示如图8-59所示。[m
[31m-[m
[31m-     （3）测试@CacheEvit[m
[31m-     访问http://localhost：8080/able？id=1，为id为1的数据做缓[m
[31m-存，再次访问http://localhost：8080/able？id=1，确认数据已从[m
[31m-缓存中获取。[m
[31m-     访问http://localhost：8080/evit？id=1，从缓存中删除key为[m
[31m-1的缓存数据：[m
[31m-     再次访问http://localhost：8080/able？id=1，观察控制台重[m
[31m-新做了缓存：[m
[31m-[m
[31m-页面显示如图8-58所示。[m
[31m-[m
[31m-8.5.4　切换缓存技术[m
[31m-[m
[31m-切换缓存技术除了移入相关依赖包或者配置以外，使用方[m
[31m-[m
[31m-式和实战例子保持一致。下面简要讲解在Spring                    Boot下，[m
[31m-[m
[31m-EhCache和Guava作为缓存技术的方式，其余缓存技术也是类[m
[31m-[m
[31m-似的方式。[m
[31m-[m
[31m-     1.EhCache[m
[31m-[m
[31m-     当我们需要使用EhCache作为缓存技术的时候，我们只需[m
[31m-在pom.xml中添加EhCache的依赖即可：[m
[31m-[m
[31m-<dependency>[m
[31m-         <groupId>net.sf.ehcache</groupId>[m
[31m-         <artifactId>ehcache</artifactId>[m
[31m-[m
[31m- </dependency>[m
[31m-[m
[31m-     EhCache所需的配置文件ehcache.xml只需放在类路径下，[m
[31m-Spring Boot会自动扫描，例如：[m
[31m-[m
[31m-       <?xml version="1.0" encoding="UTF-8"?>[m
[31m-       <ehcache>[m
[31m-[m
[31m-                      <cache name="people" maxElementsInMemory="1000" />[m
[31m-</ehcache>[m
[31m-[m
[31m-     Spring  Boot会给我们自动配置EhCacheCacheManager的[m
[31m-Bean。[m
[31m-[m
[31m-2.Guava[m
[31m-[m
[31m-     当我们需要使用Guava作为缓存技术的时候，我们也只需[m
[31m-在pom.xml中增加Guava的依赖即可：[m
[31m-[m
[31m-             <dependency>[m
[31m-                    <groupId>com.google.guava</groupId>[m
[31m-                    <artifactId>guava</artifactId>[m
[31m-                    <version>18.0</version>[m
[31m-[m
[31m-             </dependency>[m
[31m-[m
[31m-     Spring  Boot会给我们自动配置GuavaCacheManager这个[m
[31m-Bean。[m
[31m-[m
[31m-3.Redis[m
[31m-使用Redis，只需添加下面的依赖即可：[m
[31m-[m
[31m-              <dependency>[m
[31m-                     <groupId>org.springframework.boot</groupId>[m
[31m-                                                    <artifactId>spring-boot-starter-[m
[31m-[m
[31m-redis</artifactId>[m
[31m-              </dependency>[m
[31m-[m
[31m-     Spring Boot将会为我们自动配置RedisCacheManager以及[m
[31m-RedisTemplate的Bean。[m
[31m-8.6　非关系型数据库NoSQL[m
[31m-[m
[31m-     NoSQL是对于不使用关系作为数据管理的数据库系统的统[m
[31m-称。NoSQL的主要特点是不使用SQL语言作为查询语言，数据[m
[31m-存储也不是固定的表、字段。[m
[31m-[m
[31m-     NoSQL数据库主要有文档存储型（MongoDB）、图形关系[m
[31m-存储型（Neo4j）和键值对存储型（Redis）。[m
[31m-[m
[31m-     本节将演示基于MongoDB的数据访问以及基于Redis的数[m
[31m-据访问。[m
[31m-[m
[31m-8.6.1　MongoDB[m
[31m-[m
[31m-     MongoDB是一个基于文档（Document）的存储型的数据[m
[31m-库，使用面向对象的思想，每一条数据记录都是文档的对象。[m
[31m-[m
[31m-     在本节我们不会介绍太多关于MongoDB数据库本身的知[m
[31m-识，本节主要讲述Spring及Spring Boot对MongoDB的支持，以[m
[31m-及基于Spring Boot和MongoDB的实战例子。[m
[31m-[m
[31m-     1.Spring的支持[m
[31m-[m
[31m-     Spring对MongoDB的支持主要是通过Spring Data MongoDB[m
[31m-来实现的，Spring Data MongoDB为我们提供了如下功能。[m
[31m-[m
[31m-     （1）Object/Document映射注解支持[m
[31m-[m
[31m-     JPA提供了一套Object/Relation映射的注解（@Entity、[m
[31m-@Id），而Spring Data MongoDB也提供了表8-7所示的注解。[m
[31m-[m
[31m-                                       表8-7　注户[m
[31m-[m
[31m-     （2）MongoTemplate[m
[31m-     像JdbcTemplate一样，Spring Data MongoDB也为我们提供[m
[31m-了一个MongoTemplate，MongoTemplate为我们提供了数据访[m
[31m-问的方法。我们还需要为MongoClient以及MongoDbFactory来[m
[31m-配置数据库连接属性，例如：[m
[31m-[m
[31m-              @Bean[m
[31m-              public MongoClient client() throws UnknownHostException {[m
[31m-[m
[31m-                      MongoClient client = new MongoClient(new ServerAddress("127.0.0[m
[31m-                      return client;[m
[31m-              }[m
[31m-[m
[31m-              @Bean[m
[31m-              public MongoDbFactory mongoDbFactory() throws Exception {[m
[31m-[m
[31m-                      String database = new MongoClientURI("mongodb://localhost/test"[m
[31m-                      return new SimpleMongoDbFactory(client() , database);[m
[31m-              }[m
[31m-[m
[31m-              @Bean[m
[31m-              public MongoTemplate mongoTemplate(MongoDbFactory mongoDbFactory) t[m
[31m-[m
[31m-                      return new MongoTemplate(mongoDbFactory);[m
[31m-              }[m
[31m-[m
[31m-     （3）Repository的支持[m
[31m-     类似于Spring Data JPA，Spring Data MongoDB也提供了[m
[31m-Repository的支持，使用方式和Spring Data JPA一致，定义如[m
[31m-下：[m
[31m-[m
[31m-       public interface PersonRepository extends MongoRepository<Person, Strin[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     类似于Spring Data JPA的开启支持方式，MongoDB的[m
[31m-Repository的支持开启需在配置类上注解[m
[31m-@EnableMongoRepositories，例如：[m
[31m-[m
[31m-       @Configuration[m
[31m-       @EnableMongoRepositories[m
[31m-       public class AppConfig {[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-2.Spring Boot的支持[m
[31m-Spring Boot对MongoDB的支持，分别位于：[m
[31m-[m
[31m-org.springframework.boot.autoconfigure.mongo[m
[31m-[m
[31m-主要配置数据库连接、MongoTemplate。我们可以使用[m
[31m-[m
[31m-以“spring.data.mongodb”为前缀的属性来配置MongoDB相关的[m
[31m-[m
[31m-信息。Spring  Boot为我们提供了一些默认属性，如默认[m
[31m-[m
[31m-MongoDB的端口为27017、默认服务器为localhost、默认数据[m
[31m-[m
[31m-库为test。Spring Boot的主要配置如下：[m
[31m-       spring.data.mongodb.host= # 数据库主机地址，默认localhost[m
[31m-       spring.data.mongodb.port=27017 # 数据库连接端口默认27107[m
[31m-       spring.data.mongodb.uri=mongodb://localhost/test # connection URL[m
[31m-       spring.data.mongodb.database=[m
[31m-       spring.data.mongodb.authentication-database=[m
[31m-       spring.data.mongodb.grid-fs-database=[m
[31m-       spring.data.mongodb.username=[m
[31m-       spring.data.mongodb.password=[m
[31m-       spring.data.mongodb.repositories.enabled=true #repository支持[m
[31m-       是否开启，默认为已开启[m
[31m-       spring.data.mongodb.field-naming-strategy=[m
[31m-       org.springframework.boot.autoconfigure.data.mongo[m
[31m-[m
[31m-     为我们开启了对Repository的支持，即自动为我们配置了[m
[31m-@EnableMongoRepositories。[m
[31m-[m
[31m-     所以我们在Spring Boot下使用MongoDB只需引入spring-[m
[31m-boot-starter-data-mongodb依赖即可，无须任何配置。[m
[31m-[m
[31m-     3.实战[m
[31m-[m
[31m-     （1）安装MongoDB[m
[31m-[m
[31m-     1）非Docker安装。若不使用Docker作为安装方式，则我们[m
[31m-可以访问https://www.mongodb.org/downloads来下载适合自己[m
[31m-当前操作系统的版本来安装MongoDB。[m
[31m-[m
[31m-     2）Docker安装。前面已经下载好了MongoDB的Docker镜[m
[31m-像，接下来需通过下面命令运行Docker容器：[m
[31m-[m
[31m-       docker run -d -p 27017:27017 mongo[m
[31m-[m
[31m-     运行好以后，记得在VirtualBox再做一次端口映射，如图8-[m
[31m-60所示。[m
[31m-                                   图8-60　端口映射[m
[31m-[m
[31m-     MongoDB数据库管理软件可使用Robomongo，下载地址是[m
[31m-http://www.robomongo.org，如图8-61所示。[m
[31m-[m
[31m-          图8-61　Robomongo界面[m
[31m-[m
[31m-（2）搭建Spring Boot项目[m
[31m-[m
[31m-搭建Spring  Boot项目，依赖为MongoDB（spring-boot-[m
[31m-[m
[31m-starter-data-mongodb）和Web（spring-boot-starter-web）。[m
[31m-[m
[31m-项目信息：[m
[31m-groupId：com.wisely[m
[31m-arctifactId:ch8_6_1[m
[31m-package: com.wisely. ch8_6_1[m
[31m-[m
[31m-     因为Spring Boot的默认数据库连接满足我们当前测试的要[m
[31m-求，所以将不在为application.properties配置连接信息。[m
[31m-[m
[31m-     （3）领域模型[m
[31m-[m
[31m-     本例的领域模型是人（Person），包含他工作过的地点[m
[31m-（Location）。这个虽然和关系型数据库的一对多类似，但还[m
[31m-是不一样的，Location的数据只属于某个人。[m
[31m-[m
[31m-     Person源码：[m
[31m-[m
[31m-package com.wisely.ch8_6_1.domain;[m
[31m-[m
[31m-import java.util.Collection;[m
[31m-import java.util.LinkedHashSet;[m
[31m-[m
[31m-import org.springframework.data.annotation.Id;[m
[31m-import org.springframework.data.mongodb.core.mapping.Document;[m
[31m-[m
[31m-@Document //1                                     new LinkedHashSet<Locatio[m
[31m-public class Person {[m
[31m-[m
[31m-       @Id //2[m
[31m-       private String id;[m
[31m-       private String name;[m
[31m-       private Integer age;[m
[31m-       @Field("locs")//3[m
[31m-       private Collection<Location> locations =[m
[31m-();[m
[31m-[m
[31m-       public Person(String name, Integer age) {[m
[31m-              super();[m
[31m-              this.name = name;[m
[31m-              this.age = age;[m
[31m-[m
[31m-       }[m
[31m-//省略getter、setter方法[m
[31m-}[m
[31m-     代码解释[m
[31m-     ①@Document注解映射领域模型和MongoDB的文档。[m
[31m-     ②@Id注解表明这个属性为文档的Id。[m
[31m-     ③@Field注解此属性在文档中的名称为locs，locations属性[m
[31m-将以数组形式存在当前数据记录中。[m
[31m-     Location源码：[m
[31m-[m
[31m-       package com.wisely.ch8_6_1.domain;[m
[31m-       public class Location {[m
[31m-[m
[31m-              private String place;[m
[31m-              private String year;[m
[31m-              public Location(String place, String year) {[m
[31m-[m
[31m-                      super();[m
[31m-                      this.place = place;[m
[31m-                      this.year = year;[m
[31m-              }[m
[31m-       //省略getter、setter方法[m
[31m-       }[m
[31m-[m
[31m-     （4）数据访问：[m
[31m-[m
[31m-       package com.wisely.ch8_6_1.dao;[m
[31m-       import java.util.List;[m
[31m-       import org.springframework.data.mongodb.repository.MongoRepository;[m
[31m-       import org.springframework.data.mongodb.repository.Query;[m
[31m-       import com.wisely.ch8_6_1.domain.Person;[m
[31m-       public interface PersonRepository extends MongoRepository<Person, Strin[m
[31m-         Person findByName(String name); //1[m
[31m-[m
[31m-         @Query("{'age': ?0}") //2[m
[31m-         List<Person> withQueryFindByAge(Integer age);[m
[31m-[m
[31m-}[m
[31m-[m
[31m-代码解释[m
[31m-[m
[31m-①支持方法名查询。[m
[31m-[m
[31m-②支持@Query查询，查询参数构造JSON字符串即可。[m
[31m-[m
[31m-（5）控制器：[m
[31m-[m
[31m-package com.wisely.ch8_6_1.web;[m
[31m-[m
[31m-import java.util.Collection;[m
[31m-import java.util.LinkedHashSet;[m
[31m-import java.util.List;[m
[31m-import org.springframework.beans.factory.annotation.Autowired;[m
[31m-import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-import org.springframework.web.bind.annotation.RestController;[m
[31m-import com.wisely.ch8_6_1.dao.PersonRepository;[m
[31m-import com.wisely.ch8_6_1.domain.Location;[m
[31m-import com.wisely.ch8_6_1.domain.Person;[m
[31m-[m
[31m-@RestController[m
[31m-public class DataController {[m
[31m-[m
[31m-       @Autowired[m
[31m-       PersonRepository personRepository;[m
[31m-[m
[31m-       @RequestMapping("/save") //1[m
[31m-       public Person save(){[m
[31m-[m
[31m-              Person p = new Person("wyf",32);[m
[31m-              Collection<Location> locations = new LinkedHashSet<Location>[m
[31m-();[m
[31m-              Location loc1 = new Location("上海","2009");[m
[31m-              Location loc2 = new Location("合肥","2010");[m
[31m-              Location loc3 = new Location("广州","2011");[m
[31m-                      Location loc4 = new Location("马鞍山","2012");[m
[31m-                      locations.add(loc1);[m
[31m-                      locations.add(loc2);[m
[31m-                      locations.add(loc3);[m
[31m-                      locations.add(loc4);[m
[31m-                      p.setLocations(locations);[m
[31m-                      return personRepository.save(p);[m
[31m-              }[m
[31m-[m
[31m-              @RequestMapping("/q1") //2[m
[31m-              public Person q1(String name){[m
[31m-[m
[31m-                      return personRepository.findByName(name);[m
[31m-              }[m
[31m-[m
[31m-              @RequestMapping("/q2") //3[m
[31m-              public List<Person> q2(Integer age){[m
[31m-[m
[31m-                      return personRepository.withQueryFindByAge(age);[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①测试保存数据。[m
[31m-[m
[31m-     ②测试方法名查询。[m
[31m-[m
[31m-     ③测试@Query查询。[m
[31m-[m
[31m-     （6）运行[m
[31m-[m
[31m-     测试保存数据[m
[31m-[m
[31m-     访问http://localhost：8080/save测试保存，页面如图8-62所[m
[31m-示。[m
[31m-                                   图8-62　测试保存[m
[31m-[m
[31m-     我们可以在Robomongo中查看保存后的数据，如图8-63所[m
[31m-示。[m
[31m-[m
[31m-                             图8-63　查看保存后的数据[m
[31m-[m
[31m-     测试方法名查询[m
[31m-     访问http://localhost：8080/q1？name=wyf，页面结果如图8-[m
[31m-64所示。[m
[31m-     测试@Query查询[m
[31m-     访问http://localhost：8080/q2？age=32，页面结果如图8-65[m
[31m-所示。[m
[31m-                              图8-64　测试方法名查询[m
[31m-[m
[31m-                              图8-65　测试@Query查询[m
[31m-[m
[31m-8.6.2　Redis[m
[31m-[m
[31m-     Redis是一个基于键值对的开源内存数据存储，当然Redis[m
[31m-也可以做数据缓存（见8.5.4节）。[m
[31m-[m
[31m-     1.Spring的支持[m
[31m-     （1）配置[m
[31m-     Spring对Redis的支持也是通过Spring Data Redis来实现的，[m
[31m-Spring Data JPA为我们提供了连接相关的ConnectionFactory和[m
[31m-数据操作相关的RedisTemplate。在此特别指出，Spring Data[m
[31m-Redis只对Redis 2.6和2.8版本做过测试。[m
[31m-[m
[31m-     根据Redis的不同的Java客户端，Spring Data Redis提供了如[m
[31m-下的ConnectionFactory：[m
[31m-[m
[31m-     JedisConnectionFactory：使用Jedis作为Redis客户端。[m
[31m-[m
[31m-     JredisConnectionFactory：使用Jredis作为Redis客户端。[m
[31m-[m
[31m-     LettuceConnectionFactory：使用Lettuce作为Redis客户端。[m
[31m-[m
[31m-     SrpConnectionFactory：使用Spullara/redis-protocol作为[m
[31m-Redis客户端。[m
[31m-[m
[31m-     配置方式如下：[m
[31m-[m
[31m-             @Bean[m
[31m-              public RedisConnectionFactory redisConnectionFactory() {[m
[31m-                      return new JedisConnectionFactory();[m
[31m-              }[m
[31m-[m
[31m-     RedisTemplate配置方式如下：[m
[31m-[m
[31m-              @Bean[m
[31m-              public RedisTemplate<Object, Object> redisTemplate()throws UnknownH[m
[31m-[m
[31m-                      RedisTemplate<Object, Object> template = new RedisTemplate<Obje[m
[31m-       ();[m
[31m-[m
[31m-                      template.setConnectionFactory(redisConnectionFactory());[m
[31m-                      return template;[m
[31m-              }[m
[31m-     （2）使用[m
[31m-[m
[31m-     Spring Data Redis为我们提供了RedisTemplate和[m
[31m-StringRedisTemplate两个模板来进行数据操作，其中，[m
[31m-StringRedisTemplate只针对键值都是字符型的数据进行操作。[m
[31m-[m
[31m-     RedisTemplate和StringRedisTemplate提供的主要数据访问[m
[31m-方法如表8-8所示。[m
[31m-[m
[31m-                                 表8-8　数据访问方法[m
[31m-[m
[31m-     更多关于Spring Data Redis的操作，请查看Spring Data[m
[31m-Redis官方文档。[m
[31m-[m
[31m-（3）定义Serializer[m
[31m-[m
[31m-     当我们的数据存储到Redis的时候，我们的键（key）和值[m
[31m-（value）都是通过Spring提供的Serializer序列化到数据库的。[m
[31m-RedisTemplate默认使用的是JdkSerializationRedisSerializer，[m
[31m-StringRedisTemplate默认使用的是StringRedisSerializer。[m
[31m-[m
[31m-Spring Data JPA为我们提供了下面的Serializer：[m
[31m-[m
[31m-     GenericToStringSerializer、Jackson2JsonRedisSerializer、[m
[31m-JacksonJsonRedisSerializer、JdkSerializationRedisSerializer、[m
[31m-OxmSerializer、StringRedisSerializer。[m
[31m-[m
[31m-2.Spring Boot的支持[m
[31m-[m
[31m-Spring            Boot对Redis的支持，[m
[31m-org.springframework.boot.autoconfigure.redis包如图8-66所示。[m
[31m-[m
[31m-                                    图8-66　Redis包[m
[31m-[m
[31m-     RedisAutoConfiguration为我们默认配置了[m
[31m-JedisConnectionFactory、RedisTemplate以及[m
[31m-StringRedisTemplate，让我们可以直接使用Redis作为数据存[m
[31m-储。[m
[31m-[m
[31m-     RedisProperties向我们展示了可以使用以“spring.redis”为前[m
[31m-缀的属性在application.properties中配置Redis，主要属性如下：[m
[31m-[m
[31m-       spring.redis.database= 0# 数据库名称，默认为db0[m
[31m-       spring.redis.host=localhost #服务器地址，默认为localhostt[m
[31m-       spring.redis.password= # 数据库密码d[m
[31m-       spring.redis.port=6379 # 连接端口号，默认为6379[m
[31m-       spring.redis.pool.max-idle=8 # 连接池设置[m
[31m-       spring.redis.pool.min-idle=0[m
[31m-       spring.redis.pool.max-active=8[m
[31m-       spring.redis.pool.max-wait=-1[m
[31m-       spring.redis.sentinel.master=[m
[31m-       spring.redis.sentinel.nodes=[m
[31m-       spring.redis.timeout=[m
[31m-[m
[31m-     3.实战[m
[31m-[m
[31m-     （1）安装Redis[m
[31m-[m
[31m-     1）非Docker安装。若不基于Docker安装的话，我们可以到[m
[31m-http://redis.io/download下载合适版本的Redis。注意不要下载最[m
[31m-新版本的3.0.x版本。[m
[31m-     2）Docker安装。前面我们已经下载好了Redis镜像，通过[m
[31m-[m
[31m-下面命令运行容器：[m
[31m-[m
[31m-       docker run -d -p 6379:6379 redis:2.8.21[m
[31m-[m
[31m-     并在VirtualBox配置端口映射，如图8-67所示。[m
[31m-[m
[31m-图8-67　端口映射[m
[31m-[m
[31m-Redis数据管理可以使用Redis  Client，下载地址为[m
[31m-[m
[31m-https://github.com/caoxinyu/RedisClient，这是一个可以独立运[m
[31m-[m
[31m-行的jar包，如图8-68所示。[m
[31m-                                  图8-68　RedisClient[m
[31m-[m
[31m-     （2）新建Spring Boot项目[m
[31m-     搭建Spring Boot项目，依赖为Redis（spring-boot-starter-[m
[31m-redis）和Web（spring-boot-starter-web）。[m
[31m-     项目信息：[m
[31m-[m
[31m-       groupId：com.wisely[m
[31m-       arctifactId:ch8_6_2[m
[31m-       package: com.wisely. ch8_6_2[m
[31m-[m
[31m-     因为Spring Boot的默认数据库连接满足我们当前测试的要[m
[31m-求，所以无须不在application.properties配置连接信息。[m
[31m-[m
[31m-     （3）领域模型类：[m
[31m-[m
[31m-       package com.wisely.ch8_6_2.dao;[m
[31m-       import java.io.Serializable;[m
[31m-       public class Person implements Serializable{[m
[31m-[m
[31m-              private static final long serialVersionUID = 1L;[m
[31m-[m
[31m-              private String id;[m
[31m-              private String name;[m
[31m-              private Integer age;[m
[31m-[m
[31m-              public Person() {[m
[31m-                      super();[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              public Person(String id,String name, Integer age) {[m
[31m-                      super();[m
[31m-                      this.id = id;[m
[31m-                      this.name = name;[m
[31m-                      this.age = age;[m
[31m-[m
[31m-              }[m
[31m-       //省略getter、setter方法[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     此类必须用时间序列化接口，因为使用Jackson做序列化需[m
[31m-要一个空构造。[m
[31m-[m
[31m-     （4）数据访问：[m
[31m-[m
[31m-       package com.wisely.ch8_6_2.domain;[m
[31m-[m
[31m-       import javax.annotation.Resource;[m
[31m-[m
[31m-       import org.springframework.beans.factory.annotation.Autowired;[m
[31m-       import org.springframework.data.redis.core.RedisTemplate;[m
[31m-       import org.springframework.data.redis.core.StringRedisTemplate;[m
[31m-       import org.springframework.data.redis.core.ValueOperations;[m
[31m-       import org.springframework.stereotype.Repository;[m
[31m-[m
[31m-       import com.wisely.ch8_6_2.dao.Person;[m
[31m-[m
[31m-       @Repository[m
[31m-       public class PersonDao {[m
[31m-[m
[31m-              @Autowired[m
[31m-              StringRedisTemplate stringRedisTemplate; //1[m
[31m-[m
[31m-              @Resource(name="stringRedisTemplate")[m
[31m-              ValueOperations<String,String> valOpsStr; //3[m
[31m-[m
[31m-              @Autowired[m
[31m-              RedisTemplate<Object, Object> redisTemplate; //2[m
[31m-[m
[31m-              @Resource(name="redisTemplate")[m
[31m-              ValueOperations<Object, Object> valOps; //4[m
[31m-[m
[31m-              public void stringRedisTemplateDemo(){ //5[m
[31m-                      valOpsStr.set("xx", "yy");[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              public void save(Person person){[m
[31m-                      valOps.set(person.getId(),person); //6[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              public String getString(){[m
[31m-                      return valOpsStr.get("xx");//7[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              public Person getPerson(){[m
[31m-                      return (Person) valOps.get("1");//8[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①Spring Boot已为我们配置StringRedisTemplate，在此处可[m
[31m-以直接注入。[m
[31m-[m
[31m-     ②Spring Boot已为我们配置RedisTemplate，在此处可以直[m
[31m-接注入。[m
[31m-[m
[31m-     ③可以使用@Resource注解指定stringRedisTemplate，可注[m
[31m-入基于字符串的简单属性操作方法。[m
[31m-[m
[31m-     ④可以使用@Resource注解指定redisTemplate，可注入基于[m
[31m-对象的简单属性操作方法；[m
[31m-[m
[31m-⑤通过set方法，存储字符串类型。[m
[31m-[m
[31m-⑥通过set方法，存储对象类型。[m
[31m-[m
[31m-⑦通过get方法，获得字符串。[m
[31m-[m
[31m-⑧通过get方法，获得对象。[m
[31m-[m
[31m-（5）配置[m
[31m-[m
[31m-Spring     Boot为我们自动配置了RedisTemplate，而[m
[31m-[m
[31m-RedisTemplate使用的是JdkSerializationRedisSerializer，这个对[m
[31m-[m
[31m-我们演示Redis          Client很不直观，因为[m
[31m-[m
[31m-JdkSerializationRedisSerializer使用二级制形式存储数据，在此[m
[31m-[m
[31m-我们将自己配置RedisTemplate并定义Serializer。[m
[31m-[m
[31m-package com.wisely.ch8_6_2;[m
[31m-[m
[31m-import java.net.UnknownHostException;[m
[31m-[m
[31m-import org.springframework.boot.SpringApplication;[m
[31m-import org.springframework.boot.autoconfigure.SpringBootApplication;[m
[31m-import org.springframework.context.annotation.Bean;[m
[31m-import org.springframework.data.redis.connection.RedisConnectionFactory[m
[31m-import org.springframework.data.redis.core.RedisTemplate;[m
[31m-import org.springframework.data.redis.serializer.Jackson2JsonRedisSeria[m
[31m-import org.springframework.data.redis.serializer.StringRedisSerializer;[m
[31m-[m
[31m-import com.fasterxml.jackson.annotation.JsonAutoDetect;[m
[31m-import com.fasterxml.jackson.annotation.PropertyAccessor;[m
[31m-import com.fasterxml.jackson.databind.ObjectMapper;[m
[31m-[m
[31m-@SpringBootApplication[m
[31m-public class Ch862Application {[m
[31m-              public static void main(String[] args) {[m
[31m-                      SpringApplication.run(Ch862Application.class, args);[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              @Bean[m
[31m-              @SuppressWarnings({ "rawtypes", "unchecked" })[m
[31m-              public RedisTemplate<Object, Object> redisTemplate(RedisConnectionF[m
[31m-[m
[31m-                             throws UnknownHostException {[m
[31m-                      RedisTemplate<Object, Object> template = new RedisTemplate<Obje[m
[31m-       ();[m
[31m-                      template.setConnectionFactory(redisConnectionFactory);[m
[31m-[m
[31m-                      Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new J[m
[31m-                      ObjectMapper om = new ObjectMapper();[m
[31m-                      om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibilit[m
[31m-                      om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);[m
[31m-                      jackson2JsonRedisSerializer.setObjectMapper(om);[m
[31m-[m
[31m-                      template.setValueSerializer(jackson2JsonRedisSerializer); //1[m
[31m-                      template.setKeySerializer(new StringRedisSerializer()); //2[m
[31m-[m
[31m-                      template.afterPropertiesSet();[m
[31m-                      return template;[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①设置值（value）的序列化采用[m
[31m-Jackson2JsonRedisSerializer。[m
[31m-[m
[31m-     ②设置键（key）的序列化采用StringRedisSerializer。[m
[31m-[m
[31m-     （6）控制器：[m
[31m-[m
[31m-       package com.wisely.ch8_6_2.web;[m
[31m-[m
[31m-       import org.springframework.beans.factory.annotation.Autowired;[m
[31m-import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-import org.springframework.web.bind.annotation.RestController;[m
[31m-[m
[31m-import com.wisely.ch8_6_2.dao.Person;[m
[31m-import com.wisely.ch8_6_2.domain.PersonDao;[m
[31m-[m
[31m-@RestController[m
[31m-public class DataController {[m
[31m-[m
[31m-       @Autowired[m
[31m-       PersonDao personDao;[m
[31m-[m
[31m-       @RequestMapping("/set") //1[m
[31m-       public void set(){[m
[31m-[m
[31m-              Person person = new Person("1","wyf", 32);[m
[31m-              personDao.save(person);[m
[31m-              personDao.stringRedisTemplateDemo();[m
[31m-       }[m
[31m-[m
[31m-       @RequestMapping("/getStr") //2[m
[31m-       public String getStr(){[m
[31m-[m
[31m-              return personDao.getString();[m
[31m-       }[m
[31m-[m
[31m-       @RequestMapping("/getPerson") //3[m
[31m-       public Person getPerson(){[m
[31m-[m
[31m-              return personDao.getPerson();[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-代码解释[m
[31m-[m
[31m-①演示设置字符及对象。[m
[31m-[m
[31m-②演示获得字符。[m
[31m-[m
[31m-③演示获得对象。[m
[31m-[m
[31m-（7）运行[m
[31m-[m
[31m-演示设置字符及对象，访问http://localhost：8080/set，此时[m
[31m-查看Redis Client。[m
[31m-     字符存储如图8-69所示。[m
[31m-[m
[31m-                                   图8-69　字符存储[m
[31m-[m
[31m-     对象存储如图8-70所示。[m
[31m-[m
[31m-                                   图8-70　对象存储[m
[31m-[m
[31m-     演示获得字符，访问http://localhost：8080/getStr，页面显[m
[31m-示如图8-71所示。[m
[31m-                                   图8-71　获得字符[m
[31m-[m
[31m-     演示获得对象，访问http://localhost：8080/getPerson，页面[m
[31m-显示如图8-72所示。[m
[31m-[m
[31m-                                   图8-72　获得对象[m
[31m-第9章　Spring Boot企业级开发[m
[31m-[m
[31m-9.1　安全控制Spring Security[m
[31m-[m
[31m-9.1.1　Spring Security快速入门[m
[31m-[m
[31m-     1.什么是Spring Security[m
[31m-[m
[31m-     Spring Security是专门针对基于Spring的项目的安全框架，[m
[31m-充分利用了依赖注入和AOP来实现安全的功能。[m
[31m-[m
[31m-     在早期的Spring Security版本，使用Spring Security需要使[m
[31m-用大量的XML配置，而本节将全部基于Java配置来实现Spring[m
[31m-Security的功能。[m
[31m-[m
[31m-     安全框架有两个重要的概念，即认证（Authentication）和[m
[31m-授权（Authorization）。认证即确认用户可以访问当前系统；[m
[31m-授权即确定用户在当前系统下所拥有的功能权限，本节将围绕[m
[31m-认证和授权展开。[m
[31m-[m
[31m-     2.Spring Security的配置[m
[31m-[m
[31m-     （1）DelegatingFilterProxy[m
[31m-[m
[31m-     Spring Security为我们提供了一个多个过滤器来实现所有安[m
[31m-全的功能，我们只需注册一个特殊的DelegatingFilterProxy过滤[m
[31m-器到WebApplicationInitializer即可。[m
[31m-而在实际使用中，我们只需让自己的Initializer类继承[m
[31m-[m
[31m-AbstractSecurity  WebApplicationInitializer抽象类即可。[m
[31m-[m
[31m-AbstractSecurityWebApplicationInitializer实现了[m
[31m-[m
[31m-WebApplicationInitializer接口，并通过onStartup方法调用：[m
[31m-[m
[31m-insertSpringSecurityFilterChain(servletContext);[m
[31m-[m
[31m-     它为我们注册了DelegatingFilterProxy。[m
[31m-insertSpringSecurityFilterChain源码如下：[m
[31m-[m
[31m-              private void insertSpringSecurityFilterChain(ServletContext servlet[m
[31m-                      String filterName = DEFAULT_FILTER_NAME;[m
[31m-                      DelegatingFilterProxy springSecurityFilterChain = new Delegatin[m
[31m-                                    filterName);[m
[31m-                      String contextAttribute = getWebApplicationContextAttribute();[m
[31m-                      if (contextAttribute != null) {[m
[31m-                             springSecurityFilterChain.setContextAttribute(contextAttrib[m
[31m-                      }[m
[31m-                      registerFilter(servletContext, true, filterName, springSecurity[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-     所以我们只需用以下代码即可开启Spring Security的过滤器[m
[31m-支持：[m
[31m-[m
[31m-public class AppInitializer extends                Abstrac[m
[31m-}[m
[31m-[m
[31m-（2）配置[m
[31m-Spring Security的配置和Spring MVC的配置类似，只需在[m
[31m-一个配置类上注解@EnableWebSecurity，并让这个类继承[m
[31m-WebSecurityConfigurerAdapter即可。我们可以通过重写[m
[31m-configure方法来配置相关的安全配置。[m
[31m-[m
[31m-     代码如下：[m
[31m-[m
[31m-       @Configuration[m
[31m-       @EnableWebSecurity[m
[31m-       public class WebSecurityConfig extends WebSecurityConfigurerAdapter{[m
[31m-[m
[31m-              @Override[m
[31m-              protected void configure(HttpSecurity http) throws Exception {[m
[31m-[m
[31m-                      super.configure(http);[m
[31m-              }[m
[31m-[m
[31m-              @Override[m
[31m-              protected void configure(AuthenticationManagerBuilder auth) throws[m
[31m-[m
[31m-                      super.configure(auth);[m
[31m-              }[m
[31m-[m
[31m-              @Override[m
[31m-              public void configure(WebSecurity web) throws Exception {[m
[31m-[m
[31m-                      super.configure(web);[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     3.用户认证[m
[31m-[m
[31m-     认证需要我们有一套用户数据的来源，而授权则是对于某[m
[31m-个用户有相应的角色权限。在Spring Security里我们通过重写[m
[31m-[m
[31m-       protected void configure(AuthenticationManagerBuilder auth)[m
[31m-[m
[31m-     方法来实现定制。[m
[31m-     （1）内存中的用户[m
[31m-[m
[31m-     使用AuthenticationManagerBuilder的[m
[31m-inMemoryAuthentication方法即可添加在内存中的用户，并可[m
[31m-给用户指定角色权限[m
[31m-[m
[31m-       @Override[m
[31m-              protected void configure(AuthenticationManagerBuilder auth) throws[m
[31m-                      auth.inMemoryAuthentication()[m
[31m-                             .withUser("wyf").password("wyf").roles("ROLE_ADMIN")[m
[31m-                             .and()[m
[31m-                             .withUser("wisely").password("wisely").roles("ROLE_USER");[m
[31m-              }[m
[31m-[m
[31m-     （2）JDBC中的用户[m
[31m-[m
[31m-     JDBC中的用户直接指定dataSource即可。[m
[31m-[m
[31m-       @Autowired[m
[31m-              DataSource dataSource;[m
[31m-[m
[31m-              @Override[m
[31m-              protected void configure(AuthenticationManagerBuilder auth) throws[m
[31m-[m
[31m-                      auth.jdbcAuthentication().dataSource(dataSource);[m
[31m-              }[m
[31m-[m
[31m-     不过这看上去很奇怪，其实这里的Spring Security是默认了[m
[31m-你的数据库结构的。通过jdbcAuthentication的源码，我们可以[m
[31m-看出在JdbcDaoImpl中定义了默认的用户及角色权限获取的[m
[31m-SQL语句：[m
[31m-[m
[31m-       public static final String DEF_USERS_BY_USERNAME_QUERY = "select userna[m
[31m-                             + "from users " + "where username = ?";[m
[31m-[m
[31m-              public static final String DEF_AUTHORITIES_BY_USERNAME_QUERY = "sel[m
[31m-                             + "from authorities " + "where username = ?";[m
[31m-[m
[31m-     当然我们可以自定义我们的查询用户和权限的SQL语句，[m
[31m-例如：[m
[31m-[m
[31m-              @Override[m
[31m-              protected void configure(AuthenticationManagerBuilder auth) throws[m
[31m-[m
[31m-                      auth.jdbcAuthentication().dataSource(dataSource)[m
[31m-                             .usersByUsernameQuery("select username,password,true "[m
[31m-                                           + "from myusers where username = ?")[m
[31m-                             .authoritiesByUsernameQuery("select username,role "[m
[31m-                                           + "from roles where username = ?");[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-     （3）通用的用户[m
[31m-[m
[31m-     上面的两种用户和权限的获取方式只限于内存或者[m
[31m-JDBC，我们的数据访问方式可以是多种各样的，可以是非关[m
[31m-系型数据库，也可以是我们常用的JPA等。[m
[31m-[m
[31m-     这时我们需要自定义实现UserDetailsService接口。上面的[m
[31m-内存中用户及JDBC用户就是UserDetailsService的实现，定义[m
[31m-如下：[m
[31m-[m
[31m-       public class CustomUserService implements UserDetailsService {[m
[31m-              @Autowired[m
[31m-              SysUserRepository userRepository;[m
[31m-[m
[31m-              @Override[m
[31m-              public UserDetails loadUserByUsername(String username) throws Usern[m
[31m-[m
[31m-                      SysUser user = userRepository.findByUsername(username);[m
[31m-                      List<GrantedAuthority> authorities =new ArrayList<GrantedAuthor[m
[31m-       ();[m
[31m-                      authorities.add(new SimpleGrantedAuthority("ROLE_ADMIN"));[m
[31m-                      return new User(user.getUsername(),user.getPassword(),authoriti[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     说明：SysUser是我们系统的用户领域对象类，User来自于[m
[31m-org.springframework.security.core.userdetails.User。[m
[31m-[m
[31m-     除此之外，我们还需要注册这个CustomUserService，代码[m
[31m-如下：[m
[31m-[m
[31m-              @Bean[m
[31m-              UserDetailsService customUserService(){[m
[31m-[m
[31m-                      return new CustomUserService();[m
[31m-              }[m
[31m-              @Override[m
[31m-              protected void configure(AuthenticationManagerBuilder auth) throws[m
[31m-[m
[31m-                      auth.userDetailsService(customUserService());[m
[31m-              }[m
[31m-[m
[31m-     4.请求授权[m
[31m-     Spring Security是通过重写[m
[31m-[m
[31m-       protected void configure(HttpSecurity http)[m
[31m-[m
[31m-     方法来实现请求拦截的。[m
[31m-     Spring Security使用以下匹配器来匹配请求路径：[m
[31m-     antMatchers：使用Ant风格的路径匹配。[m
[31m-     regexMatchers：使用正则表达式匹配路径。[m
[31m-     anyRequest：匹配所有请求路径。[m
[31m-     在匹配了请求路径后，需要针对当前用户的信息对请求路[m
[31m-径进行安全处理，Spring Security提供了表9-1所示的安全处理[m
[31m-方法。[m
[31m-[m
[31m-                                 表9-1　安全处理方法[m
[31m-[m
[31m-     我们可以看一下下面的示例代码：[m
[31m-[m
[31m-              @Override[m
[31m-              protected void configure(HttpSecurity http) throws Exception {[m
[31m-[m
[31m-                      http[m
[31m-                      .authorizeRequests() //1[m
[31m-                      .antMatchers("/admin/**").hasRole("ROLE_ADMIN") //2[m
[31m-                      .antMatchers("/user/**").hasAnyRole("ROLE_ADMIN","ROLE_USER") /[m
[31m-                      .anyRequest().authenticated();//4[m
[31m-              }[m
[31m-[m
[31m-     代码解释[m
[31m-     ①通过authorizeRequests方法来开始请求权限配置。[m
[31m-     ②请求匹配/admin/**，只有拥有ROLE_ADMIN角色的用[m
[31m-户可以访问。[m
[31m-[m
[31m-     ③请求匹配/user/**，拥有ROLE_ADMIN或ROLE_USER角[m
[31m-色的用户都可访问。[m
[31m-[m
[31m-     ④其余所有的请求都需要认证后（登录后）才可访问。[m
[31m-[m
[31m-     5.定制登录行为[m
[31m-[m
[31m-     我们也可以通过重写[m
[31m-[m
[31m-       protected void configure(HttpSecurity http)[m
[31m-[m
[31m-     方法来定制我们的登录行为。[m
[31m-[m
[31m-     下面将重用的登录行为的定制以简短的代码演示：[m
[31m-[m
[31m-       @Override[m
[31m-              protected void configure(HttpSecurity http) throws Exception {[m
[31m-                      http[m
[31m-                             .formLogin() //1[m
[31m-                               .loginPage("/login") //2[m
[31m-                               .defaultSuccessUrl("/index") //3[m
[31m-                               .failureUrl("/login?error") //4[m
[31m-                               .permitAll()[m
[31m-                             .and()[m
[31m-                             .rememberMe() //5[m
[31m-                                    .tokenValiditySeconds(1209600) //6[m
[31m-                                    .key("myKey") //7[m
[31m-                             .and()[m
[31m-                             .logout()//8[m
[31m-                                    .logoutUrl("/custom-logout") //9[m
[31m-                                    .logoutSuccessUrl("/logout-success") //10[m
[31m-                                    .permitAll();[m
[31m-[m
[31m-              }[m
[31m-     代码解释[m
[31m-     ①通过formLogin方法定制登录操作。[m
[31m-     ②使用loginPage方法定制登录页面的访问地址。[m
[31m-     ③defaultSuccessUrl指定登录成功后转向的页面。[m
[31m-     ④failureUrl指定登录失败后转向的页面。[m
[31m-     ⑤rememberMe开启cookie存储用户信息。[m
[31m-     ⑥tokenValiditySeconds指定cookie有效期为1209600秒，即[m
[31m-2个星期。[m
[31m-     ⑦key指定cookie中的私钥。[m
[31m-     ⑧使用logout方法定制注销行为。[m
[31m-     ⑨logoutUrl指定注销的URL路径。[m
[31m-     ⑩logoutSuccessUrl指定注销成功后转向的页面。[m
[31m-[m
[31m-9.1.2　Spring Boot的支持[m
[31m-[m
[31m-Spring  Boot针对Spring  Security的自动配置在[m
[31m-[m
[31m-org.springframework.boot.autoconfigure.security包中。[m
[31m-[m
[31m-     主要通过SecurityAutoConfiguration和SecurityProperties来完[m
[31m-成配置。[m
[31m-[m
[31m-     SecurityAutoConfiguration导入了[m
[31m-SpringBootWebSecurityConfiguration中的配置。在[m
[31m-SpringBootWebSecurityConfiguration配置中，我们获得如下的[m
[31m-自动配置：[m
[31m-[m
[31m-     1）自动配置了一个内存中的用户，账号为user，密码在程[m
[31m-序启动时出现。[m
[31m-[m
[31m-     2）忽略/css/**、/js/**、/images/**和/**/favicon.ico等静态[m
[31m-文件的拦截。[m
[31m-[m
[31m-     3）自动配置的securityFilterChainRegistration的Bean。[m
[31m-[m
[31m-     SecurityProperties使用以“security”为前缀的属性配置Spring[m
[31m-Security相关的配置，包含：[m
[31m-[m
[31m-       security.user.name=user # 内存中的用户默认账号为user[m
[31m-       security.user.password= # l默认用户的密码[m
[31m-       security.user.role=USER # 默认用户的角色[m
[31m-       security.require-ssl=false # 是否需要ssl支持[m
[31m-       security.enable-csrf=false # 是否开启“跨站请求伪造”支持，默认关闭[m
[31m-       security.basic.enabled=true[m
[31m-       security.basic.realm=Spring[m
[31m-       security.basic.path= # /**[m
[31m-       security.basic.authorize-mode=[m
[31m-       security.filter-order=0[m
[31m-       security.headers.xss=false[m
[31m-       security.headers.cache=false[m
[31m-       security.headers.frame=false[m
[31m-       security.headers.content-type=false[m
[31m-       security.headers.hsts=all[m
[31m-       security.sessions=stateless[m
[31m-       security.ignored= # 用逗号隔开的无须拦截的路径[m
[31m-[m
[31m-     Spring Boot为我们做了如此多的配置，当我们需要自己扩[m
[31m-展的配置时，只需配置类继承WebSecurityConfigurerAdapter类[m
[31m-即可，无须使用@EnableWebSecurity注解，例如：[m
[31m-       @Configuration[m
[31m-       public class WebSecurityConfig extends WebSecurityConfigurerAdapter{[m
[31m-       }[m
[31m-[m
[31m-9.1.3　实战[m
[31m-[m
[31m-     在本节的示例中，我们将演示使用Spring Boot下的Spring[m
[31m-Security的配置，完成简单的认证授权的功能。此节我们将通[m
[31m-过Spring Data JPA获得用户数据。页面模板使用Thymeleaf，[m
[31m-Thymeleaf也为我们提供了支持Spring Security的标签。[m
[31m-[m
[31m-     1.新建Spring Boot项目[m
[31m-     新建Spring Boot项目，依赖为JPA（spring-boot-starter-data-[m
[31m-jpa）、Security（spring-boot-starter-security）、[m
[31m-Thymeleaf（spring-boot-starter-thymeleaf）。[m
[31m-     项目信息：[m
[31m-[m
[31m-       groupId：com.wisely[m
[31m-       arctifactId:ch9_1[m
[31m-       package: com.wisely. ch9_1[m
[31m-[m
[31m-     并添加Oracle驱动及Thymeleaf的Spring Security的支持。[m
[31m-[m
[31m-                      <dependency>[m
[31m-                             <groupId>com.oracle</groupId>[m
[31m-                             <artifactId>ojdbc6</artifactId>[m
[31m-                             <version>11.2.0.2.0</version>[m
[31m-[m
[31m-                      </dependency>[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.thymeleaf.extras</groupId>[m
[31m-                                                                 <artifactId>thymeleaf-extras-[m
[31m-[m
[31m-       springsecurity4</artifactId>[m
[31m-                      </dependency>[m
[31m-[m
[31m-     我们的application.properties配置如下：[m
[31m-[m
[31m-       spring.datasource.driverClassName=oracle.jdbc.OracleDriver[m
[31m-       spring.datasource.url=jdbc\:oracle\:thin\:@localhost\:1521\:xe[m
[31m-       spring.datasource.username=boot[m
[31m-       spring.datasource.password=boot[m
[31m-[m
[31m-       logging.level.org.springframework.security= INFO[m
[31m-[m
[31m-       spring.thymeleaf.cache=false[m
[31m-[m
[31m-       spring.jpa.hibernate.ddl-auto=update[m
[31m-       spring.jpa.show-sql=true[m
[31m-[m
[31m-     将bootstrap.min.css放置在src/main/resources/static/css下，此[m
[31m-路径默认不拦截。[m
[31m-[m
[31m-     2.用户和角色[m
[31m-     我们使用JPA来定义用户和角色。[m
[31m-     用户：[m
[31m-[m
[31m-       package com.wisely.ch9_1.domain;[m
[31m-[m
[31m-       import java.util.ArrayList;[m
[31m-       import java.util.Collection;[m
[31m-       import java.util.List;[m
[31m-[m
[31m-       import javax.persistence.CascadeType;[m
[31m-       import javax.persistence.Entity;[m
[31m-import javax.persistence.FetchType;[m
[31m-import javax.persistence.GeneratedValue;[m
[31m-import javax.persistence.Id;[m
[31m-import javax.persistence.ManyToMany;[m
[31m-[m
[31m-import org.springframework.security.core.GrantedAuthority;[m
[31m-import org.springframework.security.core.authority.SimpleGrantedAuthori[m
[31m-import org.springframework.security.core.userdetails.UserDetails;[m
[31m-@Entity[m
[31m-public class SysUser implements UserDetails{//1[m
[31m-[m
[31m-       private static final long serialVersionUID = 1L;[m
[31m-       @Id[m
[31m-       @GeneratedValue[m
[31m-       private Long id;[m
[31m-       private String username;[m
[31m-       private String password;[m
[31m-       @ManyToMany(cascade = {CascadeType.REFRESH},fetch = FetchType.EAGER[m
[31m-       private List<SysRole> roles;[m
[31m-[m
[31m-       @Override[m
[31m-       public Collection<? extends GrantedAuthority> getAuthorities() {//3[m
[31m-[m
[31m-              List<GrantedAuthority> auths = new ArrayList<GrantedAuthority>[m
[31m-();[m
[31m-[m
[31m-              List<SysRole> roles=this.getRoles();[m
[31m-              for(SysRole role:roles){[m
[31m-[m
[31m-                     auths.add(new SimpleGrantedAuthority(role.getName()));[m
[31m-              }[m
[31m-              return auths;[m
[31m-       }[m
[31m-       @Override[m
[31m-       public boolean isAccountNonExpired() {[m
[31m-              return true;[m
[31m-       }[m
[31m-       @Override[m
[31m-       public boolean isAccountNonLocked() {[m
[31m-              return true;[m
[31m-       }[m
[31m-       @Override[m
[31m-       public boolean isCredentialsNonExpired() {[m
[31m-              return true;[m
[31m-       }[m
[31m-       @Override[m
[31m-       public boolean isEnabled() {[m
[31m-              return true;[m
[31m-       }[m
[31m-       //省略getter、setter方法[m
[31m-}[m
[31m-     代码解释[m
[31m-[m
[31m-     ①让我们的用户实体实现UserDetails接口，我们的用户实[m
[31m-体即为Spring Security所使用的用户。[m
[31m-[m
[31m-     ②配置用户和角色的多对多关系。[m
[31m-[m
[31m-     ③重写getAuthorities方法，将用户的角色作为权限。[m
[31m-     角色：[m
[31m-[m
[31m-       package com.wisely.ch9_1.domain;[m
[31m-[m
[31m-       import javax.persistence.Entity;[m
[31m-       import javax.persistence.GeneratedValue;[m
[31m-       import javax.persistence.Id;[m
[31m-[m
[31m-       @Entity[m
[31m-       public class SysRole {[m
[31m-[m
[31m-              @Id[m
[31m-              @GeneratedValue[m
[31m-              private Long id;[m
[31m-              private String name; //1[m
[31m-              //省略getter、setter方法[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①name为角色名称。[m
[31m-     （1）数据结构及初始化[m
[31m-     当我们配置用户和角色的多对多关系后，通过设置[m
[31m-       spring.jpa.hibernate.ddl-auto=update[m
[31m-[m
[31m-     为我们自动生成用户表：SYS_USER、角色表：[m
[31m-SYS_ROLE、关联表：SYS_USER_ROLES。[m
[31m-[m
[31m-     针对上面的表结构，我们初始化一些数据来方便我们演[m
[31m-示。在src/main/resources下，新建data.sql，即新建两个用户，[m
[31m-角色分别为ROLE_ADMIN和ROLE_USER，代码如下：[m
[31m-[m
[31m-       insert into SYS_USER (id,username, password) values (1,'wyf', 'wyf');[m
[31m-       insert into SYS_USER (id,username, password) values (2,'wisely', 'wisel[m
[31m-[m
[31m-       insert into SYS_ROLE(id,name) values(1,'ROLE_ADMIN');[m
[31m-       insert into SYS_ROLE(id,name) values(2,'ROLE_USER');[m
[31m-[m
[31m-       insert into SYS_USER_ROLES(SYS_USER_ID,ROLES_ID) values(1,1);[m
[31m-       insert into SYS_USER_ROLES(SYS_USER_ID,ROLES_ID) values(2,2);[m
[31m-[m
[31m-     （2）传值对象[m
[31m-[m
[31m-     用来测试不同角色用户的数据展示：[m
[31m-[m
[31m-       package com.wisely.ch9_1.domain;[m
[31m-[m
[31m-       public class Msg {[m
[31m-              private String title;[m
[31m-              private String content;[m
[31m-              private String etraInfo;[m
[31m-              public Msg(String title, String content, String etraInfo) {[m
[31m-                      super();[m
[31m-                      this.title = title;[m
[31m-                      this.content = content;[m
[31m-                      this.etraInfo = etraInfo;[m
[31m-              }[m
[31m-              //省略getter、setter方法[m
[31m-[m
[31m-       }[m
[31m-3.数据访问[m
[31m-我们这里的数据访问很简单，代码如下：[m
[31m-[m
[31m-package com.wisely.ch9_1.dao;[m
[31m-import org.springframework.data.jpa.repository.JpaRepository;[m
[31m-import com.wisely.ch9_1.domain.SysUser;[m
[31m-public interface SysUserRepository extends JpaRepository<SysUser, Long>[m
[31m-{[m
[31m-[m
[31m-       SysUser findByUsername(String username);[m
[31m-}[m
[31m-[m
[31m-代码解释[m
[31m-这里只需一个根据用户名查出用户的方法。[m
[31m-4.自定义UserDetailsService[m
[31m-[m
[31m-package com.wisely.ch9_1.security;[m
[31m-import org.springframework.beans.factory.annotation.Autowired;[m
[31m-import org.springframework.security.core.userdetails.UserDetails;[m
[31m-import org.springframework.security.core.userdetails.UserDetailsService[m
[31m-import org.springframework.security.core.userdetails.UsernameNotFoundEx[m
[31m-import com.wisely.ch9_1.dao.SysUserRepository;[m
[31m-import com.wisely.ch9_1.domain.SysUser;[m
[31m-public class CustomUserService implements UserDetailsService { //1[m
[31m-[m
[31m-       @Autowired[m
[31m-       SysUserRepository userRepository;[m
[31m-       @Override[m
[31m-       public UserDetails loadUserByUsername(String username) { //2[m
[31m-在");      SysUser user = userRepository.findByUsername(username);[m
[31m-          if(user == null){[m
[31m-       }[m
[31m-}                     throw new UsernameNotFoundException("用户名不存[m
[31m-[m
[31m-          }[m
[31m-[m
[31m-          return user; //3[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①自定义需实现UserDetailsService接口。[m
[31m-[m
[31m-     ②重写loadUserByUsername方法获得用户。[m
[31m-[m
[31m-     ③我们当前的用户实现了UserDetails接口，可直接返回给[m
[31m-Spring Security使用。[m
[31m-[m
[31m-     5.配置[m
[31m-[m
[31m-     （1）Spring MVC配置：[m
[31m-[m
[31m-       package com.wisely.ch9_1.config;[m
[31m-[m
[31m-       import org.springframework.context.annotation.Configuration;[m
[31m-       import org.springframework.web.servlet.config.annotation.ViewController[m
[31m-       import org.springframework.web.servlet.config.annotation.WebMvcConfigur[m
[31m-[m
[31m-       @Configuration[m
[31m-       public class WebMvcConfig extends WebMvcConfigurerAdapter{[m
[31m-[m
[31m-              @Override[m
[31m-              public void addViewControllers(ViewControllerRegistry registry) {[m
[31m-[m
[31m-                      registry.addViewController("/login").setViewName("login");[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-代码解释[m
[31m-[m
[31m-注册访问/login转向login.html页面。[m
[31m-[m
[31m-（2）Spring Security配置：[m
[31m-[m
[31m-package com.wisely.ch9_1.config;[m
[31m-[m
[31m-import org.springframework.context.annotation.Bean;[m
[31m-import org.springframework.context.annotation.Configuration;[m
[31m-import org.springframework.security.config.annotation.authentication.bu[m
[31m-import org.springframework.security.config.annotation.web.builders.Http[m
[31m-import org.springframework.security.config.annotation.web.configuration[m
[31m-import org.springframework.security.core.userdetails.UserDetailsService[m
[31m-import com.wisely.ch9_1.security.CustomUserService;[m
[31m-[m
[31m-@Configuration[m
[31m-public class WebSecurityConfig extends WebSecurityConfigurerAdapter{//1[m
[31m-[m
[31m-       @Bean[m
[31m-       UserDetailsService customUserService(){ //2[m
[31m-[m
[31m-              return new CustomUserService();[m
[31m-       }[m
[31m-[m
[31m-       @Override[m
[31m-       protected void configure(AuthenticationManagerBuilder auth) throws[m
[31m-[m
[31m-              auth.userDetailsService(customUserService()); //3[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-       @Override[m
[31m-       protected void configure(HttpSecurity http) throws Exception {[m
[31m-[m
[31m-              http.authorizeRequests()[m
[31m-                                           .anyRequest().authenticated() //4[m
[31m-                                           .and()[m
[31m-                                           .formLogin()[m
[31m-                                                  .loginPage("/login")[m
[31m-                                                  .failureUrl("/login?error")[m
[31m-                                                  .permitAll() //5[m
[31m-                                           .and()[m
[31m-                                           .logout().permitAll(); //6[m
[31m-[m
[31m-       }[m
[31m-}[m
[31m-代码解释[m
[31m-[m
[31m-     ①扩展Spring                 Security配置需继承[m
[31m-WebSecurityConfigurerAdapter。[m
[31m-[m
[31m-②注册CustomUserService的Bean。[m
[31m-[m
[31m-③添加我们自定义的user detail service认证。[m
[31m-[m
[31m-④所有请求需要认证即登录后才能访问。[m
[31m-[m
[31m-⑤定制登录行为，登录页面可任意访问。[m
[31m-[m
[31m-⑥定制注销行为，注销请求可任意访问。[m
[31m-[m
[31m-6.页面[m
[31m-[m
[31m-（1）登录页面：[m
[31m-[m
[31m-<!DOCTYPE html>[m
[31m-<html xmlns:th="http://www.thymeleaf.org">[m
[31m-<head>[m
[31m-<meta content="text/html;charset=UTF-8"/>[m
[31m-<title>登录页面</title>[m
[31m-<link rel="stylesheet" th:href="@{css/bootstap.min.css}"/>[m
[31m-<style type="text/css">[m
[31m-[m
[31m-       body {[m
[31m-   padding-top: 50px;[m
[31m-}[m
[31m-.starter-template {[m
[31m-   padding: 40px 15px;[m
[31m-   text-align: center;[m
[31m-}[m
[31m-</style>[m
[31m-</head>[m
[31m-<body>[m
[31m-[m
[31m-         <nav class="navbar navbar-inverse navbar-fixed-top">[m
[31m-          <div class="container">[m
[31m-              <div class="navbar-header">[m
[31m-示</a>       <a class="navbar-brand" href="#">Spring Security演[m
[31m-[m
[31m-       </div>[m
[31m-       <div id="navbar" class="collapse navbar-collapse">[m
[31m-[m
[31m-          <ul class="nav navbar-nav">[m
[31m-            <li><a th:href="@{/}"> 首页 </a></li>[m
[31m-[m
[31m-          </ul>[m
[31m-       </div><!--/.nav[m
[31m-[m
[31m--collapse -->[m
[31m-          </div>[m
[31m-[m
[31m-       </nav>[m
[31m-         <div class="container">[m
[31m-[m
[31m-          <div class="starter-template">[m
[31m-                 <p th:if="${param.logout}" class="bg-warning">已成功[m
[31m-[m
[31m-注销</p><!-- 1 -->[m
[31m-               <p th:if="${param.error}" class="bg-danger">有错误，请[m
[31m-[m
[31m-重试</p> <!-- 2 -->[m
[31m-                     <h2>使用账号密码登录</h2>[m
[31m-                     <form name="form" th:action="@{/login}" action="/login" met[m
[31m-[m
[31m-- 3 -->[m
[31m-                             <div class="form-group">[m
[31m-                                    <label for="username">账号</label>[m
[31m-                                                    <input type="text" class="form-[m
[31m-[m
[31m-control" name="username" value="" placeholder="账号" />[m
[31m-                             </div>[m
[31m-                             <div class="form-group">[m
[31m-                                    <label for="password">密码</label>[m
[31m-                                             <input type="password" class="form-[m
[31m-[m
[31m-control" name="password" placeholder="密码" />[m
[31m-                             </div>[m
[31m-                             <input type="submit" id="login" value="Login" class="bt[m
[31m-[m
[31m-primary" />[m
[31m-                     </form>[m
[31m-[m
[31m-          </div>[m
[31m-       </div>[m
[31m-</body>[m
[31m-</html>[m
[31m-代码解释[m
[31m-[m
[31m-①注销成功后显示。[m
[31m-[m
[31m-②登录有错误时显示。[m
[31m-[m
[31m-③默认的登录路径为/login。[m
[31m-[m
[31m-（2）首页：[m
[31m-[m
[31m-<!DOCTYPE html>[m
[31m-<html xmlns:th="http://www.thymeleaf.org"[m
[31m-[m
[31m-              xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-[m
[31m-springsecurity4"><!-- 1 -->[m
[31m-<head>[m
[31m-<meta content="text/html;charset=UTF-8"/>[m
[31m-<title sec:authentication="name"></title> <!-- 2 -->[m
[31m-<link rel="stylesheet" th:href="@{css/bootstrap.min.css}" />[m
[31m-<style type="text/css">[m
[31m-body {[m
[31m-[m
[31m-   padding-top: 50px;[m
[31m-}[m
[31m-.starter-template {[m
[31m-[m
[31m-   padding: 40px 15px;[m
[31m-   text-align: center;[m
[31m-}[m
[31m-</style>[m
[31m-</head>[m
[31m-<body>[m
[31m-[m
[31m-         <nav class="navbar navbar-inverse navbar-fixed-top">[m
[31m-          <div class="container">[m
[31m-              <div class="navbar-header">[m
[31m-                   <a class="navbar-brand" href="#">Spring Security演[m
[31m-[m
[31m-示</a>[m
[31m-              </div>[m
[31m-              <div id="navbar" class="collapse navbar-collapse">[m
[31m-                  <ul class="nav navbar-nav">[m
[31m-                   <li><a th:href="@{/}"> 首页 </a></li>[m
[31m-[m
[31m-                  </ul>[m
[31m-              </div><!--/.nav[m
[31m--collapse -->[m
[31m-          </div>[m
[31m-[m
[31m-       </nav>[m
[31m-[m
[31m-      <div class="container">[m
[31m-[m
[31m-      <div class="starter-template">[m
[31m-           <h1 th:text="${msg.title}"></h1>[m
[31m-[m
[31m-      <p class="bg-primary" th:text="${msg.content}"></p>[m
[31m-[m
[31m-->     <div sec:authorize="hasRole('ROLE_ADMIN')"> <!-- 3 -[m
[31m-</p>               <p class="bg-info" th:text="${msg.etraInfo}">[m
[31m-[m
[31m-      </div>[m
[31m-[m
[31m-                <div sec:authorize="hasRole('ROLE_USER')"> <!-- 4--[m
[31m-[m
[31m->[m
[31m-                     <p class="bg-info">无更多信息显示</p>[m
[31m-[m
[31m-              </div>[m
[31m-[m
[31m-              <form th:action="@{/logout}" method="post">               btn-[m
[31m-[m
[31m-                                       <input type="submit" class="btn[m
[31m-primary" value="注销"/><!-- 5 -->[m
[31m-[m
[31m-              </form>[m
[31m-[m
[31m-          </div>[m
[31m-[m
[31m-       </div>[m
[31m-</body>[m
[31m-</html>[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①Thymeleaf为我们提供的Spring Security的标签支持。[m
[31m-[m
[31m-     ②通过sec：authentication="name"获得当前用户的用户[m
[31m-名。[m
[31m-     ③sec：authorize="hasRole（'ROLE_ADMIN'）"意味着只[m
[31m-有当前用户觉得为ROLE_ADMIN时，才可显示标签内内容。[m
[31m-[m
[31m-     ④sec：authorize="hasRole（'ROLE_USER'）"意味着只有[m
[31m-当前用户觉得为ROLE_USER时，才可显示标签内内容。[m
[31m-[m
[31m-     ⑤注销的默认路径为/logout，需通过POST请求提交。[m
[31m-[m
[31m-     7.控制器[m
[31m-[m
[31m-     此控制器很简单，只为首页显示准备数据：[m
[31m-[m
[31m-       package com.wisely.ch9_1.web;[m
[31m-[m
[31m-       import org.springframework.stereotype.Controller;[m
[31m-       import org.springframework.ui.Model;[m
[31m-       import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-[m
[31m-       import com.wisely.ch9_1.domain.Msg;[m
[31m-[m
[31m-       @Controller[m
[31m-       public class HomeController {[m
[31m-[m
[31m-              @RequestMapping("/")[m
[31m-              public String index(Model model){[m
[31m-[m
[31m-                      Msg msg = new Msg("测试标题","测试内容","额外信息，只对管[m
[31m-       理员显示");[m
[31m-[m
[31m-                      model.addAttribute("msg", msg);[m
[31m-                      return "home";[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     8.运行[m
[31m-[m
[31m-     （1）登录。访问http://localhost：8080，将会自动转到登[m
[31m-录页面http://localhost：8080/login，如图9-1所示。[m
[31m-         图9-1　转到登录页面http://localhost：8080/login[m
[31m-[m
[31m-使用正确的账号密码登录，如图9-2所示。[m
[31m-[m
[31m-                   图9-2　使用正确的账号密码登录[m
[31m-[m
[31m-使用错误的账号密码登录，如图9-3所示。[m
[31m-                   图9-3　使用错误的账号密码登录[m
[31m-[m
[31m-（2）注销。登录成功后，单击注销按钮，如图9-4所示。[m
[31m-[m
[31m-                           图9-4　单击注销按钮[m
[31m-[m
[31m-此时页面显示如图9-5所示。[m
[31m-                           图9-5　单击注销按钮[m
[31m-[m
[31m-（3）用户信息[m
[31m-页面上我们将用户名显示在页面的标题上，如图9-6所示。[m
[31m-[m
[31m-                              图9-6　用户信息[m
[31m-[m
[31m-（4）视图控制[m
[31m-wyf和wisely用户角色不同，因此获得不同的视图。[m
[31m-wyf用户视图如图9-7所示。[m
[31m-                           图9-7　wyf用户视图[m
[31m-[m
[31m-wisely用户视图如图9-8所示。[m
[31m-[m
[31m-                          图9-8　wisely用户视图[m
[31m-9.2　批处理Spring Batch[m
[31m-[m
[31m-9.2.1　Spring Batch快速入门[m
[31m-[m
[31m-     1.什么是Spring Batch[m
[31m-     Spring Batch是用来处理大量数据操作的一个框架，主要用[m
[31m-来读取大量数据，然后进行一定处理后输出成指定的形式。[m
[31m-     2.Spring Batch主要组成[m
[31m-     SpringBatch主要由以下几部分组成，如表9-2所示。[m
[31m-[m
[31m-                            表9-2　SpringBatch组成部分[m
[31m-[m
[31m-     以上Spring Batch的主要组成部分只需注册成Spring的Bean[m
[31m-即可。若想开启批处理的支持还需在配置类上使用[m
[31m-@EnableBatchProcessing。[m
[31m-[m
[31m-     一个示意的Spring Batch的配置如下：[m
[31m-[m
[31m-       @Configuration[m
[31m-       @EnableBatchProcessing[m
[31m-       public class BatchConfig {[m
[31m-@Bean[m
[31m-public JobRepository jobRepository(DataSource dataSource, PlatformT[m
[31m-[m
[31m-              throws Exception {[m
[31m-       JobRepositoryFactoryBean jobRepositoryFactoryBean = new JobRepo[m
[31m-       jobRepositoryFactoryBean.setDataSource(dataSource);[m
[31m-       jobRepositoryFactoryBean.setTransactionManager(transactionManag[m
[31m-       jobRepositoryFactoryBean.setDatabaseType("oracle");[m
[31m-       return jobRepositoryFactoryBean.getObject();[m
[31m-}[m
[31m-[m
[31m-@Bean[m
[31m-public SimpleJobLauncher jobLauncher(DataSource dataSource, Platfor[m
[31m-[m
[31m-              throws Exception {[m
[31m-       SimpleJobLauncher jobLauncher = new SimpleJobLauncher();[m
[31m-       jobLauncher.setJobRepository(jobRepository(dataSource, transact[m
[31m-       return jobLauncher;[m
[31m-}[m
[31m-[m
[31m-@Bean[m
[31m-public Job importJob(JobBuilderFactory jobs, Step s1) {[m
[31m-[m
[31m-       return jobs.get("importJob")[m
[31m-                     .incrementer(new RunIdIncrementer())[m
[31m-                     .flow(s1)[m
[31m-                     .end()[m
[31m-                     .build();[m
[31m-[m
[31m-}[m
[31m-[m
[31m-@Bean[m
[31m-public Step step1(StepBuilderFactory stepBuilderFactory, ItemReader[m
[31m-[m
[31m-              ItemProcessor<Person,Person> processor) {[m
[31m-       return stepBuilderFactory[m
[31m-[m
[31m-                     .get("step1")[m
[31m-                     .<Person, Person>chunk(65000)[m
[31m-                     .reader(reader)[m
[31m-                     .processor(processor)[m
[31m-                     .writer(writer)[m
[31m-                     .build();[m
[31m-}[m
[31m-[m
[31m-@Bean[m
[31m-public ItemReader<Person> reader() throws Exception {[m
[31m-[m
[31m-              //新建ItemReader接口的实现类返回[m
[31m-              return reader;[m
[31m-}[m
[31m-[m
[31m-@Bean[m
[31m-public ItemProcessor<Person, Person> processor() {[m
[31m-[m
[31m-       //新建ItemProcessor接口的实现类返回[m
[31m-                      return processor;[m
[31m-              }[m
[31m-[m
[31m-              @Bean[m
[31m-              public ItemWriter<Person> writer(DataSource dataSource) {[m
[31m-[m
[31m-                      //新建ItemWriter接口的实现类返回[m
[31m-                      return writer;[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     3.Job监听[m
[31m-[m
[31m-     若需要监听我们的Job的执行情况，则定义个一个类实现[m
[31m-JobExecutionListener，并在定义Job的Bean上绑定该监听器。[m
[31m-[m
[31m-     监听器的定义如下：[m
[31m-[m
[31m-       public class MyJobListener implements JobExecutionListener{[m
[31m-[m
[31m-              @Override[m
[31m-              public void beforeJob(JobExecution jobExecution) {[m
[31m-              //Job开始前[m
[31m-              }[m
[31m-[m
[31m-              @Override[m
[31m-              public void afterJob(JobExecution jobExecution) {[m
[31m-              //Job完成后[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     注册并绑定监听器到Job：[m
[31m-[m
[31m-              @Bean[m
[31m-              public Job importJob(JobBuilderFactory jobs, Step s1) {[m
[31m-[m
[31m-                      return jobs.get("importJob")[m
[31m-                                    .incrementer(new RunIdIncrementer())[m
[31m-                                    .flow(s1)[m
[31m-                                    .end()[m
[31m-                                    .listener(csvJobListener())[m
[31m-                                    .build();[m
[31m-              }[m
[31m-[m
[31m-              @Bean[m
[31m-              public MyJobListener myJobListener() {[m
[31m-[m
[31m-                      return new MyJobListener();[m
[31m-              }[m
[31m-[m
[31m-     4.数据读取[m
[31m-[m
[31m-     Spring Batch为我们提供了大量的ItemReader的实现，用来[m
[31m-读取不同的数据来源，如图9-9所示。[m
[31m-[m
[31m-     5.数据处理及校验[m
[31m-[m
[31m-     数据处理和校验都要通过ItemProcessor接口实现来完成。[m
[31m-[m
[31m-     （1）数据处理[m
[31m-[m
[31m-     数据处理只需实现ItemProcessor接口，重写其process方[m
[31m-法。方法输入的参数是从ItemReader读取到的数据，返回的数[m
[31m-据给ItemWriter。[m
[31m-                       图9-9　大量ItemReader实现[m
[31m-[m
[31m-public class MyItemProcessor implements ItemProcessor<Person, Person> {[m
[31m-[m
[31m-       @Override[m
[31m-       public Person process(Person person){[m
[31m-[m
[31m-                String name = person.getName().toUpperCase();[m
[31m-                person.setName(name);[m
[31m-                return person;[m
[31m-       }[m
[31m-[m
[31m-}[m
[31m-     （2）数据校验[m
[31m-[m
[31m-     我们可以JSR-303（主要实现有hibernate-validator）的注[m
[31m-解，来校验ItemReader读取到的数据是否满足要求。[m
[31m-[m
[31m-     我们可以让我们的ItemProcessor实现[m
[31m-ValidatingItemProcessor接口：[m
[31m-[m
[31m-       public class MyItemProcessor extends ValidatingItemProcessor<Person>[m
[31m-       {[m
[31m-[m
[31m-              @Override[m
[31m-              public Person process(Person item) throws ValidationException {[m
[31m-[m
[31m-                      super.process(item);[m
[31m-                      return item;[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     定义我们的校验器，实现的Validator接口来自于Spring，[m
[31m-我们将使用JSR-303的Validator来校验：[m
[31m-[m
[31m-       public class MyBeanValidator<T> implements Validator<T>,InitializingBea[m
[31m-              private javax.validation.Validator validator;[m
[31m-              @Override[m
[31m-              public void afterPropertiesSet() throws Exception {[m
[31m-                      ValidatorFactory validatorFactory = Validation.buildDefaultVali[m
[31m-                      validator = validatorFactory.usingContext().getValidator();[m
[31m-              }[m
[31m-              @Override[m
[31m-              public void validate(T value) throws ValidationException {[m
[31m-                      Set<ConstraintViolation<T>> constraintViolations = validator.va[m
[31m-                      if(constraintViolations.size()>0){[m
[31m-[m
[31m-                             StringBuilder message = new StringBuilder();[m
[31m-                             for (ConstraintViolation<T> constraintViolation : constrain[m
[31m-[m
[31m-                                    message.append(constraintViolation.getMessage() + "\n")[m
[31m-                             }[m
[31m-                             throw new ValidationException(message.toString());[m
[31m-                      }[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     在定义我们的MyItemProcessor时必须将MyBeanValidator设[m
[31m-置进去，代码如下：[m
[31m-[m
[31m-              @Bean[m
[31m-              public ItemProcessor<Person, Person> processor() {[m
[31m-[m
[31m-                      MyItemProcessor processor = new MyItemProcessor();[m
[31m-                      processor.setValidator(myBeanValidator());[m
[31m-                      return processor;[m
[31m-              }[m
[31m-[m
[31m-              @Bean[m
[31m-              public Validator<Person> myBeanValidator() {[m
[31m-[m
[31m-                      return new MyBeanValidator<Person>();[m
[31m-              }[m
[31m-[m
[31m-     6.数据输出[m
[31m-[m
[31m-     Spring Batch为我们提供了大量的ItemWriter的实现，用来[m
[31m-将数据输出到不同的目的地，如图9-11所示。[m
[31m-[m
[31m-     7.计划任务[m
[31m-[m
[31m-     Spring Batch的任务是通过JobLauncher的run方法来执行[m
[31m-的，因此我们只需在普通的计划任务方法中执行JobLauncher[m
[31m-的run方法即可。[m
[31m-[m
[31m-     演示代码如下，别忘了配置类使用@EnableScheduling开启[m
[31m-计划任务支持：[m
[31m-[m
[31m-       @Service[m
[31m-public class ScheduledTaskService {[m
[31m-       @Autowired[m
[31m-       JobLauncher jobLauncher;[m
[31m-[m
[31m-       @Autowired[m
[31m-       Job importJob;[m
[31m-[m
[31m-       public JobParameters jobParameters;[m
[31m-       @Scheduled(fixedRate = 5000)[m
[31m-       public void execute() throws Exception {[m
[31m-[m
[31m-              jobParameters = new JobParametersBuilder()[m
[31m-                             .addLong("time", System.currentTimeMillis()).toJobParam[m
[31m-[m
[31m-                  jobLauncher.run(importJob,jobParameters);[m
[31m-       }[m
[31m-[m
[31m-}[m
[31m-[m
[31m-          图9-10　数据输出[m
[31m-[m
[31m-8.参数后置绑定[m
[31m-     我们在ItemReader和ItemWriter的Bean定义的时候，参数已[m
[31m-经硬编码在Bean的初始化中，代码如下：[m
[31m-[m
[31m-              @Bean[m
[31m-              public ItemReader<Person> reader() throws Exception {[m
[31m-[m
[31m-                      FlatFileItemReader<Person> reader = new FlatFileItemReader<Pers[m
[31m-       ();[m
[31m-[m
[31m-                      reader.setResource(new ClassPathResource("people.csv"));[m
[31m-                      return reader;[m
[31m-              }[m
[31m-[m
[31m-     这时我们要读取的文件的位置已经硬编码在Bean的定义[m
[31m-中，这在很多情况下不符合我们的实际需求，这时我们需要使[m
[31m-用参数后置绑定。[m
[31m-[m
[31m-     要实现参数后置绑定，我们可以在JobParameters中绑定参[m
[31m-数，在Bean定义的时候使用一个特殊的Bean生命周期注解[m
[31m-@StepScope，然后通过@Value注入此参数。[m
[31m-[m
[31m-     参数设置：[m
[31m-[m
[31m-              String path = "people.csv";[m
[31m-[m
[31m-              JobParameters jobParameters = new JobParametersBuilder()[m
[31m-                                    .addLong("time", System.currentTimeMillis())[m
[31m-                                    .addString("input.file.name", path)[m
[31m-                                    .toJobParameters();[m
[31m-[m
[31m-              jobLauncher.run(importJob,jobParameters);[m
[31m-[m
[31m-     定义Bean：[m
[31m-[m
[31m-              @Bean[m
[31m-              @StepScope[m
[31m-                         public ItemReader<Person> reader(@Value("#[m
[31m-{jobParameters['input.file.name']}") String pathToFile) throws Exceptio[m
[31m-[m
[31m-              FlatFileItemReader<Person> reader = new FlatFileItemReader<Pers[m
[31m-();[m
[31m-[m
[31m-              reader.setResource(new ClassPathResource(pathToFile));[m
[31m-              return reader;[m
[31m-       }[m
[31m-[m
[31m-9.2.2　Spring Boot的支持[m
[31m-[m
[31m-Spring  Boot对Spring   Batch支持的源码位于[m
[31m-[m
[31m-org.springframework.boot.autoconfigure.batch下。[m
[31m-[m
[31m-     Spring Boot为我们自动初始化了Spring Batch存储批处理记[m
[31m-录的数据库，且当我们程序启动时，会自动执行我们定义的[m
[31m-[m
[31m-Job的Bean。[m
[31m-[m
[31m-Spring Boot提供如下属性来定制Spring Batch：[m
[31m-[m
[31m-spring.batch.job.names=job1,job2 #启动时要执行的Job，默认执行全部[m
[31m-[m
[31m-Job[m
[31m-spring.batch.job.enabled=true #是否自动执行定义的Job，默认为是[m
[31m-spring.batch.initializer.enabled=true #是否初始化Spring Batch[m
[31m-的数据库，默认为是[m
[31m-[m
[31m-spring.batch.schema=[m
[31m-spring.batch.table-prefix= # 设置Spring Batch的数据库表的前缀[m
[31m-[m
[31m-9.2.3　实战[m
[31m-[m
[31m-     本例将使用Spring Batch将csv文件中的数据使用JDBC批处[m
[31m-理的方式插入数据库。[m
[31m-     1.新建Spring Boot项目[m
[31m-[m
[31m-     新建Spring Boot项目，依赖为JDBC（spring-boot-starter-[m
[31m-jdbc）、Batch（spring-boot-starter-batch）、Web（spring-boot-[m
[31m-starter-web）。[m
[31m-[m
[31m-     项目信息：[m
[31m-[m
[31m-       groupId：com.wisely[m
[31m-       arctifactId:ch9_2[m
[31m-       package: com.wisely.ch9_2[m
[31m-[m
[31m-     此项目使用Oracle驱动，Spring Batch会自动加载hsqldb驱[m
[31m-动，所以我们要去除：[m
[31m-[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework.boot</groupId>[m
[31m-                                                           <artifactId>spring-boot-starter-[m
[31m-[m
[31m-       batch</artifactId>[m
[31m-                             <exclusions>[m
[31m-                                    <exclusion>[m
[31m-                                           <groupId>org.hsqldb[m
[31m-[m
[31m-       </groupId>[m
[31m-                                           <artifactId>hsqldb</artifactId>[m
[31m-[m
[31m-                                    </exclusion>[m
[31m-                             </exclusions>[m
[31m-                      </dependency>[m
[31m-[m
[31m-                      <dependency>[m
[31m-                             <groupId>com.oracle</groupId>[m
[31m-                             <artifactId>ojdbc6</artifactId>[m
[31m-                             <version>11.2.0.2.0</version>[m
[31m-[m
[31m-                      </dependency>[m
[31m-添加hibernate-validator依赖，作为数据校验使用：[m
[31m-[m
[31m-              <dependency>[m
[31m-                     <groupId>org.hibernate</groupId>[m
[31m-                     <artifactId>hibernate-validator</artifactId>[m
[31m-[m
[31m-              </dependency>[m
[31m-[m
[31m-     测试csv数据，位于src/main/resources/people.csv中，内容如[m
[31m-下：[m
[31m-[m
[31m-       汪某某,11,汉族,合肥[m
[31m-       张某某,12,汉族,上海[m
[31m-       李某某,13,非汉族,武汉[m
[31m-       刘某,14,非汉族,南京[m
[31m-       欧阳某某,115,汉族,北京[m
[31m-[m
[31m-     数据表定义，位于src/main/resources/schema.sql中，内容如[m
[31m-下：[m
[31m-[m
[31m-create table PERSON[m
[31m-[m
[31m-([m
[31m-[m
[31m-   id NUMBER not null primary key,[m
[31m-[m
[31m-   name     VARCHAR2(20),[m
[31m-[m
[31m-   age NUMBER,[m
[31m-[m
[31m-   nation   VARCHAR2(20),[m
[31m-[m
[31m-   address  VARCHAR2(20)[m
[31m-[m
[31m-);[m
[31m-[m
[31m-数据源的配置与前面例子保持一致。[m
[31m-2.领域模型类[m
[31m-package com.wisely.ch9_2.domain;[m
[31m-import javax.validation.constraints.Size;[m
[31m-public class Person {[m
[31m-[m
[31m-       @Size(max=4,min=2) //1[m
[31m-       private String name;[m
[31m-       private int age;[m
[31m-       private String nation;[m
[31m-       private String address;[m
[31m-//省略getter、setter方法[m
[31m-}[m
[31m-[m
[31m-代码解释[m
[31m-①此处使用JSR-303注解来校验数据。[m
[31m-3.数据处理及校验[m
[31m-（1）处理：[m
[31m-[m
[31m-package com.wisely.ch9_2.batch;[m
[31m-import org.springframework.batch.item.validator.ValidatingItemProcessor[m
[31m-import org.springframework.batch.item.validator.ValidationException;[m
[31m-import com.wisely.ch9_2.domain.Person;[m
[31m-public class CsvItemProcessor extends ValidatingItemProcessor<Person>[m
[31m-{[m
[31m-[m
[31m-       @Override[m
[31m-       public Person process(Person item) throws ValidationException {[m
[31m-[m
[31m-              super.process(item); //1[m
[31m-              if(item.getNation().equals("汉族")){ //2[m
[31m-[m
[31m-                     item.setNation("01");[m
[31m-                      }else{[m
[31m-                             item.setNation("02");[m
[31m-[m
[31m-                      }[m
[31m-                      return item;[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①需执行super.proces：（item）才会调用自定义校验器。[m
[31m-[m
[31m-     ②对数据做简单的处理，若民族为汉族，则数据转换成[m
[31m-01，其余转换成02。[m
[31m-[m
[31m-     （2）校验：[m
[31m-[m
[31m-       package com.wisely.ch9_2.batch;[m
[31m-[m
[31m-       import java.util.Set;[m
[31m-[m
[31m-       import javax.validation.ConstraintViolation;[m
[31m-       import javax.validation.Validation;[m
[31m-       import javax.validation.ValidatorFactory;[m
[31m-[m
[31m-       import org.springframework.batch.item.validator.ValidationException;[m
[31m-       import org.springframework.batch.item.validator.Validator;[m
[31m-       import org.springframework.beans.factory.InitializingBean;[m
[31m-[m
[31m-       public class CsvBeanValidator<T> implements Validator<T>,InitializingBe[m
[31m-              private javax.validation.Validator validator;[m
[31m-              @Override[m
[31m-              public void afterPropertiesSet() throws Exception { //1[m
[31m-                      ValidatorFactory validatorFactory = Validation.buildDefaultVali[m
[31m-                      validator = validatorFactory.usingContext().getValidator();[m
[31m-              }[m
[31m-[m
[31m-              @Override[m
[31m-              public void validate(T value) throws ValidationException {[m
[31m-[m
[31m-                      Set<ConstraintViolation<T>> constraintViolations = validator.va[m
[31m-                      if(constraintViolations.size()>0){[m
[31m-[m
[31m-                             StringBuilder message = new StringBuilder();[m
[31m-                             for (ConstraintViolation<T> constraintViolation : constrain[m
[31m-[m
[31m-                                    message.append(constraintViolation.getMessage() + "\n")[m
[31m-                             }[m
[31m-                             throw new ValidationException(message.toString());[m
[31m-[m
[31m-                      }[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①使用JSR-303的Validator来校验我们的数据，在此处进行[m
[31m-JSR-303的Validator的初始化。[m
[31m-[m
[31m-     ②使用Validator的validate方法校验数据。[m
[31m-[m
[31m-     4.Job监听[m
[31m-[m
[31m-       package com.wisely.ch9_2.batch;[m
[31m-[m
[31m-       import org.springframework.batch.core.JobExecution;[m
[31m-       import org.springframework.batch.core.JobExecutionListener;[m
[31m-[m
[31m-       public class CsvJobListener implements JobExecutionListener{[m
[31m-[m
[31m-              long startTime;[m
[31m-              long endTime;[m
[31m-              @Override[m
[31m-              public void beforeJob(JobExecution jobExecution) {[m
[31m-[m
[31m-                      startTime = System.currentTimeMillis();[m
[31m-                      System.out.println("任务处理开始");[m
[31m-              }[m
[31m-[m
[31m-              @Override[m
[31m-              public void afterJob(JobExecution jobExecution) {[m
[31m-[m
[31m-                      endTime = System.currentTimeMillis();[m
[31m-                      System.out.println("任务处理结束");[m
[31m-                                                                              System.out.println("耗[m
[31m-[m
[31m-       时:" + (endTime - startTime) + "ms");[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     监听器实现JobExecutionListener接口，并重写其[m
[31m-beforeJob、afterJob方法即可。[m
[31m-[m
[31m-     5.配置[m
[31m-[m
[31m-     配置的完成代码如下：[m
[31m-[m
[31m-       package com.wisely.ch9_2.batch;[m
[31m-[m
[31m-       import javax.sql.DataSource;[m
[31m-[m
[31m-       import org.springframework.batch.core.Job;[m
[31m-       import org.springframework.batch.core.Step;[m
[31m-       import org.springframework.batch.core.configuration.annotation.EnableBa[m
[31m-       import org.springframework.batch.core.configuration.annotation.JobBuild[m
[31m-       import org.springframework.batch.core.configuration.annotation.StepBuil[m
[31m-       import org.springframework.batch.core.launch.support.RunIdIncrementer;[m
[31m-       import org.springframework.batch.core.launch.support.SimpleJobLauncher;[m
[31m-       import org.springframework.batch.core.repository.JobRepository;[m
[31m-       import org.springframework.batch.core.repository.support.JobRepositoryF[m
[31m-       import org.springframework.batch.item.ItemProcessor;[m
[31m-       import org.springframework.batch.item.ItemReader;[m
[31m-       import org.springframework.batch.item.ItemWriter;[m
[31m-       import org.springframework.batch.item.database.BeanPropertyItemSqlParam[m
[31m-       import org.springframework.batch.item.database.JdbcBatchItemWriter;[m
[31m-       import org.springframework.batch.item.file.FlatFileItemReader;[m
[31m-       import org.springframework.batch.item.file.mapping.BeanWrapperFieldSetM[m
[31m-       import org.springframework.batch.item.file.mapping.DefaultLineMapper;[m
[31m-       import org.springframework.batch.item.file.transform.DelimitedLineToken[m
[31m-       import org.springframework.batch.item.validator.Validator;[m
[31m-       import org.springframework.context.annotation.Bean;[m
[31m-       import org.springframework.context.annotation.Configuration;[m
[31m-import org.springframework.core.io.ClassPathResource;[m
[31m-import org.springframework.transaction.PlatformTransactionManager;[m
[31m-[m
[31m-import com.wisely.ch9_2.domain.Person;[m
[31m-[m
[31m-@Configuration[m
[31m-@EnableBatchProcessing[m
[31m-public class CsvBatchConfig {[m
[31m-[m
[31m-       @Bean[m
[31m-       public ItemReader<Person> reader() throws Exception {[m
[31m-[m
[31m-              FlatFileItemReader<Person> reader = new FlatFileItemReader<Pers[m
[31m-();[m
[31m-[m
[31m-              reader.setResource(new ClassPathResource("people.csv"));[m
[31m-                     reader.setLineMapper(new DefaultLineMapper<Person>[m
[31m-[m
[31m-() {{[m
[31m-                             setLineTokenizer(new DelimitedLineTokenizer() {{[m
[31m-                                    setNames(new String[] { "name","age", "nation" ,"ad[m
[31m-                             }});[m
[31m-                             setFieldSetMapper(new BeanWrapperFieldSetMapper<Person>[m
[31m-[m
[31m-() {{[m
[31m-                                    setTargetType(Person.class);[m
[31m-[m
[31m-                             }});[m
[31m-                     }});[m
[31m-                     return reader;[m
[31m-       }[m
[31m-[m
[31m-       @Bean[m
[31m-       public ItemProcessor<Person, Person> processor() {[m
[31m-[m
[31m-              CsvItemProcessor processor = new CsvItemProcessor();[m
[31m-              processor.setValidator(csvBeanValidator());[m
[31m-              return processor;[m
[31m-       }[m
[31m-[m
[31m-       @Bean[m
[31m-       public ItemWriter<Person> writer(DataSource dataSource) {[m
[31m-[m
[31m-              JdbcBatchItemWriter<Person> writer = new JdbcBatchItemWriter<Pe[m
[31m-();[m
[31m-[m
[31m-              writer.setItemSqlParameterSourceProvider(new BeanPropertyItemSq[m
[31m-());[m
[31m-[m
[31m-                           String sql = "insert into person " + "[m
[31m-(id,name,age,nation,address) "[m
[31m-[m
[31m-                             + "values(hibernate_sequence.nextval, :name, :age, :nat[m
[31m-              writer.setSql(sql);[m
[31m-              writer.setDataSource(dataSource);[m
[31m-              return writer;[m
[31m-       }[m
[31m-@Bean[m
[31m-public JobRepository jobRepository(DataSource dataSource, PlatformT[m
[31m-[m
[31m-              throws Exception {[m
[31m-       JobRepositoryFactoryBean jobRepositoryFactoryBean = new JobRepo[m
[31m-       jobRepositoryFactoryBean.setDataSource(dataSource);[m
[31m-       jobRepositoryFactoryBean.setTransactionManager(transactionManag[m
[31m-       jobRepositoryFactoryBean.setDatabaseType("oracle");[m
[31m-       return jobRepositoryFactoryBean.getObject();[m
[31m-}[m
[31m-[m
[31m-@Bean[m
[31m-public SimpleJobLauncher jobLauncher(DataSource dataSource, Platfor[m
[31m-[m
[31m-              throws Exception {[m
[31m-       SimpleJobLauncher jobLauncher = new SimpleJobLauncher();[m
[31m-       jobLauncher.setJobRepository(jobRepository(dataSource, transact[m
[31m-       return jobLauncher;[m
[31m-}[m
[31m-[m
[31m-@Bean[m
[31m-public Job importJob(JobBuilderFactory jobs, Step s1) {[m
[31m-[m
[31m-       return jobs.get("importJob")[m
[31m-                     .incrementer(new RunIdIncrementer())[m
[31m-                     .flow(s1)[m
[31m-                     .end()[m
[31m-                     .listener(csvJobListener())[m
[31m-                     .build();[m
[31m-[m
[31m-}[m
[31m-[m
[31m-@Bean[m
[31m-public Step step1(StepBuilderFactory stepBuilderFactory, ItemReader[m
[31m-[m
[31m-              ItemProcessor<Person,Person> processor) {[m
[31m-       return stepBuilderFactory[m
[31m-[m
[31m-                     .get("step1")[m
[31m-                     .<Person, Person>chunk(65000)[m
[31m-                     .reader(reader)[m
[31m-                     .processor(processor)[m
[31m-                     .writer(writer)[m
[31m-                     .build();[m
[31m-}[m
[31m-[m
[31m-@Bean[m
[31m-public CsvJobListener csvJobListener() {[m
[31m-[m
[31m-       return new CsvJobListener();[m
[31m-}[m
[31m-[m
[31m-@Bean[m
[31m-public Validator<Person> csvBeanValidator() {[m
[31m-[m
[31m-       return new CsvBeanValidator<Person>();[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     配置代码较长，我们将拆开讲解，首先我们的配置类要使[m
[31m-用@EnableBatchProcessing开启批处理的支持，这点千万不要[m
[31m-忘记。[m
[31m-[m
[31m-     ItemReader定义：[m
[31m-[m
[31m-              @Bean[m
[31m-              public ItemReader<Person> reader() throws Exception {[m
[31m-[m
[31m-                      FlatFileItemReader<Person> reader = new FlatFileItemReader<Pers[m
[31m-       (); //1[m
[31m-[m
[31m-                      reader.setResource(new ClassPathResource("people.csv")); //2[m
[31m-                             reader.setLineMapper(new DefaultLineMapper<Person>[m
[31m-[m
[31m-       () {{ //3[m
[31m-                                    setLineTokenizer(new DelimitedLineTokenizer() {{[m
[31m-                                           setNames(new String[] { "name","age", "nation" ,"ad[m
[31m-                                    }});[m
[31m-                                    setFieldSetMapper(new BeanWrapperFieldSetMapper<Person>[m
[31m-[m
[31m-       () {{[m
[31m-                                           setTargetType(Person.class);[m
[31m-[m
[31m-                                    }});[m
[31m-                             }});[m
[31m-                             return reader;[m
[31m-              }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①使用FlatFileItemReader读取文件。[m
[31m-[m
[31m-     ②使用FlatFileItemReader的setResource方法设置csv文件的[m
[31m-路径。[m
[31m-[m
[31m-     ③在此处对cvs文件的数据和领域模型类做对应映射。[m
[31m-     ItemProcessor定义：[m
[31m-[m
[31m-              @Bean[m
[31m-              public ItemProcessor<Person, Person> processor() {[m
[31m-[m
[31m-                      CsvItemProcessor processor = new CsvItemProcessor(); //1[m
[31m-                      processor.setValidator(csvBeanValidator()); //2[m
[31m-                      return processor;[m
[31m-              }[m
[31m-[m
[31m-             @Bean[m
[31m-              public Validator<Person> csvBeanValidator() {[m
[31m-                      return new CsvBeanValidator<Person>();[m
[31m-              }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①使用我们自己定义的ItemProcessor的实现[m
[31m-CsvItemProcessor。[m
[31m-[m
[31m-     ②为processor指定校验器为CsvBeanValidator；[m
[31m-[m
[31m-     ItemWriter定义：[m
[31m-[m
[31m-              @Bean[m
[31m-              public ItemWriter<Person> writer(DataSource dataSource) {//1[m
[31m-[m
[31m-                      JdbcBatchItemWriter<Person> writer = new JdbcBatchItemWriter<Pe[m
[31m-       (); //2[m
[31m-[m
[31m-                      writer.setItemSqlParameterSourceProvider(new BeanPropertyItemSq[m
[31m-       ());[m
[31m-[m
[31m-                                   String sql = "insert into person " + "[m
[31m-       (id,name,age,nation,address) "[m
[31m-[m
[31m-                                    + "values(hibernate_sequence.nextval, :name, :age, :nat[m
[31m-                      writer.setSql(sql); //3[m
[31m-                      writer.setDataSource(dataSource);[m
[31m-                      return writer;[m
[31m-              }[m
[31m-     代码解释[m
[31m-[m
[31m-     ①Spring能让容器中已有的Bean以参数的形式注入，Spring[m
[31m-Boot已为我们定义了dataSource。[m
[31m-[m
[31m-     ②我们使用JDBC批处理的JdbcBatchItemWriter来写数据到[m
[31m-数据库。[m
[31m-[m
[31m-     ③在此设置要执行批处理的SQL语句。[m
[31m-[m
[31m-     JobRepository定义：[m
[31m-[m
[31m-              @Bean[m
[31m-              public JobRepository jobRepository(DataSource dataSource, PlatformT[m
[31m-[m
[31m-                             throws Exception {[m
[31m-                      JobRepositoryFactoryBean jobRepositoryFactoryBean = new JobRepo[m
[31m-                      jobRepositoryFactoryBean.setDataSource(dataSource);[m
[31m-                      jobRepositoryFactoryBean.setTransactionManager(transactionManag[m
[31m-                      jobRepositoryFactoryBean.setDatabaseType("oracle");[m
[31m-                      return jobRepositoryFactoryBean.getObject();[m
[31m-              }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     jobRepository的定义需要dataSource和transactioManager，[m
[31m-Spring Boot已为我们自动配置了这两个类，Spring可通过方法[m
[31m-注入已有的Bean。[m
[31m-[m
[31m-     JobLauncher定义：[m
[31m-[m
[31m-              @Bean[m
[31m-              public SimpleJobLauncher jobLauncher(DataSource dataSource, Platfor[m
[31m-[m
[31m-                             throws Exception {[m
[31m-                      SimpleJobLauncher jobLauncher = new SimpleJobLauncher();[m
[31m-                      jobLauncher.setJobRepository(jobRepository(dataSource, transact[m
[31m-                      return jobLauncher;[m
[31m-       }[m
[31m-[m
[31m-Job定义：[m
[31m-[m
[31m-       @Bean[m
[31m-       public Job importJob(JobBuilderFactory jobs, Step s1) {[m
[31m-[m
[31m-              return jobs.get("importJob")[m
[31m-                             .incrementer(new RunIdIncrementer())[m
[31m-                             .flow(s1) //1[m
[31m-                             .end()[m
[31m-                             .listener(csvJobListener()) //2[m
[31m-                             .build();[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-       @Bean[m
[31m-       public CsvJobListener csvJobListener() {[m
[31m-[m
[31m-              return new CsvJobListener();[m
[31m-       }[m
[31m-[m
[31m-代码解释[m
[31m-[m
[31m-①为Job指定Step。[m
[31m-[m
[31m-②绑定监听器csvJobListener。[m
[31m-[m
[31m-Step定义：[m
[31m-[m
[31m-       @Bean[m
[31m-       public Step step1(StepBuilderFactory stepBuilderFactory, ItemReader[m
[31m-[m
[31m-                     ItemProcessor<Person,Person> processor) {[m
[31m-              return stepBuilderFactory[m
[31m-[m
[31m-                             .get("step1")[m
[31m-                             .<Person, Person>chunk(65000) //1[m
[31m-                             .reader(reader) //2[m
[31m-                             .processor(processor) //3[m
[31m-                             .writer(writer) //4[m
[31m-                             .build();[m
[31m-       }[m
[31m-     代码解释[m
[31m-     ①批处理每次提交65000条数据。[m
[31m-     ②给step绑定reader。[m
[31m-     ③给step绑定processor。[m
[31m-     ④给step绑定writer。[m
[31m-     6.运行[m
[31m-     启动程序，Spring Boot会自动初始化Spring Batch数据库，[m
[31m-并将csv中的数据导入到数据库中。[m
[31m-     为我们初始化的Spring Batch数据库如图9-11所示。[m
[31m-[m
[31m-                            图9-11　Spring Batch数据库[m
[31m-[m
[31m-     监听器效果如图9-12所示。[m
[31m-     数据已导入且做转换处理，如图9-13所示。[m
[31m-                                 图9-12　监听器效果[m
[31m-[m
[31m-                        图9-13　数据已导入且做转换处理[m
[31m-[m
[31m-     将我们在Person类上定义的[m
[31m-     @Size（max=4，min=2）[m
[31m-     修改为[m
[31m-     @Size（max=3，min=2），启动程序，控制台输出校验错[m
[31m-误，如图9-14所示。[m
[31m-[m
[31m-                                图9-14　输入校验错误[m
[31m-[m
[31m-     7.手动触发任务[m
[31m-     很多时候批处理任务是人为触发的，在此我们添加一个控[m
[31m-制器，通过人为触发批处理任务，并演示参数后置绑定的使[m
[31m-用。[m
[31m-[m
[31m-     注释掉CsvBatchConfig类的@Configuration注解，让此配置[m
[31m-类不再起效。新建TriggerBatchConfig配置类，内容与[m
[31m-CsvBatchConfig完全保持一致，除了修改定义ItemReader这个[m
[31m-Bean，ItemReader修改后的定义如下：[m
[31m-[m
[31m-              @Bean[m
[31m-              @StepScope[m
[31m-[m
[31m-                       public FlatFileItemReader<Person> reader(@Value("#[m
[31m-       {jobParameters['input.file.name']}") String pathToFile) throws Exceptio[m
[31m-[m
[31m-                      FlatFileItemReader<Person> reader = new FlatFileItemReader<Pers[m
[31m-       (); //1[m
[31m-[m
[31m-                       reader.setResource(new ClassPathResource(pathToFile)); //2[m
[31m-                             reader.setLineMapper(new DefaultLineMapper<Person>[m
[31m-[m
[31m-       () {{ //3[m
[31m-                                    setLineTokenizer(new DelimitedLineTokenizer() {{[m
[31m-                                           setNames(new String[] { "name","age", "nation" ,"ad[m
[31m-                                    }});[m
[31m-                                    setFieldSetMapper(new BeanWrapperFieldSetMapper<Person>[m
[31m-[m
[31m-       () {{[m
[31m-                                           setTargetType(Person.class);[m
[31m-[m
[31m-                                    }});[m
[31m-                             }});[m
[31m-[m
[31m-                             return reader;[m
[31m-              }[m
[31m-[m
[31m-     此处需注意Bean的类型修改为FlatFileItemReader，而不是[m
[31m-ItemReader。因为ItemReader接口中没有read方法，若使用[m
[31m-ItemReader则会报一个“Reader must be open before it can be[m
[31m-read”错误。[m
[31m-[m
[31m-     控制定义如下：[m
[31m-[m
[31m-       package com.wisely.ch9_2.web;[m
[31m-       import org.springframework.batch.core.Job;[m
[31m-       import org.springframework.batch.core.JobParameters;[m
[31m-       import org.springframework.batch.core.JobParametersBuilder;[m
[31m-       import org.springframework.batch.core.launch.JobLauncher;[m
[31m-       import org.springframework.beans.factory.annotation.Autowired;[m
[31m-       import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-       import org.springframework.web.bind.annotation.RestController;[m
[31m-[m
[31m-       @RestController[m
[31m-       public class DemoController {[m
[31m-[m
[31m-                      @Autowired[m
[31m-                      JobLauncher jobLauncher;[m
[31m-                      @Autowired[m
[31m-                      Job importJob;[m
[31m-                      public JobParameters jobParameters;[m
[31m-[m
[31m-                      @RequestMapping("/imp")[m
[31m-                      public String imp(String fileName) throws Exception{[m
[31m-[m
[31m-                             String path = fileName+".csv";[m
[31m-                             jobParameters = new JobParametersBuilder()[m
[31m-[m
[31m-                                           .addLong("time", System.currentTimeMillis())[m
[31m-                                           .addString("input.file.name", path)[m
[31m-                                           .toJobParameters();[m
[31m-                             jobLauncher.run(importJob,jobParameters);[m
[31m-                             return "ok";[m
[31m-                      }[m
[31m-       }[m
[31m-[m
[31m-     此时我们还要关闭Spring Boot为我们自动执行Job的配置，[m
[31m-在application.properties里使用下面代码关闭配置：[m
[31m-[m
[31m-       spring.batch.job.enabled=false[m
[31m-[m
[31m-     此时我们访问http://localhost：8080/imp？[m
[31m-fileName=people，可获得相同的数据导入效果，如图9-15所[m
[31m-示。[m
[31m-图9-15　数据导入效果[m
[31m-9.3　异步消息[m
[31m-[m
[31m-     异步消息主要目的是为了系统与系统之间的通信。所谓异[m
[31m-步消息即消息发送者无须等待消息接收者的处理及返回，甚至[m
[31m-无须关心消息是否发送成功。[m
[31m-[m
[31m-     在异步消息中有两个很重要的概念，即消息代理（message[m
[31m-broker）和目的地（destination）。当消息发送者发送消息后，[m
[31m-消息将由消息代理接管，消息代理保证消息传递到指定的目的[m
[31m-地。[m
[31m-[m
[31m-     异步消息主要有两种形式的目的地：队列（queue）和主题[m
[31m-（topic）。队列用于点对点式（point-to-point）的消息通信；[m
[31m-主题用于发布/订阅式（publish/subscribe）的消息通信。[m
[31m-[m
[31m-     1.点对点式[m
[31m-[m
[31m-     当消息发送者发送消息，消息代理获得消息后将消息放进[m
[31m-一个队列（queue）里，当有消息接收者来接收消息的时候，[m
[31m-消息将从队列里取出来传递给接收者，这时候队列里就没有了[m
[31m-这条消息。[m
[31m-[m
[31m-     点对点式确保的是每一条消息只有唯一的发送者和接收[m
[31m-者，但这并不能说明只有一个接收者可以从队列里接收消息。[m
[31m-因为队列里有多个消息，点对点式只保证每一条消息只有唯一[m
[31m-的发送者和接收者。[m
[31m-[m
[31m-     2.发布/订阅式[m
[31m-[m
[31m-     和点对点式不同，发布/订阅式是消息发送者发送消息到主[m
[31m-题（topic），而多个消息接收者监听这个主题。此时的消息发[m
[31m-送者和接收者分别叫做发布者和订阅者。[m
[31m-[m
[31m-9.3.1　企业级消息代理[m
[31m-[m
[31m-     JMS（Java Message Service）即Java消息服务，是基于JVM[m
[31m-消息代理的规范。而ActiveMQ、HornetQ是一个JMS消息代理[m
[31m-的实现。[m
[31m-[m
[31m-     AMQP（Advanced Message Queuing Protocol）也是一个消[m
[31m-息代理的规范，但它不仅兼容JMS，还支持跨语言和平台。[m
[31m-AMQP的主要实现有RabbitMQ。[m
[31m-[m
[31m-9.3.2　Spring的支持[m
[31m-[m
[31m-     Spring对JMS和AMQP的支持分别来自于spring-jms和[m
[31m-Spring-rabbit。[m
[31m-[m
[31m-     它们分别需要ConnectionFactory的实现来连接消息代理，[m
[31m-并分别提供了JmsTemplate、RabbitTemplate来发送消息。[m
[31m-[m
[31m-     Spring为JMS、AMQP提供了@JmsListener、[m
[31m-@RabbitListener注解在方法上监听消息代理发布的消息。我们[m
[31m-需要分别通过@EnableJms、@EnableRabbit开启支持。[m
[31m-[m
[31m-9.3.3　Spring Boot的支持[m
[31m-[m
[31m-Spring                Boot对JMS的自动配置支持位于[m
[31m-[m
[31m-org.springframework.boot.autoconfigure.jms下，支持JMS的实现[m
[31m-有ActiveMQ、HornetQ、Artemis（由HornetQ捐赠给ActiveMQ[m
[31m-的代码库形成的ActiveMQ的子项目）。这里我们以ActiveMQ[m
[31m-为例，Spring Boot为我们定义了ActiveMQConnectionFactory的[m
[31m-Bean作为连接，并通过“spring.activemq”为前缀的属性来配置[m
[31m-ActiveMQ的连接属性，包含：[m
[31m-[m
[31m-       spring.activemq.broker-url=tcp://localhost:61616 # 消息代理的[m
[31m-       路径[m
[31m-       spring.activemq.user=[m
[31m-       spring.activemq.password=[m
[31m-       spring.activemq.in-memory=true[m
[31m-       spring.activemq.pooled=false[m
[31m-[m
[31m-Spring  Boot在JmsAutoConfiguration还为我们配置好了[m
[31m-[m
[31m-JmsTemplate，且为我们开启了注解式消息监听的支持，即自[m
[31m-[m
[31m-动开启@EnableJms。[m
[31m-[m
[31m-Spring          Boot对AMQP的自动配置支持位于[m
[31m-[m
[31m-org.springframework.boot.autoconfigure.amqp下，它为我们配置[m
[31m-[m
[31m-了连接的ConnectionFactory和RabbitTemplate，且为我们开启了[m
[31m-[m
[31m-注解式消息监听，即自动开启@EnableRabbit。RabbitMQ的配[m
[31m-[m
[31m-置可通过“spring.rabbitmq”来配置RabbitMQ，主要包含：[m
[31m-[m
[31m-spring.rabbitmq.host=localhost   #rabbitmq服务器地址，默认为[m
[31m-[m
[31m-localhost[m
[31m-spring.rabbitmq.port=5672 #rabbitmq端口，默认为5672[m
[31m-[m
[31m-spring.rabbitmq.username=admin[m
[31m-[m
[31m-spring.rabbitmq.password=secret[m
[31m-[m
[31m-9.3.4　JMS实战[m
[31m-     1.安装ActiveMQ[m
[31m-[m
[31m-     （1）非Docker安装[m
[31m-[m
[31m-     读者可访问http://activemq.apache.org/activemq-5111-[m
[31m-release.html，下载合适的ActiveMQ版本。[m
[31m-[m
[31m-     （2）Docker安装[m
[31m-[m
[31m-     前面已经下载好了ActiveMQ的镜像，我们可以通过下面命[m
[31m-令运行镜像：[m
[31m-[m
[31m-docker run -d -p                 61616:61616  -[m
[31m-p 8161:8161 cloudesire/activemq[m
[31m-[m
[31m-     其中61616是消息代理的端口，8161是ActiveMQ的管理界[m
[31m-面端口，最后别忘了在VirtualBox开启61616及8161的端口映[m
[31m-射。[m
[31m-[m
[31m-     访问http://localhost：8161可打开ActiveMQ的管理界面，管[m
[31m-理员账号密码默认为admin/admin，如图9-16所示。[m
[31m-[m
[31m-     （3）内嵌ActiveMQ[m
[31m-[m
[31m-     我们可以将ActiveMQ内嵌在程序里，只要在项目依赖里加[m
[31m-入activemq-broker即可。[m
[31m-[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.apache.activemq</groupId>[m
[31m-                             <artifactId>activemq-broker</artifactId>[m
[31m-[m
[31m-                      </dependency>[m
[31m-                           图9-16　ActiveMQ的管理界面[m
[31m-[m
[31m-     2.新建Spring Boot项目[m
[31m-[m
[31m-     新建Spring Boot项目，依赖无。[m
[31m-[m
[31m-     项目信息：[m
[31m-[m
[31m-       groupId：com.wisely[m
[31m-       arctifactId:ch9_3_4[m
[31m-       package: com.wisely.ch9_3_4[m
[31m-[m
[31m-     虽然Spring Boot提供了JMS（spring-boot-starter-hornetq）[m
[31m-的依赖，但默认我们使用的消息代理是HornetQ，本例将以[m
[31m-ActiveMQ为例，所以我们需要添加spring-jms和activemq-client[m
[31m-的依赖，所需的完成依赖如下：[m
[31m-[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework.boot</groupId>[m
[31m-                             <artifactId>spring-boot-starter</artifactId>[m
[31m-[m
[31m-                      </dependency>[m
[31m-                      <dependency>[m
[31m-[m
[31m-                             <groupId>org.springframework</groupId>[m
[31m-                             <artifactId>spring-jms</artifactId>[m
[31m-                      </dependency>[m
[31m-[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.apache.activemq</groupId>[m
[31m-                             <artifactId>activemq-client</artifactId>[m
[31m-[m
[31m-                      </dependency>[m
[31m-[m
[31m-     配置ActiveMQ消息代理的地址，在application.properties里[m
[31m-使用：[m
[31m-[m
[31m-       spring.activemq.broker-url=tcp://localhost:61616[m
[31m-[m
[31m-     在实际情况下，消息的发布者和接收者一般都是分开的，[m
[31m-而这里我们为了演示简单，将消息发送者和接收者放在一个程[m
[31m-序里。[m
[31m-[m
[31m-     3.消息定义[m
[31m-[m
[31m-     定义JMS发送的消息需实现MessageCreator接口，并重写其[m
[31m-createMessage方法：[m
[31m-[m
[31m-       package com.wisely.ch9_3_4;[m
[31m-[m
[31m-       import javax.jms.JMSException;[m
[31m-       import javax.jms.Message;[m
[31m-       import javax.jms.Session;[m
[31m-[m
[31m-       import org.springframework.jms.core.MessageCreator;[m
[31m-[m
[31m-       public class Msg implements MessageCreator{[m
[31m-[m
[31m-              @Override[m
[31m-              public Message createMessage(Session session) throws JMSException {[m
[31m-[m
[31m-                      return session.createTextMessage("测试消息");[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     4.消息发送及目的地定义[m
[31m-[m
[31m-       package com.wisely.ch9_3_4;[m
[31m-[m
[31m-       import org.springframework.beans.factory.annotation.Autowired;[m
[31m-       import org.springframework.boot.CommandLineRunner;[m
[31m-       import org.springframework.boot.SpringApplication;[m
[31m-       import org.springframework.boot.autoconfigure.SpringBootApplication;[m
[31m-       import org.springframework.jms.core.JmsTemplate;[m
[31m-[m
[31m-       @SpringBootApplication[m
[31m-       public class Ch934Application implements CommandLineRunner{ //1[m
[31m-[m
[31m-              @Autowired[m
[31m-              JmsTemplate jmsTemplate; //2[m
[31m-[m
[31m-              public static void main(String[] args) {[m
[31m-                      SpringApplication.run(Ch934Application.class, args);[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              @Override[m
[31m-              public void run(String... args) throws Exception {[m
[31m-[m
[31m-                      jmsTemplate.send("my-destination", new Msg()); //3[m
[31m-[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①Spring Boot为我们提供了CommandLineRunner接口，用[m
[31m-于程序启动后执行的代码，通过重写其run方法执行。[m
[31m-[m
[31m-     ②注入Spring Boot为我们配置好的JmsTemplate的Bean。[m
[31m-     ③通过JmsTemplate的send方法向my-destination目的地发送[m
[31m-Msg的消息，这里也等于在消息代理上定义了一个目的地叫[m
[31m-my-destination。[m
[31m-[m
[31m-     5.消息监听[m
[31m-[m
[31m-       package com.wisely.ch9_3_4;[m
[31m-[m
[31m-       import org.springframework.jms.annotation.JmsListener;[m
[31m-       import org.springframework.stereotype.Component;[m
[31m-[m
[31m-       @Component[m
[31m-       public class Receiver {[m
[31m-[m
[31m-              @JmsListener(destination = "my-destination")[m
[31m-              public void receiveMessage(String message) {[m
[31m-[m
[31m-                      System.out.println("接受到: <" + message + ">");[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     @JmsListener是Spring 4.1为我们提供的一个新特性，用来[m
[31m-简化JMS开发。我们只需在这个注解的属性destination指定要[m
[31m-监听的目的地，即可接收该目的地发送的消息。此例监听my-[m
[31m-destination目的地发送的消息。[m
[31m-[m
[31m-     6.运行[m
[31m-[m
[31m-     启动程序，程序会自动向目的地my-destination发送消息，[m
[31m-而Receiver类注解了@JmsLisener的方法会自动监听my-[m
[31m-destination发送的消息。[m
[31m-[m
[31m-     控制台显示Receiver已接收到消息，如图9-17所示。[m
[31m-                                图9-17　已接收到消息[m
[31m-[m
[31m-     在ActiveMQ的管理页面也可以查看我们目的地的相关信[m
[31m-息，如图9-18所示。[m
[31m-[m
[31m-                          图9-18　查看目的地的相关信息[m
[31m-[m
[31m-9.3.5　AMQP实战[m
[31m-[m
[31m-     1.安装RabbitMQ[m
[31m-     （1）非Docker安装[m
[31m-     RabbitMQ是基于erlang语言开发的，所以安装RabbitMQ先[m
[31m-要下载安装erlang，下载地址为[m
[31m-http://www.erlang.org/download.html；然后下载RabbitMQ，下[m
[31m-载地址为https://www.rabbitmq.com/download.html。[m
[31m-     （2）Docker安装[m
[31m-     前面已经下载好了RabbitMQ的镜像，以下面命令运行一个[m
[31m-容器：[m
[31m-[m
[31m-       docker run -d -p 5672:5672 -p 15672:15672 rabbitmq:3-[m
[31m-       management[m
[31m-[m
[31m-     其中5672是消息代理的端口，15672是Web管理界面的端[m
[31m-口，我们使用的是带管理界面的RabbitMQ；最后还要在[m
[31m-VirtualBox做以下这两个端口的映射。[m
[31m-[m
[31m-     访问http://localhost：15672，打开管理界面，默认账号密[m
[31m-码为guest/guest，如图9-19所示。[m
[31m-[m
[31m-                            图9-19　RabbitMQ管理界面[m
[31m-[m
[31m-     2.新建Spring Boot项目[m
[31m-     新建Spring Boot项目，依赖为AMQP（spring-boot-starter-[m
[31m-amqp）。[m
[31m-     项目信息：[m
[31m-groupId：com.wisely[m
[31m-arctifactId:ch9_3_5[m
[31m-package: com.wisely.ch9_3_5[m
[31m-[m
[31m-     Spring Boot默认我们的Rabbit主机为localhost、端口号为[m
[31m-5672，所以我们无须为Spring Boot的application.properties配置[m
[31m-RabbitMQ的连接信息。[m
[31m-[m
[31m-     3.发送信息及目的地定义[m
[31m-[m
[31m-package com.wisely.ch9_3_5;[m
[31m-[m
[31m-import org.springframework.amqp.core.Queue;[m
[31m-import org.springframework.amqp.rabbit.core.RabbitTemplate;[m
[31m-import org.springframework.beans.factory.annotation.Autowired;[m
[31m-import org.springframework.boot.CommandLineRunner;[m
[31m-import org.springframework.boot.SpringApplication;[m
[31m-import org.springframework.boot.autoconfigure.SpringBootApplication;[m
[31m-import org.springframework.context.annotation.Bean;[m
[31m-[m
[31m-@SpringBootApplication[m
[31m-public class Ch935Application implements CommandLineRunner{[m
[31m-[m
[31m-       @Autowired[m
[31m-       RabbitTemplate rabbitTemplate; //1[m
[31m-[m
[31m-       public static void main(String[] args) {[m
[31m-              SpringApplication.run(Ch935Application.class, args);[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-       @Bean //2[m
[31m-       public Queue wiselyQueue(){[m
[31m-[m
[31m-              return new Queue("my-queue");[m
[31m-       }[m
[31m-[m
[31m-       @Override                                                    "来自[m
[31m-       public void run(String... args) throws Exception {[m
[31m-[m
[31m-                         rabbitTemplate.convertAndSend("my-queue",[m
[31m-RabbitMQ的问候"); //3[m
[31m-[m
[31m-       }[m
[31m-}[m
[31m-     代码解释[m
[31m-[m
[31m-     ①可注入Spring Boot为我们自动配置好的RabbitTemplate。[m
[31m-[m
[31m-     ②定义目的地即队列，队列名称为my-queue。[m
[31m-[m
[31m-     ③通过RabbitTemplate的convertAndSend方法向队列my-[m
[31m-queue发送消息。[m
[31m-[m
[31m-     4.消息监听[m
[31m-[m
[31m-       package com.wisely.ch9_3_5;[m
[31m-[m
[31m-       import org.springframework.amqp.rabbit.annotation.RabbitListener;[m
[31m-       import org.springframework.stereotype.Component;[m
[31m-[m
[31m-       @Component[m
[31m-       public class Receiver {[m
[31m-[m
[31m-              @RabbitListener(queues = "my-queue")[m
[31m-              public void receiveMessage(String message) {[m
[31m-[m
[31m-                      System.out.println("Received <" + message + ">");[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     使用@RabbitListener来监听RabbitMQ的目的地发送的消[m
[31m-息，通过queues属性指定要监听的目的地。[m
[31m-[m
[31m-     5.运行[m
[31m-[m
[31m-     启动程序，程序会自动向目的地my-queue发送消息，而[m
[31m-Receiver类注解了@RabbitListener的方法会自动监听my-queue[m
[31m-发送的消息。[m
[31m-控制台显示如图9-20所示。[m
[31m-[m
[31m-                              图9-20　控制台[m
[31m-[m
[31m-RabbitMQ管理界面显示如图9-21所示。[m
[31m-[m
[31m-                      图9-21　RabbitMQ管理界面[m
[31m-9.4　系统集成Spring Integration[m
[31m-[m
[31m-9.4.1　Spring Integration快速入门[m
[31m-[m
[31m-Spring       Ingegration提供了基于Spring的EIP（Enterprise[m
[31m-[m
[31m-Integration    Patterns，企业集成模式）的实现。Spring[m
[31m-[m
[31m-Integration主要解决的问题是不同系统之间交互的问题，通过[m
[31m-[m
[31m-异步消息驱动来达到系统交互时系统之间的松耦合。本节将基[m
[31m-[m
[31m-于无XML配置的原则使用Java配置、注解以及Spring[m
[31m-[m
[31m-Integration Java DSL来使用Spring Integration。[m
[31m-[m
[31m-Spring         Integratin主要由Message、Channel和Message[m
[31m-[m
[31m-EndPoint组成。[m
[31m-[m
[31m-9.4.2　Message[m
[31m-[m
[31m-     Message是用来在不同部分之间传递的数据。Message由两[m
[31m-部分组成：消息体（payload）与消息头（header）。消息体可[m
[31m-以是任何数据类型（如XML、JSON，Java对象）；消息头表[m
[31m-示的元数据就是解释消息体的内容。[m
[31m-[m
[31m-public interface Message<T> {[m
[31m-       T getPayload();[m
[31m-       MessageHeaders getHeaders();[m
[31m-[m
[31m-}[m
[31m-9.4.3　Channel[m
[31m-[m
[31m-     在消息系统中，消息发送者发送消息到通道（Channel），[m
[31m-消息收受者从通道（Channel）接收消息。[m
[31m-[m
[31m-     1.顶级接口[m
[31m-     （1）MessageChannel[m
[31m-     MessageChannel是Spring Integration消息通道的顶级接口：[m
[31m-[m
[31m-       public interface MessageChannel {[m
[31m-              public static final long INDEFINITE_TIMEOUT = -1;[m
[31m-              boolean send(Message<?> message);[m
[31m-              boolean send(Message<?> message, long timeout);[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     当使用send方法发送消息时，返回值为true，则表示消息发[m
[31m-送成功。MessageChannel有两大子接口，分别为[m
[31m-PollableChannle（可轮询）和SubscribableChannel（可订阅）。[m
[31m-我们所有的消息通道类都是实现这两个接口。[m
[31m-[m
[31m-     （2）PollableChannel[m
[31m-     PollableChannel具备轮询获得消息的能力，定义如下：[m
[31m-[m
[31m-       public interface PollableChannel extends MessageChannel {[m
[31m-              Message<?> receive();[m
[31m-              Message<?> receive(long timeout);[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     （3）SubscribableChannel[m
[31m-     SubscribableChannel发送消息给订阅了MessageHanlder的订[m
[31m-阅者：[m
[31m-[m
[31m-       public interface SubscribableChannel extends MessageChannel {[m
[31m-              boolean subscribe(MessageHandler handler);[m
[31m-              boolean unsubscribe(MessageHandler handler);[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     2.常用消息通道[m
[31m-[m
[31m-     （1）PublishSubscribeChannel[m
[31m-[m
[31m-     PublishSubscribeChannel允许广播消息给所有订阅者，配置[m
[31m-方式如下：[m
[31m-[m
[31m-              @Bean[m
[31m-               public PublishSubscribeChannel publishSubscribeChannel()[m
[31m-       {[m
[31m-[m
[31m-                      PublishSubscribeChannel channel = new PublishSubscribeChannel()[m
[31m-                    return channel;[m
[31m-              }[m
[31m-[m
[31m-     其中，当前消息通道的id为publishSubscribeChannel。[m
[31m-[m
[31m-     （2）QueueChannel[m
[31m-[m
[31m-     QueueChannel允许消息接收者轮询获得信息，用一个队列[m
[31m-（queue）接收消息，队列的容量大小可配置，配置方式如[m
[31m-下：[m
[31m-[m
[31m-              @Bean[m
[31m-              public QueueChannel queueChannel(){[m
[31m-[m
[31m-                      QueueChannel channel = new QueueChannel(10);[m
[31m-                      return channel;[m
[31m-              }[m
[31m-[m
[31m-     其中QueueChannel构造参数10即为队列的容量。[m
[31m-     （3）PriorityChannel[m
[31m-     PriorityChannel可按照优先级将数据存储到对，它依据于消[m
[31m-息的消息头priority属性，配置方式如下：[m
[31m-[m
[31m-              @Bean[m
[31m-              public PriorityChannel priorityChannel(){[m
[31m-[m
[31m-                      PriorityChannel channel = new PriorityChannel(10);[m
[31m-                      return channel;[m
[31m-              }[m
[31m-[m
[31m-     （4）RendezvousChannel[m
[31m-     RendezvousChannel确保每一个接收者都接收到消息后再发[m
[31m-送消息，配置方式如下：[m
[31m-[m
[31m-              @Bean[m
[31m-              public RendezvousChannel rendezvousChannel(){[m
[31m-              RendezvousChannel channel = new RendezvousChannel();[m
[31m-              return channel;[m
[31m-              }[m
[31m-[m
[31m-     （5）DirectChannel[m
[31m-     DirectChannel是Spring Integration默认的消息通道，它允许[m
[31m-将消息发送给为一个订阅者，然后阻碍发送直到消息被接收，[m
[31m-配置方式如下：[m
[31m-@Bean[m
[31m-public DirectChannel directChannel(){[m
[31m-[m
[31m-       DirectChannel channel = new DirectChannel();[m
[31m-       return channel;[m
[31m-}[m
[31m-[m
[31m-     （6）ExecutorChannel[m
[31m-[m
[31m-     ExecutorChannel可绑定一个多线程的task executor，配置方[m
[31m-式如下：[m
[31m-[m
[31m-             @Bean[m
[31m-              public ExecutorChannel executorChannel(){[m
[31m-              ExecutorChannel channel = new ExecutorChannel(executor());[m
[31m-              return channel;[m
[31m-              }[m
[31m-[m
[31m-              @Bean[m
[31m-              public Executor executor(){[m
[31m-              ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();[m
[31m-[m
[31m-                      taskExecutor.setCorePoolSize(5);[m
[31m-                      taskExecutor.setMaxPoolSize(10);[m
[31m-                      taskExecutor.setQueueCapacity(25);[m
[31m-                      taskExecutor.initialize();[m
[31m-                      return taskExecutor;[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-3.通道拦截器[m
[31m-[m
[31m-Spring   Integration给消息通道提供了通道拦截器[m
[31m-[m
[31m-（ChannelInterceptor），用来拦截发送和接收消息的操作。[m
[31m-[m
[31m-     ChannelInterceptor接口定义如下，我们只需实现这个接口[m
[31m-即可：[m
[31m-public interface ChannelInterceptor {[m
[31m-[m
[31m-                        Message<?>     preSend(Message<?[m
[31m-[m
[31m-> message, MessageChannel channel);[m
[31m-[m
[31m-                        void           postSend(Message<?[m
[31m-[m
[31m-> message, MessageChannel channel, boolean sent);[m
[31m-[m
[31m-              void      afterSendCompletion(Message<?[m
[31m-[m
[31m-> message, MessageChannel channel, boolean sent, Exception ex);[m
[31m-[m
[31m-   boolean preReceive(MessageChannel channel);[m
[31m-[m
[31m-                    Message<?>         postReceive(Message<?[m
[31m-[m
[31m-> message, MessageChannel channel);[m
[31m-[m
[31m-          void          afterReceiveCompletion(Message<?[m
[31m-[m
[31m-> message, MessageChannel channel, Exception ex);[m
[31m-[m
[31m-}[m
[31m-[m
[31m-我们通过下面的代码给所有的channel增加拦截器：[m
[31m-[m
[31m-channel.addInterceptor(someInterceptor);[m
[31m-[m
[31m-9.4.4　Message EndPoint[m
[31m-[m
[31m-消息端点（Message            Endpoint）是真正处理消息的[m
[31m-[m
[31m-（Message）组件，它还可以控制通道的路由。我们可用的消[m
[31m-[m
[31m-息端点包含如下：[m
[31m-[m
[31m-（1）Channel Adapter[m
[31m-[m
[31m-     通道适配器（Channel Adapter）是一种连接外部系统或传[m
[31m-输协议的端点（EndPoint），可以分为入站（inbound）和出站[m
[31m-（outbound）。[m
[31m-[m
[31m-     通道适配器是单向的，入站通道适配器只支持接收消息，[m
[31m-出站通道适配器只支持输出消息。[m
[31m-Spring Integration内置了如下的适配器：[m
[31m-[m
[31m-     RabbitMQ、Feed、File、FTP/SFTP、Gemfire、HTTP、[m
[31m-TCP/UDP、JDBC、JPA、JMS、Mail、MongoDB、Redis、[m
[31m-RMI、Twitter、XMPP、WebServices（SOAP、REST）、[m
[31m-WebSocket等。[m
[31m-[m
[31m-     Spring Integration extensions项目提供了更多的支持，地址[m
[31m-为：https://github.com/spring-projects/spring-integration-[m
[31m-extensions。[m
[31m-[m
[31m-（2）Gateway[m
[31m-[m
[31m-     消息网关（Gateway）类似于Adapter，但是提供了双向的[m
[31m-请求/返回集成方式，也分为入站（inbound）和出站[m
[31m-（outbound）。Spring Integration对相应的Adapter多都提供了[m
[31m-Gateway。[m
[31m-[m
[31m-（3）Service Activator[m
[31m-[m
[31m-     Service Activator可调用Spring的Bean来处理消息，并将处[m
[31m-理后的结果输出到指定的消息通道。[m
[31m-[m
[31m-（4）Router[m
[31m-[m
[31m-路由（Router）可根据消息体类型（Payload    Type[m
[31m-[m
[31m-Router）、消息头的值（Header Value Router）以及定义好的[m
[31m-[m
[31m-接收表（Recipient List Router）作为条件，来决定消息传递到[m
[31m-[m
[31m-的通道。[m
[31m-[m
[31m-（5）Filter[m
[31m-[m
[31m-     过滤器（Filter）类似于路由（Router），不同的是过滤器[m
[31m-不决定消息路由到哪里，而是决定消息是否可以传递给消息通[m
[31m-道。[m
[31m-[m
[31m-     （6）Splitter[m
[31m-[m
[31m-     拆分器（Splitter）将消息拆分为几个部分单独处理，拆分[m
[31m-器处理的返回值是一个集合或者数组。[m
[31m-[m
[31m-     （7）Aggregator[m
[31m-[m
[31m-     聚合器（Aggregator）与拆分器相反，它接收一个[m
[31m-java.util.List作为参数，将多个消息合并为一个消息。[m
[31m-[m
[31m-     （8）Enricher[m
[31m-[m
[31m-     当我们从外部获得消息后，需要增加额外的消息到已有的[m
[31m-消息中，这时就需要使用消息增强器（Enricher）。消息增强[m
[31m-器主要有消息体增强器（Payload Enricher）和消息头增强器[m
[31m-（Header Enricher）两种。[m
[31m-[m
[31m-     （9）Transformer[m
[31m-[m
[31m-     转换器（Transformer）是对获得的消息进行一定的逻辑转[m
[31m-换处理（如数据格式转换）。[m
[31m-[m
[31m-     （10）Bridge[m
[31m-[m
[31m-     使用连接桥（Bridge）可以简单地将两个消息通道连接起[m
[31m-来。[m
[31m-[m
[31m-9.4.5　Spring Integration Java DSL[m
[31m-[m
[31m-     Spring Integration提供了一个IntegrationFlow来定义系统继[m
[31m-承流程，而通过IntegrationFlows和IntegrationFlowBuilder来实[m
[31m-现使用Fluent API来定义流程。在Fluent API里，分别提供了下[m
[31m-面方法来映射Spring Integration的端点（EndPoint）。[m
[31m-[m
[31m-       transform() -> Transformer[m
[31m-       filter() -> Filter[m
[31m-       handle() -> ServiceActivator、Adapter、Gateway[m
[31m-       split() -> Splitter[m
[31m-       aggregate() -> Aggregator[m
[31m-       route() -> Router[m
[31m-       bridge() -> Bridge[m
[31m-[m
[31m-     一个简单的流程定义如下：[m
[31m-[m
[31m-              @Bean[m
[31m-              public IntegrationFlow demoFlow() {[m
[31m-[m
[31m-                                      return IntegrationFlows.from("input") //从[m
[31m-       Channel input获取消息[m
[31m-[m
[31m-                                                                                                                    .[m
[31m-       <String, Integer>transform(Integer::parseInt) //将消息转换成整[m
[31m-       数[m
[31m-[m
[31m-                                           .get(); //获得集成流程并注册为Bean[m
[31m-              }[m
[31m-[m
[31m-9.4.6　实战[m
[31m-[m
[31m-     本章将演示读取https://spring.io/blog.atom的新闻聚合文[m
[31m-件，atom是一种xml文件，且格式是固定的，示例如下：[m
[31m-[m
[31m-       <?xml version="1.0" encoding="UTF-8"?>[m
[31m-       <feed xmlns="http://www.w3.org/2005/Atom">[m
[31m-[m
[31m-           <title>Spring</title>[m
[31m-           <link rel="alternate" href="https://spring.io/blog" />[m
[31m-           <link rel="self" href="https://spring.io/blog.atom" />[m
[31m-           <id>http://spring.io/blog.atom</id>[m
[31m-           <icon>https://spring.io/favicon.ico</icon>[m
[31m-           <updated>2015-07-29T14:46:00Z</updated>[m
[31m-           <entry>[m
[31m-[m
[31m-                      <title>Spring Cloud Connectors 1.2.0 released</title>[m
[31m-                      <link rel="alternate" href="http://..." />[m
[31m-                      <category term="releases" label="Releases" />[m
[31m-                      <author>[m
[31m-[m
[31m-                         <name>some author[m
[31m-[m
[31m-       </name>[m
[31m-                      </author>[m
[31m-                      <id>tag:spring.io,2015-07-27:2196</id>[m
[31m-                      <updated>2015-07-29T14:46:00Z</updated>[m
[31m-                      <content type="html">...</content>[m
[31m-[m
[31m-           </entry>[m
[31m-       </feed>[m
[31m-[m
[31m-     我们将读取到到消息通过分类（Category），将消息转到[m
[31m-不同的消息通道，将分类为releases和engineering的消息写入磁[m
[31m-盘文件，将分类为news的消息通过邮件发送。[m
[31m-[m
[31m-     1.新建Spring Boot项目[m
[31m-[m
[31m-     新建Spring Boot项目，依赖为Integration（spring-boot-[m
[31m-starter-integration）和mail（spring-boot-starter-mail）。[m
[31m-[m
[31m-     项目信息：[m
[31m-[m
[31m-       groupId：com.wisely[m
[31m-       arctifactId:ch9_4[m
[31m-       package: com.wisely.ch9_4[m
[31m-[m
[31m-     另外，我们还要添加Spring Integration对atom及mail的支[m
[31m-持。[m
[31m-[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework.integration</groupId>[m
[31m-                                                             <artifactId>spring-integration-[m
[31m-[m
[31m-       feed</artifactId>[m
[31m-                      </dependency>[m
[31m-[m
[31m-                             <dependency>[m
[31m-                             <groupId>org.springframework.integration</groupId>[m
[31m-[m
[31m-                                                             <artifactId>spring-integration-[m
[31m-       mail</artifactId>[m
[31m-[m
[31m-                      </dependency>[m
[31m-[m
[31m-     本例的所有代码都在入口类中完成。[m
[31m-[m
[31m-     2.读取流程[m
[31m-[m
[31m-                @Value("https://spring.io/blog.atom") // 1[m
[31m-              Resource resource;[m
[31m-[m
[31m-              @Bean(name = PollerMetadata.DEFAULT_POLLER)[m
[31m-              public PollerMetadata poller() { // 2[m
[31m-[m
[31m-                      return Pollers.fixedRate(500).get();[m
[31m-              }[m
[31m-[m
[31m-              @Bean[m
[31m-              public FeedEntryMessageSource feedMessageSource() throws IOExceptio[m
[31m-[m
[31m-                      FeedEntryMessageSource messageSource = new FeedEntryMessageSour[m
[31m-                      return messageSource;[m
[31m-              }[m
[31m-[m
[31m-              @Bean[m
[31m-              public IntegrationFlow myFlow() throws IOException {[m
[31m-[m
[31m-                      return IntegrationFlows.from(feedMessageSource()) //4[m
[31m-                                                  .<SyndEntry, String> route(payload -[m
[31m-[m
[31m-       > payload.getCategories().get(0).getName(),//5[m
[31m-                                                                                                   mapping -[m
[31m-[m
[31m-       > mapping.channelMapping("releases", "releasesChannel") //6[m
[31m-                                                                 .channelMapping("engineering", "enginee[m
[31m-                                                                 .channelMapping("news", "newsChannel"))[m
[31m-                      .get(); // 7[m
[31m-              }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①通过@value注解自动获得https://spring.io/blog.atom的资[m
[31m-源。[m
[31m-[m
[31m-     ②使用Fluent API和Pollers配置默认的轮询方式。[m
[31m-[m
[31m-     ③FeedEntryMessageSource实际为feed：inbound-channel-[m
[31m-adapter，此处即构造feed的入站通道适配器作为数据输入。[m
[31m-[m
[31m-     ④流程从from方法开始。[m
[31m-[m
[31m-     ⑤通过路由方法route来选择路由，消息体（payload）的类[m
[31m-型为SyndEntry，作为判断条件的类型为String，判断的值是通[m
[31m-过payload获得的分类（Categroy）；[m
[31m-[m
[31m-     ⑥通过不同分类的值转向不同的消息通道，若分类为[m
[31m-releases，则转向releasesChannel；若分类为engineering，则转[m
[31m-向engineeringChannel；若分类为news，则转向newsChannel。[m
[31m-[m
[31m-     ⑦通过get方法获得IntegrationFlow实体，配置为Spring的[m
[31m-Bean。[m
[31m-[m
[31m-     3.releases流程[m
[31m-[m
[31m-              @Bean[m
[31m-              public IntegrationFlow releasesFlow() {[m
[31m-[m
[31m-                      return IntegrationFlows.from(MessageChannels.queue("releasesCha[m
[31m-                                    .<SyndEntry, String> transform([m
[31m-                                                                                                   payload -[m
[31m-[m
[31m-       > "《" + payload.getTitle() + "》 " + payload.getLink() + getProperty("l[m
[31m-                                    .handle(Files.outboundAdapter(new File("e:/ springblog"[m
[31m-                                                   .fileExistsMode(FileExistsMode.APPEND)[m
[31m-                                                   .charset("UTF-8")[m
[31m-                                                                  .fileNameGenerator(message -[m
[31m-[m
[31m-       > "releases.txt")[m
[31m-                                                   .get())[m
[31m-[m
[31m-                                    .get();[m
[31m-              }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①从消息通道releasesChannel开始获取数据。[m
[31m-[m
[31m-     ②使用transform方法进行数据转换。payload类型为[m
[31m-SyndEntry，将其转换为字符串类型，并自定义数据的格式。[m
[31m-[m
[31m-     ③用handle方法处理file的出站适配器。Files类是由Spring[m
[31m-Integration Java DSL提供的Fluent API用来构造文件输出的适配[m
[31m-器。[m
[31m-[m
[31m-     4.engineering流程[m
[31m-[m
[31m-              @Bean[m
[31m-              public IntegrationFlow engineeringFlow() {[m
[31m-[m
[31m-                      return IntegrationFlows.from(MessageChannels.queue("engineering[m
[31m-                                    .<SyndEntry, String> transform([m
[31m-                                                                                                              e-[m
[31m-[m
[31m-       > "《" + e.getTitle() + "》 " + e.getLink() + getProperty("line.separato[m
[31m-                                    .handle(Files.outboundAdapter(new File("e:/springblog")[m
[31m-                                                   .fileExistsMode(FileExistsMode.APPEND)[m
[31m-                                                   .charset("UTF-8")[m
[31m-                                                                  .fileNameGenerator(message -[m
[31m-[m
[31m-       > "engineering.txt")[m
[31m-                                                   .get())[m
[31m-[m
[31m-                                    .get();[m
[31m-              }[m
[31m-     代码解释[m
[31m-[m
[31m-     与releases流程相同。[m
[31m-[m
[31m-     5.news流程[m
[31m-[m
[31m-       @Bean[m
[31m-              public IntegrationFlow newsFlow() {[m
[31m-                      return IntegrationFlows.from(MessageChannels.queue("newsChannel[m
[31m-                                    .<SyndEntry, String> transform([m
[31m-                                                                                                   payload -[m
[31m-[m
[31m-       > "《" + payload.getTitle() + "》 " + payload.getLink() + getProperty("l[m
[31m-                                    .enrichHeaders( //1[m
[31m-                                                   Mail.headers()[m
[31m-                                                   .subject("来自Spring的新闻")[m
[31m-                                                   .to("wisely-man@126.com")[m
[31m-                                                   .from("wisely-man@126.com"))[m
[31m-                                    .handle(Mail.outboundAdapter("smtp.126.com") //2[m
[31m-                                                   .port(25)[m
[31m-                                                   .protocol("smtp")[m
[31m-                                                                               .credentials("wisely-[m
[31m-[m
[31m-       man@126.com", "******")[m
[31m-                                                                           .javaMailProperties(p -[m
[31m-[m
[31m-       > p.put("mail.debug", "false")), e -> e.id("smtpOut"))[m
[31m-                                    .get();[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①通过enricherHeader来增加消息头的信息。[m
[31m-[m
[31m-     ②邮件发送的相关信息通过Spring Integration Java DSL提[m
[31m-供的Mail的headers方法来构造。[m
[31m-[m
[31m-     ③使用handle方法来定义邮件发送的出站适配器，使用[m
[31m-Spring Integration Java DSL提供的Mail.outboundAdapter来构[m
[31m-造，这里使用wisely-man@126.com邮箱向自己发送邮件。[m
[31m-     6.运行[m
[31m-     （1）写文件结果[m
[31m-     查看E：\springblog目录，发现多了两个文件，如图9-22所[m
[31m-示。[m
[31m-[m
[31m-                                图9-22　springblag目录[m
[31m-[m
[31m-     engineering.txt文件内容如图9-23所示。[m
[31m-[m
[31m-                          图9-23　engineering.txt文件内容[m
[31m-[m
[31m-     releases.txt文件内容如图9-24所示。[m
[31m-                      图9-24　releases.txt文件内容[m
[31m-[m
[31m-（2）邮箱接收结果[m
[31m-登录邮箱可以看到刚才发送的邮件，如图9-25所示。[m
[31m-[m
[31m-                        图9-25　刚才发送的邮件[m
[31m-第10章　Spring Boot开发部署与测试[m
[31m-[m
[31m-10.1　开发的热部署[m
[31m-[m
[31m-10.1.1　模板热部署[m
[31m-[m
[31m-     在Spring Boot里，模板引擎的页面默认是开启缓存的，如[m
[31m-果修改了页面的内容，则刷新页面是得不到修改后的页面的因[m
[31m-此，我们可以在application.properties中关闭模板引擎的缓存，[m
[31m-例如：[m
[31m-[m
[31m-     Thymeleaf的配置：[m
[31m-[m
[31m-       spring.thymeleaf.cache=false[m
[31m-[m
[31m-     FreeMarker的配置：[m
[31m-[m
[31m-       spring.freemarker.cache=false[m
[31m-[m
[31m-     Groovy的配置：[m
[31m-[m
[31m-       spring.groovy.template.cache=false[m
[31m-     Velocity的配置：[m
[31m-[m
[31m-       spring.velocity.cache=false[m
[31m-[m
[31m-10.1.2　Spring Loaded[m
[31m-[m
[31m-     Spring Loaded可实现修改类文件的热部署。下载Spring[m
[31m-Loaded，地址为：http://repo.spring.io/simple/libs-release-[m
[31m-local/org/springframework/springloaded/1.2.3.RELEASE/springloaded-[m
[31m-1.2.3.RELEASE.jar，安装单击Run Config urations…。如图10-1[m
[31m-所示。[m
[31m-[m
[31m-                          图10-1　单击RunConfigurations[m
[31m-[m
[31m-     在Arguments标签页的vm arguments中填入如下内容，注意[m
[31m-下面指定的springloaded的路径：[m
[31m-[m
[31m-       -javaagent:E:\springloaded-1.2.3.RELEASE.jar -noverify[m
[31m-     页面截图如图10-2所示。[m
[31m-[m
[31m-                              图10-2　Arguments标签页[m
[31m-[m
[31m-10.1.3　JRebel[m
[31m-[m
[31m-     JRebel是Java开发热部署的最佳工具，其对Spring Boot也提[m
[31m-供了极佳的支持。JRebel为收费软件，可试用14天。[m
[31m-[m
[31m-     （1）安装[m
[31m-     打开EclipseMarketPlace，如图10-3所示。[m
[31m-                   图10-3　打开Eclipse Marketplace[m
[31m-[m
[31m-检索JRebel，并安装，如图10-4所示。[m
[31m-                            图10-4　安装JRebel[m
[31m-[m
[31m-重启STS，即可完成安装。[m
[31m-（2）配置使用[m
[31m-注册试用，如图10-5所示。[m
[31m-                                图10-5　注册[m
[31m-[m
[31m-选定Spring Boot，增加JRebel功能，如图10-6所示。[m
[31m-                               图10-6　增加JRebel功能[m
[31m-[m
[31m-     此时为我们添加了一个rebel.xml，用来配置热部署内容，[m
[31m-如图10-7所示。[m
[31m-                               图10-7　增加的rebcl.xml[m
[31m-[m
[31m-     JRebel会对D：/workspace-sts-[m
[31m-3.7.0.RELEASE/ch10/target/classes目录下的文件进行热部署，[m
[31m-如图10-8所示。[m
[31m-[m
[31m-                             图10-8　对文件进行热部署[m
[31m-[m
[31m-     首次启动会询问是否以JRebel启动程序，如图10-9所示。[m
[31m-                       图10-9　询问是否以JRebel启动程序[m
[31m-[m
[31m-     当启动时出现和JRebel相关的信息，表明配置成功，如图[m
[31m-10-10所示。[m
[31m-[m
[31m-                                  图10-10　启动成功[m
[31m-[m
[31m-10.1.4　spring-boot-devtools[m
[31m-[m
[31m-     在Spring Boot项目中添加spring-boot-devtools依赖即可实现[m
[31m-页面，即代码的热部署。[m
[31m-[m
[31m-                  <dependency>[m
[31m-                             <groupId>org.springframework.boot</groupId>[m
[31m-                             <artifactId>spring-boot-devtools</artifactId>[m
[31m-[m
[31m-                      </dependency>[m
[31m-10.2　常规部署[m
[31m-[m
[31m-10.2.1　jar形式[m
[31m-[m
[31m-1.打包[m
[31m-[m
[31m-若我们在新建Spring  Boot项目的时候，选择打包方式[m
[31m-[m
[31m-（Packaging）是jar，则我们只需用：[m
[31m-[m
[31m-mvn pakage[m
[31m-[m
[31m-如图10-11所示。[m
[31m-                        图10-11　运行mvn pakage[m
[31m-[m
[31m-2.运行[m
[31m-可直接使用下面命令运行，结果如图10-12所示。[m
[31m-[m
[31m-java -jar xx.jar[m
[31m-                          图10-12　运行java-jar xx.jar命令[m
[31m-[m
[31m-     3.注册为Linux的服务[m
[31m-[m
[31m-     Linux下运行的软件我们通常把它注册为服务，这样我们就[m
[31m-可以通过命令开启、关闭以及保持开机启动等功能。[m
[31m-[m
[31m-     若想使用此项功能，我们需将代码中关于spring-boot-[m
[31m-maven-plugin的配置修改为：[m
[31m-[m
[31m-              <build>[m
[31m-                      <plugins>[m
[31m-                             <plugin>[m
[31m-                                    <groupId>org.springframework.boot</groupId>[m
[31m-                                                               <artifactId>spring-boot-maven-[m
[31m-[m
[31m-       plugin</artifactId>[m
[31m-                                    <configuration>[m
[31m-                                           <executable>true</executable>[m
[31m-                                    </configuration>[m
[31m-[m
[31m-                             </plugin>[m
[31m-                      </plugins>[m
[31m-              </build>[m
[31m-     然后使用mvn package打包。[m
[31m-[m
[31m-     主流的Linux大多使用init.d或systemd来注册服务。下面以[m
[31m-CentOS 6.6演示init.d注册服务；以CentOS 7.1演示systemd注册[m
[31m-服务。操作系统可选择使用VirtualBox安装或者直接安装在机[m
[31m-器上。[m
[31m-[m
[31m-     用SSH客户端将jar包上传到CentOS的/var/apps下。[m
[31m-[m
[31m-     （1）安装JDK[m
[31m-[m
[31m-     从Oracle官网下载JDK，注意选择的是：jdk-8u51-linux-[m
[31m-x64.rpm。这是红帽系Linux系统专用安装包格式，将JDK下载[m
[31m-放置到Linux下任意目录。[m
[31m-[m
[31m-     执行下面命令安装JDK：[m
[31m-[m
[31m-       rpm -ivh jdk-8u51-linux-x64.rpm[m
[31m-[m
[31m-（2）基于Linux的init.d部署[m
[31m-注册服务，在CentOS 6.6的终端执行：[m
[31m-[m
[31m-sudo ln -s                     /var/apps/ch10-0.0.1-[m
[31m-SNAPSHOT.jar /etc/init.d/ch10[m
[31m-[m
[31m-其中ch10就是我们的服务名。[m
[31m-启动服务：[m
[31m-[m
[31m-service ch10 start[m
[31m-停止服务：[m
[31m-[m
[31m-service ch10 stop[m
[31m-[m
[31m-服务状态：[m
[31m-[m
[31m-service ch10 status[m
[31m-[m
[31m-开机启动：[m
[31m-[m
[31m-chkconfig ch10 on[m
[31m-[m
[31m-     项目日志存放于/var/log/ch10.log下，可用cat或tail等命令查[m
[31m-看。[m
[31m-[m
[31m-     （3）基于Linux的Systemd部署[m
[31m-[m
[31m-     在/etc/systemd/system/目录下新建文件ch10.service，填入下[m
[31m-面内容：[m
[31m-[m
[31m-[Unit]                      -jar  /var/apps/ch10-0.0.1-[m
[31m-Description=ch10[m
[31m-After=syslog.target[m
[31m-[m
[31m-[Service][m
[31m-ExecStart= /usr/bin/java[m
[31m-SNAPSHOT.jar[m
[31m-[m
[31m-[Install][m
[31m-WantedBy=multi-user.target[m
[31m-     注意，在实际使用中修改Description和ExecStart后面的内[m
[31m-容。[m
[31m-[m
[31m-     启动服务：[m
[31m-[m
[31m-       systemctl start ch10[m
[31m-       或systemctl start ch10.service[m
[31m-[m
[31m-     停止服务：[m
[31m-[m
[31m-       systemctl stop ch10[m
[31m-       或systemctl stop ch10.service[m
[31m-[m
[31m-     服务状态：[m
[31m-[m
[31m-       systemctl status ch10[m
[31m-       或systemctl status ch10.service[m
[31m-[m
[31m-     开机启动：[m
[31m-[m
[31m-       systemctl enable ch10[m
[31m-       或systemctl enbale ch10.service[m
[31m-[m
[31m-     项目日志：[m
[31m-[m
[31m-       journalctl -u ch10[m
[31m-       或journalctl -u ch10.service[m
[31m-10.2.2　war形式[m
[31m-[m
[31m-     1.打包方式为war时[m
[31m-     新建Spring Boot项目时可选择打包方式（Packaging）是[m
[31m-war形式，如图10-13所示。[m
[31m-[m
[31m-                           图10-13　选择打包方式为war[m
[31m-[m
[31m-     打包的方式和jar包一致，执行：[m
[31m-[m
[31m-       mvn package[m
[31m-[m
[31m-     结果如图10-14所示。[m
[31m-                                  图10-14　打包结果[m
[31m-[m
[31m-     最后生成的war文件可以放在你喜欢的Servlet容器上运行。[m
[31m-     2.打包方式为jar时[m
[31m-     若我们新建Spring Boot项目时选择打包方式选择的是jar，[m
[31m-部署时我们又想要用war包形式部署，那么怎么将jar形式转换[m
[31m-成war形式呢？当然需求反过来也是一样的。[m
[31m-     我们比较下jar打包和war打包项目文件的不同之处，即可[m
[31m-知做如下修改可将jar打包方式转换成war打包方式。[m
[31m-     在pom.xml文件中，将[m
[31m-[m
[31m-       <packaging>jar</packaging>[m
[31m-[m
[31m-     修改为[m
[31m-[m
[31m-       <packaging>war</packaging>[m
[31m-[m
[31m-     增加下面依赖覆盖默认内嵌的Tomcat依赖：[m
[31m-[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework.boot</groupId>[m
[31m-                                                           <artifactId>spring-boot-starter-[m
[31m-[m
[31m-       tomcat</artifactId>[m
[31m-                             <scope>provided</scope>[m
[31m-[m
[31m-                      </dependency>[m
[31m-[m
[31m-     增加ServletInitializer类，内容如下：[m
[31m-import org.springframework.boot.builder.SpringApplicationBuilder;[m
[31m-import org.springframework.boot.context.web.SpringBootServletInitialize[m
[31m-[m
[31m-public class ServletInitializer extends SpringBootServletInitializer {[m
[31m-[m
[31m-       @Override[m
[31m-       protected SpringApplicationBuilder configure(SpringApplicationBuild[m
[31m-[m
[31m-              return application.sources(Ch10warApplication.class);[m
[31m-       }[m
[31m-[m
[31m-}[m
[31m-10.3　云部署——基于Docker的部署[m
[31m-[m
[31m-     本节我们将在CentOS 7.1上演示用Docker部署Spring Boot[m
[31m-程序。前面我们讲述了使用已经编译好的Docker镜像，本节我[m
[31m-们将讲述如何编译自己的Docker镜像，并运行镜像的容器。[m
[31m-[m
[31m-     主流的云计算（PAAS）平台都支持发布Docker镜像。[m
[31m-Docker是使用Dokerfile文件来编译自己的镜像的。[m
[31m-[m
[31m-10.3.1　Dockerfile[m
[31m-[m
[31m-     Dockerfile主要有如下的指令。[m
[31m-     （1）FROM指令[m
[31m-     FROM指令指明了当前镜像继承的基镜像。编译当前镜像[m
[31m-时会自动下载基镜像。[m
[31m-     示例：[m
[31m-[m
[31m-       FROM ubuntu[m
[31m-[m
[31m-     （2）MAINTAINER指令[m
[31m-     MAINTAINER指令指明了当前镜像的作者。[m
[31m-     示例：[m
[31m-       MAINTAINER wyf[m
[31m-[m
[31m-     （3）RUN指令[m
[31m-     RUN指令可以在当前镜像上执行Linux命令并形成一个新[m
[31m-的层。RUN是编译时（build）的动作。[m
[31m-     示例可有如下两种格式，CMD和ENTRYPOINT也是如[m
[31m-此：[m
[31m-[m
[31m-       RUN /bin/bash -c "echo helloworld"[m
[31m-       或RUN ["/bin/bash", "-c", "echo hello"][m
[31m-[m
[31m-     （4）CMD指令[m
[31m-     CMD指令指明了启动镜像容器时的默认行为。一个[m
[31m-Dockerfile里只能有一个CMD指令。CMD指令里设定的命令可[m
[31m-以在运行镜像时使用参数覆盖。CMD是运行时（run）的动[m
[31m-作。[m
[31m-     示例：[m
[31m-[m
[31m-       CMD echo "this is a test"[m
[31m-[m
[31m-     可被docker run-d image_name echo"this is not a test"覆盖。[m
[31m-     （5）EXPOSE指令[m
[31m-     EXPOSE指明了镜像运行时的容器必需监听指定的端口。[m
[31m-     示例：[m
[31m-[m
[31m-       EXPOSE 8080[m
[31m-[m
[31m-     （6）ENV指令[m
[31m-     ENV指令可用来设置环境变量。[m
[31m-     示例：[m
[31m-[m
[31m-       ENV myName=wyf[m
[31m-       或ENV myName wyf[m
[31m-[m
[31m-     （7）ADD指令[m
[31m-     ADD指令是从当前工作目录复制文件到镜像目录中去。[m
[31m-     示例：[m
[31m-[m
[31m-       ADD test.txt /mydir/[m
[31m-[m
[31m-     （8）ENTRYPOINT指令[m
[31m-     ENTRYPOINT指令可让容器像一个可执行程序一样运行，[m
[31m-这样镜像运行时可以像软件一样接收参数执行。[m
[31m-ENTRYPOINT是运行时（run）的动作。[m
[31m-     示例：[m
[31m-       ENTRYPOINT ["/bin/echo"][m
[31m-[m
[31m-     我们可以向镜像传递参数运行：[m
[31m-[m
[31m-       docker run -d image_name "this is not a test"[m
[31m-[m
[31m-10.3.2　安装Docker[m
[31m-[m
[31m-     通过下面命令安装Docker：[m
[31m-[m
[31m-       yum install docker[m
[31m-[m
[31m-     启动Docker并保持开机自启：[m
[31m-[m
[31m-       systemctl start docker[m
[31m-       systemctl enable docker[m
[31m-[m
[31m-10.3.3　项目目录及文件[m
[31m-[m
[31m-     我们使用源码的ch10docker来作为演示用的Spring Boot项[m
[31m-目，这个项目很简单，只修改了入口类，代码如下：[m
[31m-[m
[31m-       @SpringBootApplication[m
[31m-       @RestController[m
[31m-       public class Ch10dockerApplication {[m
[31m-              @RequestMapping("/")[m
[31m-              public String home() {[m
[31m-                      return "Hello Docker!!";[m
[31m-              }[m
[31m-              public static void main(String[] args) {[m
[31m-                      SpringApplication.run(Ch10dockerApplication.class, args);[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     在CentOS 7.1上的/var/apps/ch10docker目录下放入我们编译[m
[31m-好的ch10docker的jar包，如ch10docker-0.0.1-SNAPSHOT.jar，[m
[31m-在同级目录下新建一个Dokcerfile文件。[m
[31m-[m
[31m-     文件目录如图10-15所示。[m
[31m-[m
[31m-                                  图10-15　文件目录[m
[31m-[m
[31m-     Dockerfile文件内容如下：[m
[31m-[m
[31m-       FROM java:8[m
[31m-       MAINTAINER wyf[m
[31m-       ADD ch10docker-0.0.1-SNAPSHOT.jar app.jar[m
[31m-       EXPOSE 8080[m
[31m-       ENTRYPOINT ["java","-jar","/app.jar"][m
[31m-[m
[31m-     代码解释[m
[31m-     ①基镜像为Java，标签（版本）为8。[m
[31m-     ②作者为wyf。[m
[31m-     ③将我们的ch10docker-0.0.1-SNAPSHOT.jar添加到镜像[m
[31m-中，并重命名为app.jar。[m
[31m-     ④运行镜像的容器，监听8080端口。[m
[31m-     ⑤启动时运行java-jar app.jar。[m
[31m-[m
[31m-10.3.4　编译镜像[m
[31m-[m
[31m-     在/var/apps/ch10docker目录下执行下面命令，执行编译镜[m
[31m-像：[m
[31m-[m
[31m-       docker build -t wisely/ch10docker .[m
[31m-[m
[31m-     其中，wisely/ch10docker为镜像名称，我们设置wisely作为[m
[31m-前缀，这也是Docker镜像的一种命名习惯。[m
[31m-[m
[31m-     注意，最后还有一个“.”，这是用来指明Dockerfile路径[m
[31m-的，“.”表示Dockerfile在当前路径下。[m
[31m-[m
[31m-     编译的过程如图10-16所示。[m
[31m-                            图10-16　编译过程[m
[31m-[m
[31m-这时我们查看本地镜像，如图10-17所示。[m
[31m-[m
[31m-           图10-17　本地镜像[m
[31m-[m
[31m-10.3.5　运行[m
[31m-[m
[31m-通过下面命令运行：[m
[31m-[m
[31m-docker run -d --name ch10 -p 8080:8080 wisely/ch10docker[m
[31m-[m
[31m-查看我们当前的容器状态，如图10-18所示。[m
[31m-[m
[31m-           图10-18　当前容器状态[m
[31m-     当前的CentOS系统的ip为192.168.31.171，访问[m
[31m-http://192.168.31.171：8008，我们可以看到如图10-19所示页[m
[31m-面。[m
[31m-10.4　Spring Boot的测试[m
[31m-[m
[31m-     Spring Boot的测试和Spring MVC的测试类似。Spring Boot[m
[31m-为我们提供了一个@SpringApplicationConfiguration来替代[m
[31m-@ContextConfiguration，用来配置Application Context。[m
[31m-[m
[31m-     在Spring Boot中，每次新建项目的时候，都会自动加上[m
[31m-spring-boot-starter-test的依赖，这样我们就没有必要测试时再[m
[31m-添加额外的jar包。[m
[31m-[m
[31m-Spring  Boot还会建一个当前项目的测试类，位于[m
[31m-[m
[31m-src/test/java的根包下。[m
[31m-[m
[31m-     本节我们将直接演示一个简单的测试，测试某一个控制器[m
[31m-方法是否满足测试用例。[m
[31m-[m
[31m-10.4.1　新建Spring Boot项目[m
[31m-[m
[31m-     新建Spring Boot项目，依赖为JPA（spring-boot-starter-data-[m
[31m-jpa）、Web（spring-boot-starter-web）、hsqldb（内存数据[m
[31m-库）。[m
[31m-[m
[31m-     项目信息：[m
[31m-[m
[31m-groupId：com.wisely[m
[31m-arctifactId:ch10_4[m
[31m-package: com.wisely.ch10_4[m
[31m-10.4.2　业务代码[m
[31m-[m
[31m-     实体类：[m
[31m-[m
[31m-       package com.wisely.ch10_4.domain;[m
[31m-[m
[31m-       import javax.persistence.Entity;[m
[31m-       import javax.persistence.GeneratedValue;[m
[31m-       import javax.persistence.Id;[m
[31m-[m
[31m-       @Entity[m
[31m-       public class Person {[m
[31m-[m
[31m-              @Id[m
[31m-              @GeneratedValue[m
[31m-              private Long id;[m
[31m-              private String name;[m
[31m-[m
[31m-              public Person() {[m
[31m-                      super();[m
[31m-[m
[31m-              }[m
[31m-              public Person(String name) {[m
[31m-[m
[31m-                      super();[m
[31m-                      this.name = name;[m
[31m-              }[m
[31m-              public Long getId() {[m
[31m-                      return id;[m
[31m-              }[m
[31m-              public void setId(Long id) {[m
[31m-                      this.id = id;[m
[31m-              }[m
[31m-              public String getName() {[m
[31m-                      return name;[m
[31m-              }[m
[31m-              public void setName(String name) {[m
[31m-                      this.name = name;[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     数据访问：[m
[31m-       package com.wisely.ch10_4.dao;[m
[31m-       import org.springframework.data.jpa.repository.JpaRepository;[m
[31m-       import com.wisely.ch10_4.domain.Person;[m
[31m-       public interface PersonRepository extends JpaRepository<Person, Long> {[m
[31m-       }[m
[31m-[m
[31m-     控制器：[m
[31m-[m
[31m-       package com.wisely.ch10_4.web;[m
[31m-       import java.util.List;[m
[31m-       import org.springframework.beans.factory.annotation.Autowired;[m
[31m-       import org.springframework.http.MediaType;[m
[31m-       import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-       import org.springframework.web.bind.annotation.RequestMethod;[m
[31m-       import org.springframework.web.bind.annotation.RestController;[m
[31m-       import com.wisely.ch10_4.dao.PersonRepository;[m
[31m-       import com.wisely.ch10_4.domain.Person;[m
[31m-       @RestController[m
[31m-       @RequestMapping("/person")[m
[31m-       public class PersonController {[m
[31m-[m
[31m-              @Autowired[m
[31m-              PersonRepository personRepository;[m
[31m-              @RequestMapping(method = RequestMethod.GET,produces = {MediaType.AP[m
[31m-              public List<Person> findAll(){[m
[31m-[m
[31m-                      return personRepository.findAll();[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-10.4.3　测试用例[m
[31m-package com.wisely.ch10_4;[m
[31m-[m
[31m-import org.junit.Assert;[m
[31m-import org.junit.Before;[m
[31m-import org.junit.Test;[m
[31m-import org.junit.runner.RunWith;[m
[31m-import org.springframework.beans.factory.annotation.Autowired;[m
[31m-import org.springframework.boot.test.SpringApplicationConfiguration;[m
[31m-import org.springframework.http.MediaType;[m
[31m-import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;[m
[31m-import org.springframework.test.context.web.WebAppConfiguration;[m
[31m-import org.springframework.test.web.servlet.MockMvc;[m
[31m-import org.springframework.test.web.servlet.MvcResult;[m
[31m-import org.springframework.test.web.servlet.request.MockMvcRequestBuild[m
[31m-import org.springframework.test.web.servlet.setup.MockMvcBuilders;[m
[31m-import org.springframework.transaction.annotation.Transactional;[m
[31m-import org.springframework.web.context.WebApplicationContext;[m
[31m-[m
[31m-import com.fasterxml.jackson.core.JsonProcessingException;[m
[31m-import com.fasterxml.jackson.databind.ObjectMapper;[m
[31m-import com.wisely.ch10_4.dao.PersonRepository;[m
[31m-import com.wisely.ch10_4.domain.Person;[m
[31m-[m
[31m-@RunWith(SpringJUnit4ClassRunner.class)[m
[31m-@SpringApplicationConfiguration(classes = Ch104Application.class) //1[m
[31m-@WebAppConfiguration[m
[31m-@Transactional //2[m
[31m-public class Ch104ApplicationTests {[m
[31m-[m
[31m-       @Autowired[m
[31m-       PersonRepository personRepository;[m
[31m-[m
[31m-       MockMvc mvc;[m
[31m-[m
[31m-       @Autowired[m
[31m-       WebApplicationContext webApplicationContext;[m
[31m-[m
[31m-       String expectedJson;[m
[31m-[m
[31m-       @Before //3[m
[31m-       public void setUp() throws JsonProcessingException{[m
[31m-[m
[31m-              Person p1 = new Person("wyf");[m
[31m-              Person p2 = new Person("wisely");[m
[31m-              personRepository.save(p1);[m
[31m-              personRepository.save(p2);[m
[31m-[m
[31m-              expectedJson =Obj2Json(personRepository.findAll()); //4[m
[31m-              mvc = MockMvcBuilders.webAppContextSetup(webApplicationContext)[m
[31m-       }[m
[31m-[m
[31m-       protected String Obj2Json(Object obj) throws JsonProcessingExceptio[m
[31m-              ObjectMapper mapper = new ObjectMapper();[m
[31m-              return mapper.writeValueAsString(obj);[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-       @Test[m
[31m-       public void testPersonController() throws Exception {[m
[31m-[m
[31m-              String uri="/person";[m
[31m-              MvcResult result = mvc.perform(MockMvcRequestBuilders.get(uri).[m
[31m-[m
[31m-                                                                                                                    .andRet[m
[31m-              int status = result.getResponse().getStatus(); //7[m
[31m-              String content = result.getResponse().getContentAsString(); //8[m
[31m-[m
[31m-                                         Assert.assertEquals("错误，正确的返回值为[m
[31m-200",200, status); //9[m
[31m-[m
[31m-                             Assert.assertEquals("错误，返回值和预期返回值不一[m
[31m-致", expectedJson,content); //10[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-}[m
[31m-[m
[31m-代码解释[m
[31m-[m
[31m-①使用@SpringApplicationConfiguration替代[m
[31m-[m
[31m-@ContextConfiguration来配置Spring  Boot的Application[m
[31m-[m
[31m-Context。[m
[31m-[m
[31m-     ②使用@Transactional注解，确保每次测试后的数据将会被[m
[31m-回滚。[m
[31m-[m
[31m-     ③使用Junit的@Before注解可在测试开始前进行一些初始[m
[31m-化的工作。[m
[31m-[m
[31m-④获得期待返回的JSON字符串。[m
[31m-[m
[31m-⑤将对象转换成JSON字符串。[m
[31m-     ⑥获得一个request的执行结果。[m
[31m-     ⑦获得request执行结果的状态。[m
[31m-     ⑧获得request执行结果的内容。[m
[31m-     ⑨将预期状态200和实际状态比较。[m
[31m-     ⑩将预期字符串和返回字符串比较。[m
[31m-[m
[31m-10.4.4　执行测试[m
[31m-[m
[31m-     我们可以使用maven命令执行测试：[m
[31m-[m
[31m-       mvn clean package[m
[31m-[m
[31m-     结果如图10-20所示。[m
[31m-[m
[31m-                                  图10-20　测试结果[m
[31m-[m
[31m-     我们还可以在STS直接使用Run As→JUnit Test，效果如图[m
[31m-10-21所示。[m
[31m-图10-21　直接使用RunAs→Junit Test[m
[31m-第11章　应用监控[m
[31m-[m
[31m-     Spring Boot提供了运行时的应用监控和管理的功能。我们[m
[31m-可以通过http、JMX、SSH协议来进行操作。审计、健康及指[m
[31m-标信息将会自动得到。[m
[31m-[m
[31m-     Spring Boot提供了监控和管理端点，如表11-1所示。[m
[31m-[m
[31m-                              表11-1　监控和管理端点[m
[31m-11.1　http[m
[31m-[m
[31m-     我们可以通过http实现对应用的监控和管理，我们只需在[m
[31m-pom.xml中增加下面依赖即可：[m
[31m-[m
[31m-              <dependency>[m
[31m-                             <groupId>org.springframework.boot</groupId>[m
[31m-                                                           <artifactId>spring-boot-starter-[m
[31m-[m
[31m-       actuator</artifactId>[m
[31m-              </dependency>[m
[31m-[m
[31m-既然通过http监控和管理，那么我们的项目中必然需要[m
[31m-[m
[31m-Web的依赖。本节需新建Spring           Boot项目，依赖选择为：[m
[31m-[m
[31m-Actuator、Web、HATEOAS。[m
[31m-[m
[31m-11.1.1　新建Spring Boot项目[m
[31m-[m
[31m-     新建Spring Boot项目，依赖为Actuator（spring-boot-starter-[m
[31m-actuator）、Web（spring-boot-starter-web）、[m
[31m-HATEOAS（spring-hateoas）。[m
[31m-[m
[31m-     项目信息：[m
[31m-[m
[31m-groupId：com.wisely[m
[31m-arctifactId:ch11_1[m
[31m-package: com.wisely. ch11_1[m
[31m-11.1.2　测试端点[m
[31m-[m
[31m-     项目建立好之后我们即可测试各个端点。[m
[31m-     （1）actuator[m
[31m-     访问http://localhost：8080/actuator，效果如图11-1所示。[m
[31m-[m
[31m-                                 图11-1　访问actuator[m
[31m-[m
[31m-     （2）autoconfig[m
[31m-     访问http://localhost：8080/autoconfig，效果如图11-2所示。[m
[31m-                         图11-2　访问autoconfig[m
[31m-[m
[31m-（3）beans[m
[31m-访问http://localhost：8080/beans，效果如图11-3所示。[m
[31m-[m
[31m-         图11-3　访问beans[m
[31m-[m
[31m-（4）dump[m
[31m-     访问http://localhost：8080/dump，效果如图11-4所示。[m
[31m-[m
[31m-                                  图11-4　访问beans[m
[31m-[m
[31m-     （5）configprops[m
[31m-     访问http://localhost：8080/configprops，效果如图11-5所[m
[31m-示。[m
[31m-     （6）health[m
[31m-     访问http://localhost：8080/health，效果如图11-6所示。[m
[31m-     （7）info[m
[31m-     访问http://localhost：8080/info，效果如图11-7所示。[m
[31m-图11-5　访问ConfigProps[m
[31m-   图11-6　访问health[m
[31m-                             图11-7　访问info[m
[31m-[m
[31m-（8）metrics[m
[31m-访问http://localhost：8080/metrics，效果如图11-8所示。[m
[31m-[m
[31m-                           图11-8　访问metrics[m
[31m-[m
[31m-（9）mappings[m
[31m-访问http://localhost：8080/mappings，效果如图11-9所示。[m
[31m-                                图11-9　访问mappings[m
[31m-[m
[31m-     （10）shutdown[m
[31m-     shutdown端点默认是关闭的，我们可以在[m
[31m-application.properties中开启：[m
[31m-[m
[31m-       endpoints.shutdown.enabled=true[m
[31m-[m
[31m-     shutdown端点不支持GET提交，可以直接在浏览器上访问[m
[31m-地址，所以我们使用PostMan来测试。用POST方式访问[m
[31m-http://localhost：8080/shutdown，效果如图11-10所示。[m
[31m-[m
[31m-     控制台效果如图11-11所示。[m
[31m-                         图11-10　访问shutdown[m
[31m-[m
[31m-                           图11-11　控制台效果[m
[31m-[m
[31m-（11）trace[m
[31m-访问http://localhost：8080/trace，效果如图11-12所示。[m
[31m-                                  图11-12　访问trace[m
[31m-[m
[31m-11.1.3　定制端点[m
[31m-[m
[31m-     定制端点一般通过endpoints+端点名+属性名来设置，每段[m
[31m-之间用.隔开。[m
[31m-[m
[31m-     （1）修改端点id[m
[31m-[m
[31m-       endpoints.beans.id=mybeans[m
[31m-[m
[31m-     此时我们访问的端点地址就变成了：http://localhost：[m
[31m-8080/mybeans。[m
[31m-[m
[31m-     （2）开启端点[m
[31m-     例如我们开启shutdown端点：[m
[31m-       endpoints.shutdown.enabled=true[m
[31m-[m
[31m-     （3）关闭端点[m
[31m-     关闭beans端点：[m
[31m-[m
[31m-       endpoints.beans.enabled=false[m
[31m-[m
[31m-     （4）只开启所需端点[m
[31m-     若只开启所需端点的话，我们可以通过关闭所有的端点，[m
[31m-然后再开启所需端点来实现，例如：[m
[31m-[m
[31m-       endpoints.enabled=false[m
[31m-       endpoints.beans.enabled=true[m
[31m-[m
[31m-     （5）定制端点访问路径[m
[31m-     默认的端点访问路径是在根目录下的，如http://localhost：[m
[31m-8080/beans。我们可以通过下面配置修改：[m
[31m-[m
[31m-       management.context-path=/manage[m
[31m-[m
[31m-     此时我们的访问地址就变成了：http://localhost：[m
[31m-8080/manage/beans[m
[31m-[m
[31m-     （6）定制端点访问端口[m
[31m-     当我们基于安全的考虑，不曝露端点的端口到外部时，就[m
[31m-需要应用本身的业务端口和端点所用的端口使用不同的端口。[m
[31m-我们可以通过如下配置改变端点访问的端口：[m
[31m-[m
[31m-       management.port=8081[m
[31m-[m
[31m-     （7）关闭http端点[m
[31m-     管理http端点可使用下面配置实现：[m
[31m-[m
[31m-       management.port=-1[m
[31m-[m
[31m-11.1.4　自定义端点[m
[31m-[m
[31m-     当Spring Boot提供的端点不能满足我们特殊的需求，而我[m
[31m-们又需要对特殊的应用状态进行监控的时候，就需要自定义一[m
[31m-个端点。[m
[31m-[m
[31m-     本例演示当应用改变了一个变量的状态时，我们可以通过[m
[31m-端点监控变量的状态。[m
[31m-[m
[31m-     我们只需继承一个AbstractEndpoint的实现类，并将其注册[m
[31m-为Bean即可。[m
[31m-[m
[31m-     1.状态服务[m
[31m-[m
[31m-       package com.wisely.ch11_1;[m
[31m-       import org.springframework.stereotype.Service;[m
[31m-@Service[m
[31m-public class StatusService {[m
[31m-[m
[31m-       private String status;[m
[31m-[m
[31m-       public String getStatus() {[m
[31m-              return status;[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-       public void setStatus(String status) {[m
[31m-              this.status = status;[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-}[m
[31m-[m
[31m-代码解释[m
[31m-[m
[31m-此类无任何特别，仅为改变status的值。[m
[31m-[m
[31m-2.自定义端点[m
[31m-[m
[31m-package com.wisely.ch11_1;[m
[31m-[m
[31m-import org.springframework.beans.BeansException;[m
[31m-import org.springframework.boot.actuate.endpoint.AbstractEndpoint;[m
[31m-import org.springframework.boot.context.properties.ConfigurationPropert[m
[31m-import org.springframework.context.ApplicationContext;[m
[31m-import org.springframework.context.ApplicationContextAware;[m
[31m-[m
[31m-@ConfigurationProperties(prefix = "endpoints.status", ignoreUnknownFiel[m
[31m-public class StatusEndPoint extends AbstractEndpoint<String> implements[m
[31m-[m
[31m-       ApplicationContext context;[m
[31m-[m
[31m-       public StatusEndPoint() {[m
[31m-              super("status");[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-       @Override[m
[31m-              public String invoke() { //3[m
[31m-                      StatusService statusService = context.getBean(StatusService.cla[m
[31m-[m
[31m-                      return "The Current Status is :"+statusService.getStatus();[m
[31m-              }[m
[31m-[m
[31m-              @Override[m
[31m-              public void setApplicationContext(ApplicationContext arg0) throws B[m
[31m-[m
[31m-                      this.context = arg0;[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①通过@ConfigurationProperties的设置，我们可以在[m
[31m-application.properties中通过endpoints.status配置我们的端点。[m
[31m-[m
[31m-     ②继承AbstractEndpoint类，AbstractEndpoint是Endpoint接[m
[31m-口的抽象实现，当前类一定要重写invoke方法。实现[m
[31m-ApplicationContextAware接口可以让当前类对Spring容器的资[m
[31m-源有意识，即可访问容器的资源。[m
[31m-[m
[31m-     ③通过重写invoke方法，返回我们要监控的内容。[m
[31m-[m
[31m-     3.注册端点并定义演示控制器[m
[31m-[m
[31m-       package com.wisely.ch11_1;[m
[31m-[m
[31m-       import org.springframework.beans.factory.annotation.Autowired;[m
[31m-       import org.springframework.boot.SpringApplication;[m
[31m-       import org.springframework.boot.actuate.endpoint.Endpoint;[m
[31m-       import org.springframework.boot.autoconfigure.SpringBootApplication;[m
[31m-       import org.springframework.context.annotation.Bean;[m
[31m-       import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-       import org.springframework.web.bind.annotation.RestController;[m
[31m-       @SpringBootApplication[m
[31m-       @RestController[m
[31m-       public class DemoApplication {[m
[31m-[m
[31m-              @Autowired[m
[31m-              StatusService statusService;[m
[31m-[m
[31m-              public static void main(String[] args) {[m
[31m-                      SpringApplication.run(DemoApplication.class, args);[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-              @Bean //1[m
[31m-              public Endpoint<String> status() {[m
[31m-              Endpoint<String> status = new StatusEndPoint();[m
[31m-              return status;[m
[31m-              }[m
[31m-              @RequestMapping("/change") //2[m
[31m-              public String changeStatus(String status){[m
[31m-              statusService.setStatus(status);[m
[31m-              return "OK";[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①注册端点的Bean。[m
[31m-[m
[31m-     ②定义控制器方法用来改变status。[m
[31m-[m
[31m-     4.运行[m
[31m-[m
[31m-     启动程序，访问http://localhost：8080/status，此时效果如[m
[31m-图11-13所示。[m
[31m-                                  图11-13　访问status[m
[31m-[m
[31m-     当我们通过控制器访问http://localhost：8080/change？[m
[31m-status=running，改变status的值的时候，如图11-14所示。[m
[31m-[m
[31m-                               图11-14　改变status的值[m
[31m-[m
[31m-     我们在通过访问http://localhost：8080/status查看status的状[m
[31m-态时，结果如图11-15所示。[m
[31m-[m
[31m-                             图11-15　查看status的状态[m
[31m-11.1.5　自定义HealthIndicator[m
[31m-[m
[31m-     Health信息都是从ApplicationContext中所有的[m
[31m-HealthIndicator的Bean中收集的，Spring中内置了一些[m
[31m-HealthIndicator，如表11-2所示。[m
[31m-[m
[31m-                     表11-2　Spring中内置的HealthIndicator[m
[31m-[m
[31m-     在本节我们讲述了如何定制自己的HealthIndicator，定制自[m
[31m-己的HealthIndicator我们只需定一个实现HealthIndicator接口的[m
[31m-类，并注册为Bean即可。接着上面的例子，我们依然通过上例[m
[31m-的status值决定健康情况，只有当status的值为running时才为健[m
[31m-康。[m
[31m-[m
[31m-     1.HealthIndicator实现类[m
[31m-[m
[31m-       package com.wisely.ch11_1;[m
[31m-       import org.springframework.beans.factory.annotation.Autowired;[m
[31m-       import org.springframework.boot.actuate.health.Health;[m
[31m-       import org.springframework.boot.actuate.health.HealthIndicator;[m
[31m-       import org.springframework.stereotype.Component;[m
[31m-       @Component[m
[31m-       public class StatusHealth implements HealthIndicator {//1[m
[31m-[m
[31m-              @Autowired[m
[31m-              StatusService statusService;[m
[31m-              @Override[m
[31m-              public Health health() {[m
[31m-[m
[31m-                      String status = statusService.getStatus();[m
[31m-                                 if(status == null||!status.equals("running"))[m
[31m-[m
[31m-       {[m
[31m-       return Health.down().withDetail("Error", "Not Running").build(); //2[m
[31m-[m
[31m-                      }[m
[31m-                      return Health.up().build(); //3[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①实现HealthIndicator接口并重写health（）方法。[m
[31m-[m
[31m-     ②当status的值为非running时构造失败。[m
[31m-[m
[31m-     ③其余情况运行成功。[m
[31m-[m
[31m-     2.运行[m
[31m-[m
[31m-     运行程序，访问http://localhost：8080/health，如图11-16所[m
[31m-示。[m
[31m-                                 图11-16　访问health[m
[31m-[m
[31m-     这时我们修改status的值为running，访问http://localhost：[m
[31m-8080/change？status=running，如图11-17所示。[m
[31m-[m
[31m-                                图11-17　访问running[m
[31m-[m
[31m-     再次访问http://localhost：8080/health，显示如图11-18所[m
[31m-示。[m
[31m-图11-18　再次访问heath[m
[31m-11.2　JMX[m
[31m-[m
[31m-     我们也可以通过JMX对应用进行监控和管理。本节应用上[m
[31m-一节的例子演示。[m
[31m-[m
[31m-     在控制台调用Java内置的jconsole来实现JMX监控，如图[m
[31m-11-19所示。[m
[31m-[m
[31m-                                图11-19　调用jconsole[m
[31m-[m
[31m-     这时会打开jconsole页面，选择当前程序的进程，如图11-[m
[31m-20所示。[m
[31m-                                图11-20　jconsole页面[m
[31m-[m
[31m-     进入界面后，在MBean标签的org.springframework.boot域[m
[31m-下可对我们的程序进行监控和管理，如图11-21所示。[m
[31m-图11-21　MBean标签[m
[31m-11.3　SSH[m
[31m-[m
[31m-     我们还可以通过SSH或TELNET监控和管理我们的应用，[m
[31m-这一点Spring Boot是借助CraSH（http://www.crashub.org）来实[m
[31m-现的。在应用中，我们只需在Spring Boot项目中添加spring-[m
[31m-boot-starter-remote-shell依赖即可。[m
[31m-[m
[31m-11.3.1　新建Spring Boot项目[m
[31m-[m
[31m-     新建Spring Boot项目，依赖为Remote Shell（spring-boot-[m
[31m-starter-remote-shell）。[m
[31m-[m
[31m-     项目信息：[m
[31m-[m
[31m-       groupId：com.wisely[m
[31m-       arctifactId:ch11_3[m
[31m-       package: com.wisely. ch11_3[m
[31m-[m
[31m-11.3.2　运行[m
[31m-[m
[31m-     启动程序，此时控制台会提示SSH访问的密码，如图11-22[m
[31m-所示。[m
[31m-                              图11-22　SSH访问的密码[m
[31m-[m
[31m-     这样就可以通过下面信息登录我们的程序（SSH客户端可[m
[31m-使用puTTY、SecureCRT等），登录界面如图11-23所示。[m
[31m-[m
[31m-       主机:localhost[m
[31m-       端口:2000[m
[31m-       账号:user[m
[31m-       密码：上面截图[m
[31m-                                  图11-23　登录界面[m
[31m-[m
[31m-     登录后的效果如图11-24所示。[m
[31m-[m
[31m-                               图11-24　登录后的效果[m
[31m-[m
[31m-11.3.3　常用命令[m
[31m-[m
[31m-     （1）help[m
[31m-     输入help命令，获得命令列表，如图11-25所示。[m
[31m-                            图11-25　命令列表[m
[31m-[m
[31m-（2）metrics[m
[31m-输入metrics命令，效果如图11-26所示。[m
[31m-[m
[31m-                        图11-26　输入metrics命令[m
[31m-     （3）endpoint[m
[31m-     输入下面命令获得端点列表，如图11-27所示。[m
[31m-[m
[31m-       endpoint list[m
[31m-[m
[31m-                                  图11-27　端点列表[m
[31m-[m
[31m-     调用某一个端点，如调用health，如图11-28所示。[m
[31m-[m
[31m-       endpoint invoke health[m
[31m-[m
[31m-                                 图11-28　调用health[m
[31m-[m
[31m-11.3.4　定制登录用户[m
[31m-[m
[31m-     我们可以通过在application.properties下定制下面的属性，[m
[31m-实现用户的账号密码的定制：[m
[31m-[m
[31m-       shell.auth.simple.user.name=wyf[m
[31m-       shell.auth.simple.user.password=wyf[m
[31m-[m
[31m-11.3.5　扩展命令[m
[31m-[m
[31m-     可以在spring-boot-starter-remote-shell.jar中看到Spring Boot[m
[31m-为我们定制的命令，如图11-29所示。[m
[31m-[m
[31m-                         图11-29　Spring Boot定制的命令[m
[31m-[m
[31m-     如beans.groovy的代码为：[m
[31m-[m
[31m-       package commands[m
[31m-       import org.springframework.boot.actuate.endpoint.BeansEndpoint[m
[31m-       class beans {[m
[31m-[m
[31m-              @Usage("Display beans in ApplicationContext")[m
[31m-              @Command[m
[31m-              def main(InvocationContext context) {[m
[31m-                      def result = [:][m
[31m-                      context.attributes['spring.beanfactory'].getBeansOfType(BeansEn[m
[31m-       >[m
[31m-[m
[31m-                             result.put(name, endpoint.invoke())[m
[31m-                      }[m
[31m-                      result.size() == 1 ? result.values()[0] : result[m
[31m-              }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     需要特别指出的是，这里使用了Groovy语言来编制命令，[m
[31m-Groovy语言是由Spring主导的运行于JVM的动态语言，是可以[m
[31m-替代Java作为开发语言的。在这里还需说明的是，Spring Boot[m
[31m-既可以用Java语言开发，也可以用Groovy语言开发，本书为了[m
[31m-减少学习曲线，以及考虑绝大数读者的使用现状，所以没有对[m
[31m-Groovy语言及Groovy开发Spring进行介绍，读者如有兴趣可自[m
[31m-行学习Groovy。[m
[31m-[m
[31m-     另一个值得注意的是InvocationContext，我们可以通过[m
[31m-InvocationContext获得表11-3所示的属性。[m
[31m-[m
[31m-                                      表11-3　属性[m
[31m-[m
[31m-     这里将以Groovy语言演示一个命令的定制，命令可放在以[m
[31m-下目录，Spring Boot会自动扫描：[m
[31m-[m
[31m-       classpath*:/commands/**[m
[31m-       classpath*:/crash/commands/**[m
[31m-[m
[31m-     在src/main/resources下新建commands文件夹，新建[m
[31m-hello.groovy，内容如下：[m
[31m-[m
[31m-       package commands[m
[31m-       import org.crsh.cli.Command[m
[31m-       import org.crsh.cli.Usage[m
[31m-       import org.crsh.command.InvocationContext[m
[31m-       class hello {[m
[31m-[m
[31m-              @Usage("Say Hello")//1[m
[31m-              @Command//2[m
[31m-              def main(InvocationContext context) {[m
[31m-[m
[31m-                      def bootVersion = context.attributes['spring.boot.version'];//3[m
[31m-                      def springVersion = context.attributes['spring.version']//4[m
[31m-[m
[31m-                      return "Hello,your Spring Boot version is "+bootVersion +",your[m
[31m-[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①使用@Usage注解解释该命令的用途。[m
[31m-[m
[31m-     ②使用@Command注解当前是一个CRaSH命令。[m
[31m-[m
[31m-     ③获得Spring Boot的版本，注意Groovy的方法和变量声明[m
[31m-关键字为def。[m
[31m-[m
[31m-     ④获得Spring框架的版本。[m
[31m-[m
[31m-     ⑤返回命令执行结果。[m
[31m-[m
[31m-     运行[m
[31m-[m
[31m-     此时我们运行程序，并以SSH客户端登录，输入hello命[m
[31m-令，可获得如图11-32所示结果。[m
[31m-图11-32　运行程序[m
[31m-第12章　分布式系统开发[m
[31m-[m
[31m-12.1　微服务、原生云应用[m
[31m-[m
[31m-     微服务（Microservice）是近两年来非常火的概念，它的含[m
[31m-义是：使用定义好边界的小的独立组件来做好一件事情。微服[m
[31m-务是相对于传统单块式架构而言的。[m
[31m-[m
[31m-     单块式架构是一份代码，部署和伸缩都是基于单个单元进[m
[31m-行的。它的优点是易于部署，但是面临着可用性低、可伸缩性[m
[31m-差、集中发布的生命周期以及违反单一功能原则（Single[m
[31m-Responsibility Principle）。微服务的出现解决了这个问题，它[m
[31m-以单个独立的服务来做一个功能，且要做好这个功能。但使用[m
[31m-微服务不可避免地将功能按照边界拆分为单个服务，体现出分[m
[31m-布式的特征，这时每个微服务之间的通信将是我们要解决的问[m
[31m-题。[m
[31m-[m
[31m-     Spring Cloud的出现为我们解决分布式开发常用到的问题给[m
[31m-出了完整的解决方案。Spring Cloud基于Spring Boot，为我们[m
[31m-提供了配置管理、服务发现、断路器、代理服务等我们在做分[m
[31m-布式开发时常用问题的解决方案。[m
[31m-[m
[31m-     基于Spring Cloud开发的程序特别适合在Docker或者其他专[m
[31m-业PaaS（平台即服务，如Cloud Foundry）部署，所以又称作原[m
[31m-生云应用（Cloud Native Application）。[m
[31m-12.2　Spring Cloud快速入门[m
[31m-[m
[31m-12.2.1　配置服务[m
[31m-[m
[31m-     Spring Cloud提供了Config Server，它有在分布式系统开发[m
[31m-中外部配置的功能。通过Config Server，我们可以集中存储所[m
[31m-有应用的配置文件。[m
[31m-[m
[31m-     Config Server支持在git或者在文件系统中放置配置文件。[m
[31m-可以使用以下格式来区分不同应用的不同配置文件：[m
[31m-[m
[31m-       /{application}/{profile}[/{label}][m
[31m-       /{application}-{profile}.yml[m
[31m-       /{label}/{application}-{profile}.yml[m
[31m-       /{application}-{profile}.properties[m
[31m-       /{label}/{application}-{profile}.properties[m
[31m-[m
[31m-     Spring Cloud提供了注解@EnableConfigServer来启用配置[m
[31m-服务。[m
[31m-[m
[31m-12.2.2　服务发现[m
[31m-[m
[31m-     Spring Cloud通过Netflix OSS的Eureka来实现服务发现，服[m
[31m-务发现的主要目的是为了让每个服务之间可以互相通信。[m
[31m-[m
[31m-Eureka Server为微服务注册中心。[m
[31m-[m
[31m-Spring  Cloud使用注解的方式提供了Eureka服务端[m
[31m-（@EnableEurekaServer）和客户端（@EnableEurekaClient）。[m
[31m-[m
[31m-12.2.3　路由网关[m
[31m-[m
[31m-     路由网关的主要目的是为了让所有的微服务对外只有一个[m
[31m-接口，我们只需访问一个网关地址，即可由网关将我们的请求[m
[31m-代理到不同的服务中。[m
[31m-[m
[31m-     Spring Cloud是通过Zuul来实现的，支持自动路由映射到在[m
[31m-Eureka Server上注册的服务。Spring Cloud提供了注解[m
[31m-@EnableZuulProxy来启用路由代理。[m
[31m-[m
[31m-12.2.4　负载均衡[m
[31m-[m
[31m-     Spring Cloud提供了Ribbon和Feign作为客户端的负载均[m
[31m-衡。在Spring Cloud下，使用Ribbon直接注入一个RestTemplate[m
[31m-对象即可，此RestTemplate已做好负载均衡的配置；而使用[m
[31m-Feign只需定义个注解，有@FeignClient注解的接口，然后使用[m
[31m-@RequestMapping注解在方法上映射远程的REST服务，此方[m
[31m-法也是做好负载均衡配置的。[m
[31m-[m
[31m-12.2.5　断路器[m
[31m-[m
[31m-     断路器（Circuit Breaker），主要是为了解决当某个方法调[m
[31m-用失败的时候，调用后备方法来替代失败的方法，以达到容[m
[31m-错、阻止级联错误等功能。[m
[31m-[m
[31m-     Spring Cloud使用@EnableCircuitBreaker来启用断路器支[m
[31m-持，使用@HystrixCommand的fallbackMethod来指定后备方[m
[31m-法。[m
[31m-[m
[31m-     Spring Cloud还给我们提供了一个控制台来监控断路器的运[m
[31m-行情况。通过@EnableHystrixDashboard注解开启。[m
[31m-12.3　实战[m
[31m-[m
[31m-     实战部分主要由6个微服务组成：[m
[31m-     config：配置服务器，本例为person-service和some-service[m
[31m-提供外部配置。[m
[31m-     discovery：Eureka Server为微服务提供注册。[m
[31m-     person：为UI模块提供保存person的REST服务。[m
[31m-     some：为UI模块返回一段字符串。[m
[31m-     UI：作为应用网关，提供外部访问的唯一入口。使用Feign[m
[31m-消费person服务、Ribbon消费some服务，且都提供断路器功[m
[31m-能；[m
[31m-     monitor：监控UI模块中的断路器。[m
[31m-     本例没有完全列出代码，读者可自行翻阅源码ch12。[m
[31m-[m
[31m-12.3.1　项目构建[m
[31m-[m
[31m-     新建模块化的maven项目ch12，其pom.xml文件的主要部分[m
[31m-如下。[m
[31m-[m
[31m-     （1）使用<modules>标签来实现模块化：[m
[31m-[m
[31m-              <modules>[m
[31m-                      <module>config</module>[m
[31m-                      <module>discovery</module>[m
[31m-                      <module>ui</module>[m
[31m-                      <module>person</module>[m
[31m-                      <module>some</module>[m
[31m-                      <module>monitor</module>[m
[31m-              </modules>[m
[31m-[m
[31m-     （2）使用spring-cloud-starter-parent替代spring-boot-starter-[m
[31m-parent，其具备spring-boot-starter-parent的同样功能并附加了[m
[31m-Spring Cloud的依赖，当前最新稳定版为Angel.SR3：[m
[31m-[m
[31m-           <parent>[m
[31m-                      <groupId>org.springframework.cloud</groupId>[m
[31m-                                                          <artifactId>spring-cloud-starter-[m
[31m-[m
[31m-       parent</artifactId>[m
[31m-                      <version> Angel.SR3</version>[m
[31m-                      <relativePath/>[m
[31m-[m
[31m-       </parent>[m
[31m-[m
[31m-     （3）在此pom.xml文件里添加的dependency对所有的子模[m
[31m-块都是有效的，即在子模块不用再额外添加这些依赖：[m
[31m-[m
[31m-              <dependencies>[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework.boot</groupId>[m
[31m-                                                           <artifactId>spring-boot-starter-[m
[31m-[m
[31m-       web</artifactId>[m
[31m-                      </dependency>[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework.boot</groupId>[m
[31m-                                                           <artifactId>spring-boot-starter-[m
[31m-[m
[31m-       actuator</artifactId>[m
[31m-                      </dependency>[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework.boot</groupId>[m
[31m-                                                           <artifactId>spring-boot-starter-[m
[31m-[m
[31m-       test</artifactId>[m
[31m-                             <scope>test</scope>[m
[31m-                      </dependency>[m
[31m-              </dependencies>[m
[31m-[m
[31m-12.3.2　服务发现——Discovery（Eureka Server）[m
[31m-[m
[31m-     1.依赖[m
[31m-[m
[31m-     服务发现依赖于Eureka Server，所以本模块加上如下依赖[m
[31m-即可：[m
[31m-[m
[31m-              <dependencies>[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework.cloud</groupId>[m
[31m-                             <artifactId>spring-cloud-starter</artifactId>[m
[31m-                      </dependency>[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework.cloud</groupId>[m
[31m-                                             <artifactId>spring-cloud-starter-eureka-[m
[31m-[m
[31m-       server</artifactId>[m
[31m-                      </dependency>[m
[31m-[m
[31m-       </dependencies>[m
[31m-[m
[31m-     2.关键代码[m
[31m-[m
[31m-       package com.wisely.discovery;[m
[31m-[m
[31m-       import org.springframework.boot.SpringApplication;[m
[31m-       import org.springframework.boot.autoconfigure.SpringBootApplication;[m
[31m-       import org.springframework.cloud.netflix.eureka.server.EnableEurekaServ[m
[31m-[m
[31m-       @SpringBootApplication[m
[31m-       @EnableEurekaServer[m
[31m-       public class DiscoveryApplication {[m
[31m-          public static void main(String[] args) {[m
[31m-                     SpringApplication.run(DiscoveryApplication.class, args);[m
[31m-[m
[31m-              }[m
[31m-[m
[31m-}[m
[31m-[m
[31m-代码解释[m
[31m-[m
[31m-一个常规的Spring       Boot项目，我们只需要使用[m
[31m-[m
[31m-@EnableEurekaServer注解开启对EurekaServer的支持即可。[m
[31m-[m
[31m-3.配置[m
[31m-[m
[31m-     在云计算环境下，习惯上使用YAML配置，此处我们也采[m
[31m-用YAML配置。[m
[31m-[m
[31m-application.yml：[m
[31m-[m
[31m-server:[m
[31m-   port: 8761 #1[m
[31m-[m
[31m-eureka:[m
[31m-   instance:[m
[31m-       hostname: localhost #2[m
[31m-   client:[m
[31m-       register-with-eureka: false #3[m
[31m-[m
[31m-fetch-registry: false[m
[31m-[m
[31m-代码解释[m
[31m-①当前Eureka Server服务的端口号为8761。[m
[31m-②当前Eureka Server的hostname为localhost。[m
[31m-③当前服务不需要到Eureka Server上注册。[m
[31m-12.3.3　配置——Config（Config Server）[m
[31m-[m
[31m-     1.依赖[m
[31m-[m
[31m-     Spring Cloud为我们提供了作为配置服务的依赖spring-[m
[31m-cloud-config-server，以及作为eureka客户端的依赖spring-cloud-[m
[31m-starter-eureka：[m
[31m-[m
[31m-              <dependencies>[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework.cloud</groupId>[m
[31m-                             <artifactId>spring-cloud-starter</artifactId>[m
[31m-                      </dependency>[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework.cloud</groupId>[m
[31m-                                                           <artifactId>spring-cloud-config-[m
[31m-[m
[31m-       server</artifactId>[m
[31m-                      </dependency>[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework.cloud</groupId>[m
[31m-                                                          <artifactId>spring-cloud-starter-[m
[31m-[m
[31m-       eureka</artifactId>[m
[31m-                      </dependency>[m
[31m-[m
[31m-       </dependencies>[m
[31m-[m
[31m-     2.关键代码[m
[31m-[m
[31m-       package com.wisely.config;[m
[31m-[m
[31m-       import org.springframework.boot.SpringApplication;[m
[31m-       import org.springframework.boot.autoconfigure.SpringBootApplication;[m
[31m-       import org.springframework.cloud.config.server.EnableConfigServer;[m
[31m-       import org.springframework.cloud.netflix.eureka.EnableEurekaClient;[m
[31m-[m
[31m-       @SpringBootApplication[m
[31m-       @EnableConfigServer //1[m
[31m-       @EnableEurekaClient //2[m
[31m-       public class ConfigApplication {[m
[31m-                public static void main(String[] args) {[m
[31m-                             SpringApplication.run(ConfigApplication.class, args);[m
[31m-[m
[31m-                      }[m
[31m-[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①使用@EnableConfigServer开启配置服务器的支持。[m
[31m-[m
[31m-     ②使用@EnableEurekaClient开启作为Eureka Server的客户[m
[31m-端的支持。[m
[31m-[m
[31m-     3.配置[m
[31m-[m
[31m-     bootstrap.yml[m
[31m-[m
[31m-       spring:[m
[31m-           application:[m
[31m-              name: config #1[m
[31m-           profiles:[m
[31m-              active: native #2[m
[31m-[m
[31m-       eureka:[m
[31m-           instance:[m
[31m-              non-secure-port: ${server.port:8888} #3[m
[31m-              metadata-map:[m
[31m-                  instanceId: ${spring.application.name}:${random.value} #4[m
[31m-           client:[m
[31m-              service-url:[m
[31m-                  defaultZone: http://${eureka.host:localhost}:${eureka.port:8761}/[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     这里对bootstrap.yml做一下解释，Spring Cloud应用提供使[m
[31m-用bootstrap.yml（bootstrap.properties）负责从外部资源加载配[m
[31m-置属性。[m
[31m-[m
[31m-     ①在Erueka Server注册的服务名为config。[m
[31m-[m
[31m-     ②配置服务器使用本地配置（默认为git配置）。[m
[31m-[m
[31m-     ③非SSL端口，若环境变量中server.port有值，则使用环境[m
[31m-变量的值，没有则使用8080。[m
[31m-[m
[31m-     ④配置在Eureka Server的实例ID。[m
[31m-[m
[31m-     ⑤Eureka客户端设置Eureka Server的地址。[m
[31m-[m
[31m-     application.yml[m
[31m-[m
[31m-       spring:[m
[31m-           cloud:[m
[31m-              config:[m
[31m-                  server:[m
[31m-                      native:[m
[31m-                         search-locations: classpath:/config #1[m
[31m-[m
[31m-       server:[m
[31m-           port: 8888[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     配置其他应用所需的配置文件的位置位于类路径下的[m
[31m-config目录下，如图12-1所示。[m
[31m-                                  图12-1　config目录[m
[31m-[m
[31m-     配置文件的规则为：应用名+profile.yml。[m
[31m-[m
[31m-12.3.4　服务模块——Person服务[m
[31m-[m
[31m-     1.依赖[m
[31m-[m
[31m-     本模块需要做数据库操作，故添加spring-boot-starter-data-[m
[31m-jpa依赖（在开发环境下使用hsqldb，在Docker生产环境下使用[m
[31m-PostgreSQL）；本模块还需要使用Config Server的配置，故添[m
[31m-加spring-cloud-config-client依赖。[m
[31m-[m
[31m-              <dependencies>[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework.cloud</groupId>[m
[31m-                             <artifactId>spring-cloud-starter</artifactId>[m
[31m-                      </dependency>[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework.cloud</groupId>[m
[31m-                                                           <artifactId>spring-cloud-config-[m
[31m-[m
[31m-       client</artifactId>[m
[31m-                      </dependency>[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework.cloud</groupId>[m
[31m-                                                          <artifactId>spring-cloud-starter-[m
[31m-       eureka</artifactId>[m
[31m-                      </dependency>[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework.boot</groupId>[m
[31m-                                                  <artifactId>spring-boot-starter-data-[m
[31m-[m
[31m-       jpa</artifactId>[m
[31m-                      </dependency>[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.hsqldb</groupId>[m
[31m-                             <artifactId>hsqldb</artifactId>[m
[31m-                      </dependency>[m
[31m-                      <dependency>[m
[31m-                             <groupId>postgresql</groupId>[m
[31m-                             <artifactId>postgresql</artifactId>[m
[31m-                             <version>9.1-901-1.jdbc4</version>[m
[31m-                      </dependency>[m
[31m-[m
[31m-              </dependencies>[m
[31m-[m
[31m-     2.关键代码[m
[31m-[m
[31m-     本模块没有特别值得关注的代码，主要是实现数据库的一[m
[31m-个保存操作，并将保存操作暴露给UI模块调用。[m
[31m-[m
[31m-       package com.wisely.person.controller;[m
[31m-[m
[31m-       import java.util.List;[m
[31m-[m
[31m-       import org.springframework.beans.factory.annotation.Autowired;[m
[31m-       import org.springframework.data.domain.PageRequest;[m
[31m-       import org.springframework.web.bind.annotation.RequestBody;[m
[31m-       import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-       import org.springframework.web.bind.annotation.RequestMethod;[m
[31m-       import org.springframework.web.bind.annotation.RestController;[m
[31m-[m
[31m-       import com.wisely.person.dao.PersonRepository;[m
[31m-       import com.wisely.person.domain.Person;[m
[31m-[m
[31m-       @RestController[m
[31m-       public class PersonController {[m
[31m-[m
[31m-              @Autowired[m
[31m-              PersonRepository personRepository;[m
[31m-       @RequestMapping(value = "/save", method = RequestMethod.POST)[m
[31m-       public List<Person> savePerson(@RequestBody String personName) {[m
[31m-       Person p = new Person(personName);[m
[31m-       personRepository.save(p);[m
[31m-       List<Person> people = personRepository.findAll(new PageRequest(0, 1[m
[31m-[m
[31m-              return people;[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-3.配置[m
[31m-[m
[31m-bootstrap.yml：[m
[31m-[m
[31m-spring:[m
[31m-   application:[m
[31m-       name: person[m
[31m-   cloud:[m
[31m-       config:[m
[31m-          enabled: true[m
[31m-          discovery:[m
[31m-              enabled: true[m
[31m-              service-id: CONFIG #1[m
[31m-[m
[31m-eureka:[m
[31m-   instance:[m
[31m-       non-secure-port: ${server.port:8082}[m
[31m-   client:[m
[31m-       service-url:[m
[31m-          defaultZone: http://${eureka.host:localhost}:${eureka.port:8761}/[m
[31m-[m
[31m-代码解释[m
[31m-[m
[31m-     指定Config Server的服务名，将会通过Eureka Server发现[m
[31m-Config Server。[m
[31m-[m
[31m-     在开发环境下使用hsqldb：（Config  Server下的[m
[31m-person.yml）：[m
[31m-       spring:[m
[31m-           jpa:[m
[31m-              database: HSQL[m
[31m-[m
[31m-     在Docker生产环境下使用PostgreSQL（Config Server下的[m
[31m-person-docker.yml）：[m
[31m-[m
[31m-       spring:[m
[31m-           jpa:[m
[31m-              database: POSTGRESQL[m
[31m-           datasource:[m
[31m-              platform: postgres[m
[31m-              url: jdbc:postgresql://postgres:5432/postgres[m
[31m-              username: postgres[m
[31m-              password: postgres[m
[31m-              driver-class-name: org.postgresql.Driver[m
[31m-[m
[31m-     application.yml：[m
[31m-[m
[31m-       server:[m
[31m-           port: 8082[m
[31m-[m
[31m-       spring:[m
[31m-           jpa:[m
[31m-              hibernate:[m
[31m-                  ddl-auto: update[m
[31m-[m
[31m-12.3.5　服务模块——Some服务[m
[31m-[m
[31m-     1.依赖[m
[31m-[m
[31m-             <dependencies>[m
[31m-              <dependency>[m
[31m-                     <groupId>org.springframework.cloud</groupId>[m
[31m-                     <artifactId>spring-cloud-starter</artifactId>[m
[31m-[m
[31m-              </dependency>[m
[31m-              <dependency>[m
[31m-[m
[31m-                     <groupId>org.springframework.cloud</groupId>[m
[31m-                                                    <artifactId>spring-cloud-config-[m
[31m-[m
[31m-client</artifactId>[m
[31m-              </dependency>[m
[31m-              <dependency>[m
[31m-                     <groupId>org.springframework.cloud</groupId>[m
[31m-                                                  <artifactId>spring-cloud-starter-[m
[31m-[m
[31m-eureka</artifactId>[m
[31m-              </dependency>[m
[31m-[m
[31m-       </dependencies>[m
[31m-[m
[31m-2.关键代码[m
[31m-[m
[31m-package com.wisely.some;[m
[31m-[m
[31m-import org.springframework.beans.factory.annotation.Value;[m
[31m-import org.springframework.boot.SpringApplication;[m
[31m-import org.springframework.boot.autoconfigure.SpringBootApplication;[m
[31m-import org.springframework.cloud.client.discovery.EnableDiscoveryClient[m
[31m-import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-import org.springframework.web.bind.annotation.RestController;[m
[31m-[m
[31m-@SpringBootApplication[m
[31m-@EnableDiscoveryClient[m
[31m-@RestController[m
[31m-public class SomeApplication {[m
[31m-[m
[31m-         @Value("${my.message}") //1[m
[31m-         private String message;[m
[31m-[m
[31m-         @RequestMapping(value = "/getsome")[m
[31m-         public String getsome(){[m
[31m-[m
[31m-                return message;[m
[31m-         }[m
[31m-       public static void main(String[] args) {[m
[31m-[m
[31m-              SpringApplication.run(SomeApplication.class, args);[m
[31m-       }[m
[31m-[m
[31m-}[m
[31m-此处通过@Value注入的值来自于Config Server。[m
[31m-在开发环境下（Config Server下的some.yml）。[m
[31m-[m
[31m-my:[m
[31m-   message: Message from Development[m
[31m-[m
[31m-     在Docker生产环境下（Config                     Server下的some-[m
[31m-docker.yml）：[m
[31m-[m
[31m-       my:[m
[31m-           message: Message from Production[m
[31m-[m
[31m-3.配置[m
[31m-[m
[31m-bootstrap.yml：[m
[31m-[m
[31m-spring:[m
[31m-   application:[m
[31m-       name: some[m
[31m-   cloud:[m
[31m-       config:[m
[31m-          enabled: true[m
[31m-          discovery:[m
[31m-              enabled: true[m
[31m-              service-id: CONFIG[m
[31m-[m
[31m-eureka:[m
[31m-   instance:[m
[31m-       non-secure-port: ${server.port:8083}[m
[31m-   client:[m
[31m-       service-url:[m
[31m-          defaultZone: http://${eureka.host:localhost}:${eureka.port:8761}/[m
[31m-     application.yml：[m
[31m-[m
[31m-       server:[m
[31m-           port: 8083[m
[31m-[m
[31m-12.3.6　界面模块——UI（Ribbon，Feign）[m
[31m-[m
[31m-     1.依赖[m
[31m-[m
[31m-     本模块会使用ribbon、feign、zuul以及CircuitBreaker，所以[m
[31m-需添加相关依赖。本模块是一个具有界面的模块，所以通过[m
[31m-webjar加载了一些常用的脚本框架：[m
[31m-[m
[31m-       <dependencies>[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework.cloud</groupId>[m
[31m-                             <artifactId>spring-cloud-starter</artifactId>[m
[31m-                      </dependency>[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework.cloud</groupId>[m
[31m-                                                          <artifactId>spring-cloud-starter-[m
[31m-[m
[31m-       hystrix</artifactId>[m
[31m-                      </dependency>[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework.cloud</groupId>[m
[31m-                                                          <artifactId>spring-cloud-starter-[m
[31m-[m
[31m-       zuul</artifactId>[m
[31m-                      </dependency>[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework.cloud</groupId>[m
[31m-                                                           <artifactId>spring-cloud-config-[m
[31m-[m
[31m-       client</artifactId>[m
[31m-                      </dependency>[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework.cloud</groupId>[m
[31m-                                                          <artifactId>spring-cloud-starter-[m
[31m-[m
[31m-       eureka</artifactId>[m
[31m-              </dependency>[m
[31m-              <dependency>[m
[31m-[m
[31m-                     <groupId>org.springframework.cloud</groupId>[m
[31m-                                                  <artifactId>spring-cloud-starter-[m
[31m-[m
[31m-feign</artifactId>[m
[31m-              </dependency>[m
[31m-              <dependency>[m
[31m-                     <groupId>org.springframework.cloud</groupId>[m
[31m-                                                  <artifactId>spring-cloud-starter-[m
[31m-[m
[31m-ribbon</artifactId>[m
[31m-              </dependency>[m
[31m-              <dependency>[m
[31m-                     <groupId>org.webjars</groupId>[m
[31m-                     <artifactId>bootstrap</artifactId>[m
[31m-              </dependency>[m
[31m-              <dependency>[m
[31m-                     <groupId>org.webjars</groupId>[m
[31m-                     <artifactId>angularjs</artifactId>[m
[31m-                     <version>1.3.15</version>[m
[31m-              </dependency>[m
[31m-              <dependency>[m
[31m-                     <groupId>org.webjars</groupId>[m
[31m-                     <artifactId>angular-ui-router</artifactId>[m
[31m-                     <version>0.2.13</version>[m
[31m-              </dependency>[m
[31m-              <dependency>[m
[31m-                     <groupId>org.webjars</groupId>[m
[31m-                     <artifactId>jquery</artifactId>[m
[31m-              </dependency>[m
[31m-[m
[31m-       </dependencies>[m
[31m-[m
[31m-2.关键代码[m
[31m-[m
[31m-（1）入口：[m
[31m-[m
[31m-package com.wisely.ui;[m
[31m-[m
[31m-import org.springframework.boot.SpringApplication;[m
[31m-import org.springframework.boot.autoconfigure.SpringBootApplication;[m
[31m-import org.springframework.cloud.client.circuitbreaker.EnableCircuitBre[m
[31m-import org.springframework.cloud.netflix.eureka.EnableEurekaClient;[m
[31m-import org.springframework.cloud.netflix.feign.EnableFeignClients;[m
[31m-import org.springframework.cloud.netflix.zuul.EnableZuulProxy;[m
[31m-@SpringBootApplication[m
[31m-@EnableEurekaClient[m
[31m-@EnableFeignClients //1[m
[31m-@EnableCircuitBreaker //2[m
[31m-@EnableZuulProxy //3[m
[31m-public class UiApplication {[m
[31m-[m
[31m-       public static void main(String[] args) {[m
[31m-              SpringApplication.run(UiApplication.class, args);[m
[31m-[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-代码解释[m
[31m-[m
[31m-①通过@EnableFeignClients开启feign客户端支持。[m
[31m-[m
[31m-②通过@EnableCircuitBreaker开启CircuitBreaker的支持。[m
[31m-[m
[31m-③通过@EnableZuulProxy开启网关代理的支持[m
[31m-[m
[31m-（2）使用feign调用Person Service：[m
[31m-[m
[31m-package com.wisely.ui.service;[m
[31m-[m
[31m-import java.util.List;[m
[31m-[m
[31m-import org.springframework.cloud.netflix.feign.FeignClient;[m
[31m-import org.springframework.http.MediaType;[m
[31m-import org.springframework.web.bind.annotation.RequestBody;[m
[31m-import org.springframework.web.bind.annotation.RequestMapping;[m
[31m-import org.springframework.web.bind.annotation.RequestMethod;[m
[31m-import org.springframework.web.bind.annotation.ResponseBody;[m
[31m-[m
[31m-import com.wisely.ui.domain.Person;[m
[31m-[m
[31m-@FeignClient("person")[m
[31m-public interface PersonService {[m
[31m-[m
[31m-         @RequestMapping(method = RequestMethod.POST, value = "/save",[m
[31m-                             produces = MediaType.APPLICATION_JSON_VALUE, consumes =[m
[31m-[m
[31m-              @ResponseBody List<Person> save(@RequestBody String name);[m
[31m-}[m
[31m-     代码解释[m
[31m-[m
[31m-     我们只需通过简单的在接口中声明方法即可调用Person服[m
[31m-务的REST服务。[m
[31m-[m
[31m-     （3）调用Person Service的断路器：[m
[31m-[m
[31m-       package com.wisely.ui.service;[m
[31m-[m
[31m-       import java.util.ArrayList;[m
[31m-       import java.util.List;[m
[31m-[m
[31m-       import org.springframework.beans.factory.annotation.Autowired;[m
[31m-       import org.springframework.stereotype.Service;[m
[31m-       import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;[m
[31m-       import com.wisely.ui.domain.Person;[m
[31m-[m
[31m-       @Service[m
[31m-       public class PersonHystrixService {[m
[31m-[m
[31m-              @Autowired[m
[31m-              PersonService personService;[m
[31m-[m
[31m-              @HystrixCommand(fallbackMethod = "fallbackSave") //1[m
[31m-              public List<Person> save(String name) {[m
[31m-[m
[31m-                      return personService.save(name);[m
[31m-              }[m
[31m-[m
[31m-              public List<Person> fallbackSave(){[m
[31m-                      List<Person> list = new ArrayList<>();[m
[31m-                      Person p = new Person("Person Service 故障");[m
[31m-                      list.add(p);[m
[31m-                      return list;[m
[31m-[m
[31m-              }[m
[31m-       }[m
[31m-[m
[31m-     代码解释[m
[31m-[m
[31m-     ①使用@HystrixCommand的fallbackMethod参数指定，当[m
[31m-本方法调用失败时，调用后备方法fallbackSave。[m
[31m-（4）使用ribbon调用Some Sevice，并使用断路器：[m
[31m-[m
[31m-package com.wisely.ui.service;[m
[31m-[m
[31m-import org.springframework.beans.factory.annotation.Autowired;[m
[31m-import org.springframework.stereotype.Service;[m
[31m-import org.springframework.web.client.RestTemplate;[m
[31m-[m
[31m-import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;[m
[31m-[m
[31m-@Service[m
[31m-public class SomeHystrixService {[m
[31m-[m
[31m-       @Autowired[m
[31m-       RestTemplate restTemplate; //1[m
[31m-[m
[31m-       @HystrixCommand(fallbackMethod = "fallbackSome") //2[m
[31m-       public String getSome() {[m
[31m-[m
[31m-              return restTemplate.getForObject("http://some/getsome", String.[m
[31m-       }[m
[31m-[m
[31m-       public String fallbackSome(){[m
[31m-              return "some service模块故障";[m
[31m-[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-代码解释[m
[31m-[m
[31m-在Spring         Boot下使用Ribbon，我们只需注入一个[m
[31m-[m
[31m-RestTemplate即可，Spring Boot已为我们做好了配置。[m
[31m-[m
[31m-     使用@HystrixCommand的fallbackMethod参数指定，当本[m
[31m-方法调用失败时调用后备方法fallbackSome。[m
[31m-[m
[31m-3.配置[m
[31m-[m
[31m-bootstrap.yml：[m
[31m-       spring:[m
[31m-           application:[m
[31m-              name: ui[m
[31m-[m
[31m-       eureka:[m
[31m-           instance:[m
[31m-              non-secure-port: ${server.port:80}[m
[31m-           client:[m
[31m-              service-url:[m
[31m-                  defaultZone: http://${eureka.host:localhost}:${eureka.port:8761}/[m
[31m-[m
[31m-     application.yml[m
[31m-[m
[31m-       server:[m
[31m-           port: 80[m
[31m-[m
[31m-12.3.7　断路器监控——Monitor（DashBoard）[m
[31m-[m
[31m-     1.依赖[m
[31m-[m
[31m-             <dependencies>[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework.cloud</groupId>[m
[31m-                             <artifactId>spring-cloud-starter</artifactId>[m
[31m-                      </dependency>[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework.cloud</groupId>[m
[31m-                                           <artifactId>spring-cloud-starter-hystrix-[m
[31m-[m
[31m-       dashboard</artifactId>[m
[31m-                      </dependency>[m
[31m-                      <dependency>[m
[31m-                             <groupId>org.springframework.cloud</groupId>[m
[31m-                                                          <artifactId>spring-cloud-starter-[m
[31m-[m
[31m-       turbine</artifactId>[m
[31m-                      </dependency>[m
[31m-[m
[31m-              </dependencies>[m
[31m-2.主要代码[m
[31m-[m
[31m-package com.wisely.monitor;[m
[31m-[m
[31m-import org.springframework.boot.SpringApplication;[m
[31m-import org.springframework.boot.autoconfigure.SpringBootApplication;[m
[31m-import org.springframework.cloud.netflix.eureka.EnableEurekaClient;[m
[31m-import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystri[m
[31m-import org.springframework.cloud.netflix.turbine.EnableTurbine;[m
[31m-[m
[31m-@SpringBootApplication[m
[31m-@EnableEurekaClient[m
[31m-@EnableHystrixDashboard[m
[31m-@EnableTurbine[m
[31m-public class MonitorApplication {[m
[31m-[m
[31m-       public static void main(String[] args) {[m
[31m-              SpringApplication.run(MonitorApplication.class, args);[m
[31m-[m
[31m-       }[m
[31m-}[m
[31m-[m
[31m-3.配置[m
[31m-[m
[31m-bootstrap.yml[m
[31m-[m
[31m-spring:[m
[31m-   application:[m
[31m-       name: monitor[m
[31m-[m
[31m-eureka:[m
[31m-   instance:[m
[31m-       nonSecurePort: ${server.port:8989}[m
[31m-   client:[m
[31m-       serviceUrl:[m
[31m-          defaultZone: http://${eureka.host:localhost}:${eureka.port:8761}/[m
[31m-[m
[31m-application.yml[m
[31m-       server:[m
[31m-           port: 8989[m
[31m-[m
[31m-12.3.8　运行[m
[31m-[m
[31m-     我们依次启动DiscoveryApplication、ConfigApplication，后[m
[31m-面所有的微服务启动不分顺序，最后启动MonitorApplication。[m
[31m-此时访问http://localhost：8761，查看Eureka Server，如图12-2[m
[31m-所示。[m
[31m-[m
[31m-                             图12-2　查看Eureka Server[m
[31m-[m
[31m-     1.访问UI服务[m
[31m-     UI服务既是我们的页面，也是我们的网关代理。在实际生[m
[31m-产环境中，服务器防火墙只需将此端口暴露给外网即可，访问[m
[31m-http://localhost，如图12-3所示。[m
[31m-                          图12-3　访问localhost[m
[31m-[m
[31m-（1）调用Person Service，如图12-4所示。[m
[31m-[m
[31m-                       图12-4　调用person-service[m
[31m-[m
[31m-（2）调用Some service，如图12-5所示。[m
[31m-                              图12-5　调用some-service[m
[31m-[m
[31m-     2.断路器[m
[31m-     此时停止Person Service和Some Service，观察断路器的效[m
[31m-果，分别如图12-6和图12-7所示。[m
[31m-[m
[31m-                             图12-6　停止Person Service[m
[31m-[m
[31m-                              图12-7　停止Some Service[m
[31m-[m
[31m-     3.断路器监控[m
[31m-     访问http://localhost：8989/hystrix.stream，如图12-8所示。[m
[31m-                       图12-8　访问hystrix.stream[m
[31m-[m
[31m-输入http://localhost/hystrix.stream，如图12-9所示。[m
[31m-[m
[31m-              图12-9　输入http://localhost/hystrix.stream[m
[31m-[m
[31m-监控界面如图12-10所示。[m
[31m-图12-10　监控界面[m
[31m-12.4　基于Docker部署[m
[31m-[m
[31m-     以Spring Cloud开发的微服务程序十分适合在Docker环境下[m
[31m-部署。[m
[31m-[m
[31m-12.4.1　Dockerfile编写[m
[31m-[m
[31m-     以上6个微服务的Dockerfile的编写几乎完全一致，此处只[m
[31m-以config模块为例。[m
[31m-[m
[31m-     1.runboot.sh脚本编写[m
[31m-[m
[31m-     位于src/main/docker下：[m
[31m-[m
[31m-sleep 10[m
[31m-[m
[31m-java      -Djava.security.egd=file:/dev/./urandom  -[m
[31m-[m
[31m-jar /app/app.jar[m
[31m-[m
[31m-根据启动顺序，调整sleep的时间。[m
[31m-[m
[31m-2.Dockerfile编写[m
[31m-[m
[31m-位于src/main/docker下：[m
[31m-[m
[31m-FROM java:8[m
[31m-VOLUME /tmp[m
[31m-RUN mkdir /app[m
[31m-ADD config-1.0.0-SNAPSHOT.jar /app/app.jar[m
[31m-ADD runboot.sh /app/[m
[31m-       RUN bash -c 'touch /app/app.jar'[m
[31m-       WORKDIR /app[m
[31m-       RUN chmod a+x runboot.sh[m
[31m-       EXPOSE 8888[m
[31m-       CMD /app/runboot.sh[m
[31m-[m
[31m-     为不同的微服务我们只需修改：[m
[31m-[m
[31m-       ADD config-1.0.0-SNAPSHOT.jar /app/app.jar[m
[31m-[m
[31m-     以及端口[m
[31m-[m
[31m-       EXPOSE 8888[m
[31m-[m
[31m-     3.Docker的maven插件[m
[31m-[m
[31m-     在开发机器编译Docker镜像到服务器，使用docker-maven-[m
[31m-plugin即可，在所有程序的pom.xml内增加：[m
[31m-[m
[31m-       <build>[m
[31m-                      <plugins>[m
[31m-                             <plugin>[m
[31m-                                    <groupId>com.spotify</groupId>[m
[31m-                                                                        <artifactId>docker-maven-[m
[31m-[m
[31m-       plugin</artifactId>[m
[31m-                                    <configuration>[m
[31m-                                           <imageName>${project.name}:${project.version}[m
[31m-[m
[31m-       </imageName>[m
[31m-                                           <dockerDirectory>${project.basedir}/src/main/docker[m
[31m-                                           <skipDockerBuild>false</skipDockerBuild>[m
[31m-                                           <resources>[m
[31m-                                                   <resource>[m
[31m-                                                          <directory>${project.build.directory}[m
[31m-[m
[31m-       </directory>[m
[31m-                                                          <include>${project.build.finalName}.jar</in[m
[31m-                                                   </resource>[m
[31m-                                           </resources>[m
[31m-                                    </configuration>[m
[31m-                             </plugin>[m
[31m-                      </plugins>[m
[31m-       </build>[m
[31m-[m
[31m-     4.编译镜像[m
[31m-     使用docker-maven-plugin，默认将Docker编译到localhost。[m
[31m-如果是远程Linux服务器，请在环境变量中配置[m
[31m-DOCKER_HOST，本例的Linux服务器的地址是192.168.1.68，[m
[31m-如图12-11所示。[m
[31m-[m
[31m-                           图12-11　Linux服务器的地址[m
[31m-[m
[31m-     在控制台下进入ch12目录，执行下面语句：[m
[31m-[m
[31m-       mvn clean package docker:build -DskipTests[m
[31m-[m
[31m-     编译完成后效果如图12-12所示。[m
[31m-                                 图12-12　编译后效果[m
[31m-[m
[31m-     查看Linux服务器上的镜像，如图12-13所示。[m
[31m-[m
[31m-                          图12-13　Linux服务器上的镜像[m
[31m-[m
[31m-12.4.2　Docker Compose[m
[31m-[m
[31m-     Docker Compose是用来定义和运行多容器应用的工具。关[m
[31m-于DockerCompose的安装和使用请查看[m
[31m-https://docs.docker.com/compose/。[m
[31m-[m
[31m-     Docker Compose使用一个docker-compose.yml来描述多容器[m
[31m-的定义，使用下面命令运行整个应用。[m
[31m-[m
[31m-       docker-compose up[m
[31m-12.4.3　Docker-compose.yml编写[m
[31m-[m
[31m-       postgresdb:[m
[31m-           image: busybox[m
[31m-           volumes:[m
[31m-              - /var/lib/postgresql/data[m
[31m-[m
[31m-       postgres:[m
[31m-           name: postgres[m
[31m-           image: postgres[m
[31m-           hostname: postgres[m
[31m-           volumes_from:[m
[31m-              - postgresdb[m
[31m-[m
[31m-       # ports:[m
[31m-       # - "5432:5432"[m
[31m-[m
[31m-           environment:[m
[31m-              - POSTGRES_USER=postgres[m
[31m-              - POSTGRES_PASSWORD=postgres[m
[31m-[m
[31m-       discovery:[m
[31m-           image: "discovery:1.0.0-SNAPSHOT"[m
[31m-           hostname: discovery[m
[31m-           name: discovery[m
[31m-           ports:[m
[31m-             - "8761:8761"[m
[31m-[m
[31m-       config:[m
[31m-           image: "config:1.0.0-SNAPSHOT"[m
[31m-           hostname: config[m
[31m-           name: config[m
[31m-           links:[m
[31m-              - discovery[m
[31m-           environment:[m
[31m-                EUREKA_HOST: discovery[m
[31m-                EUREKA_PORT: 8761[m
[31m-[m
[31m-       # ports:[m
[31m-       # - "8888:8888"[m
[31m-[m
[31m-       person:[m
[31m-           image: person:1.0.0-SNAPSHOT[m
[31m-           hostname: person[m
[31m-           links:[m
[31m-              - discovery[m
[31m-              - config[m
[31m-       - postgres[m
[31m-   environment:[m
[31m-[m
[31m-         EUREKA_HOST: discovery[m
[31m-         EUREKA_PORT: 8761[m
[31m-         SPRING_PROFILES_ACTIVE: docker[m
[31m-# ports:[m
[31m-# - "8082:8082"[m
[31m-[m
[31m-some:[m
[31m-   image: some:1.0.0-SNAPSHOT[m
[31m-   hostname: some[m
[31m-   links:[m
[31m-       - discovery[m
[31m-       - config[m
[31m-   environment:[m
[31m-         EUREKA_HOST: discovery[m
[31m-         EUREKA_PORT: 8761[m
[31m-         SPRING_PROFILES_ACTIVE: docker[m
[31m-[m
[31m-# ports:[m
[31m-# - "8083:8083"[m
[31m-[m
[31m-ui:[m
[31m-   image: ui:1.0.0-SNAPSHOT[m
[31m-   hostname: ui[m
[31m-   links:[m
[31m-       - discovery[m
[31m-       - config[m
[31m-       - person[m
[31m-       - some[m
[31m-   environment:[m
[31m-         EUREKA_HOST: discovery[m
[31m-         EUREKA_PORT: 8761[m
[31m-         SPRING_PROFILES_ACTIVE: docker[m
[31m-   ports:[m
[31m-       - "80:80"[m
[31m-[m
[31m-monitor:[m
[31m-   image: monitor:1.0.0-SNAPSHOT[m
[31m-   hostname: monitor[m
[31m-   links:[m
[31m-       - discovery[m
[31m-       - config[m
[31m-       - person[m
[31m-       - some[m
[31m-       - ui[m
[31m-   environment:[m
[31m-         EUREKA_HOST: discovery[m
[31m-         EUREKA_PORT: 8761[m
[31m-                SPRING_PROFILES_ACTIVE: docker[m
[31m-       # ports:[m
[31m-       # - "8989:8989"[m
[31m-[m
[31m-     代码解释[m
[31m-     ①enviroment：给容器使用的变量，在容器中使用${}来调[m
[31m-用。[m
[31m-     ②links：当前容器依赖的容器，可直接使用依赖容器的已[m
[31m-有端口。[m
[31m-     ③ports：将我们要暴露的端口映射出来，不需要暴露的端[m
[31m-口则不做映射。[m
[31m-[m
[31m-12.4.4　运行[m
[31m-[m
[31m-     将docker-compose.yml上传至Linux服务器上，在文件当前[m
[31m-目录执行下面命令：[m
[31m-[m
[31m-       docker-compose up -d[m
[31m-[m
[31m-     -d表示后台运行。[m
[31m-     启动运行效果如图12-14所示。[m
[31m-                               图12-14　启动运行效果[m
[31m-[m
[31m-     这时我们可以在本地访问http://192.168.1.68：8761和[m
[31m-http://192.168.1.68，分别如图12-15和图12-16所示。[m
[31m-[m
[31m-               图12-15　访问效果（http://192.168.1.68：8761）[m
[31m-图12-16　访问效果（http://192.168.1.68）[m
[31m-                     附录A[m
[31m-[m
[31m-A.1　基于JHipster的代码生成[m
[31m-[m
[31m-     JHipster是一个代码生成器，可以用来生成基于Spring Boot[m
[31m-和AngularJS的项目。[m
[31m-[m
[31m-     1.安装Node.JS[m
[31m-     下载地址：https://nodejs.org/download/[m
[31m-     2.安装Git客户端[m
[31m-     下载地址：https://git-scm.com/download/win[m
[31m-     3.安装Yeoman generator[m
[31m-[m
[31m-       npm install -g yo[m
[31m-[m
[31m-     4.安装JHipster[m
[31m-[m
[31m-       npm install -g generator-jhipster[m
[31m-5.安装Bower[m
[31m-[m
[31m-npm install -g bower[m
[31m-[m
[31m-6.安装Grunt[m
[31m-[m
[31m-npm install -g grunt-cli[m
[31m-[m
[31m-7.使用JHipster生成项目[m
[31m-[m
[31m-mkdir hello-boot[m
[31m-cd hello-boot[m
[31m-yo jhipster[m
[31m-[m
[31m-执行下面代码，效果如图A-1所示。[m
[31m-[m
[31m-                             图A-1　执行效果[m
[31m-按照提示向导进行操作，如图A-2所示。[m
[31m-[m
[31m-                       图A-2　按照提示向导操作[m
[31m-[m
[31m-最终完成的结果如图A-3所示。[m
[31m-[m
[31m-                                图A-3　完成[m
[31m-[m
[31m-生成的代码文件结构如图A-4所示。[m
[31m-[m
[31m-      图A-4　文件结构[m
[31m-[m
[31m-8.运行[m
[31m-     在程序目录下，执行下面代码：[m
[31m-[m
[31m-       mvn spring-boot:run[m
[31m-[m
[31m-     访问http://localhost：8080，效果如图A-5所示。[m
[31m-[m
[31m-                         图A-5　访问http://localhost：8080[m
[31m-[m
[31m-     以账号和密码都为admin登录系统，JHipster已为我们做了[m
[31m-很多基础的工作，如图A-6所示。[m
[31m-图A-6　登录系统[m
[31m-A.2　常用应用属性配置列表[m
[31m-[m
[31m-# ===================================================================[m
[31m-[m
[31m-# COMMON SPRING BOOT PROPERTIES[m
[31m-[m
[31m-#[m
[31m-[m
[31m-# This sample file is provided as a guideline. Do NOT copy it in its[m
[31m-[m
[31m-# entirety to your own application.             ^^^[m
[31m-[m
[31m-# ===================================================================[m
[31m-[m
[31m-# ----------------------------------------[m
[31m-# CORE PROPERTIES[m
[31m-# ----------------------------------------[m
[31m-[m
[31m-# BANNER[m
[31m-banner.charset=UTF-8 # banner file encoding[m
[31m-banner.location=classpath:banner.txt # banner file location[m
[31m-[m
[31m-# SPRING CONFIG (ConfigFileApplicationListener[m
[31m-[m
[31m-)[m
[31m-spring.config.name= # config file name (default to 'application')[m
[31m-spring.config.location= # location of config file[m
[31m-[m
[31m-# PROFILES[m
[31m-spring.profiles.active= # comma list of active profiles[m
[31m-[m
[31m-spring.profiles.include= # unconditionally activate the specified comma[m
[31m-# APPLICATION SETTINGS (SpringApplication[m
[31m-)[m
[31m-spring.main.sources= # sources (class name, package name or XML resourc[m
[31m-spring.main.web-environment= # detect by default[m
[31m-spring.main.show-banner=true[m
[31m-spring.main....= # see class for all properties[m
[31m-# ADMIN (SpringApplicationAdminJmxAutoConfiguration[m
[31m-[m
[31m-)[m
[31m-spring.application.admin.enabled=false # enable admin features for the[m
[31m-spring.application.admin.jmx-[m
[31m-name=org.springframework.boot:type=Admin,name=SpringApplication # JMX n[m
[31m-# OUTPUT[m
[31m-spring.output.ansi.enabled=detect # Configure the ANSI output ("detect"[m
[31m-# LOGGING[m
[31m-logging.path=/var/logs[m
[31m-logging.file=myapp.log[m
[31m-logging.config= # location of config file (default classpath:logback.xm[m
[31m-logging.level.*= # levels for loggers, e.g. "logging.level.org.springfr[m
[31m-# IDENTITY (ContextIdApplicationContextInitializer[m
[31m-[m
[31m-)[m
[31m-spring.application.name=[m
[31m-spring.application.index=[m
[31m-# EMBEDDED SERVER CONFIGURATION (ServerProperties[m
[31m-[m
[31m-)[m
[31m-server.port=8080[m
[31m-server.address= # bind to a specific NIC[m
[31m-server.session-timeout= # session timeout in seconds[m
[31m-server.context-[m
[31m-parameters.*= # Servlet context init parameters, e.g. server.context-[m
[31m-parameters.a=alpha[m
[31m-server.context-path= # the context path, defaults to '/'[m
[31m-server.jsp-servlet.class-[m
[31m-name=org.apache.jasper.servlet.JspServlet # The class name of the JSP s[m
[31m-server.jsp-servlet.init-[m
[31m-parameters.*= # Init parameters used to configure the JSP servlet[m
[31m-server.jsp-[m
[31m-servlet.registered=true # Whether or not the JSP servlet is registered[m
[31m-server.servlet-path= # the servlet path, defaults to '/'[m
[31m-server.display-name= # the display name of the application[m
[31m-server.ssl.enabled=true # if SSL support is enabled[m
[31m-server.ssl.client-auth= # want or need[m
[31m-server.ssl.key-alias=[m
[31m-server.ssl.ciphers= # supported SSL ciphers[m
[31m-server.ssl.key-password=[m
[31m-server.ssl.key-store=[m
[31m-server.ssl.key-store-password=[m
[31m-server.ssl.key-store-provider=[m
[31m-server.ssl.key-store-type=[m
[31m-server.ssl.protocol=TLS[m
[31m-server.ssl.trust-store=[m
[31m-server.ssl.trust-store-password=[m
[31m-server.ssl.trust-store-provider=[m
[31m-server.ssl.trust-store-type=[m
[31m-server.tomcat.access-log-[m
[31m-pattern= # log pattern of the access log[m
[31m-server.tomcat.access-log-[m
[31m-enabled=false # is access logging enabled[m
[31m-server.tomcat.compression=off # is compression enabled (off, on, or an[m
[31m-server.tomcat.compressable-mime-[m
[31m-types=text/html,text/xml,text/plain # comma-[m
[31m-separated list of mime types that Tomcat will compress[m
[31m-server.tomcat.internal-[m
[31m-proxies=10\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|\\[m
[31m-[m
[31m-              192\\.168\\.\\d{1,3}\\.\\d{1,3}|\\[m
[31m-              169\\.254\\.\\d{1,3}\\.\\d{1,3}|\\[m
[31m-              127\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|\\[m
[31m-              172\\.1[6-9]{1}\\.\\d{1,3}\\.\\d{1,3}|\\[m
[31m-              172\\.2[0-9]{1}\\.\\d{1,3}\\.\\d{1,3}|\\[m
[31m-[m
[31m-                                                                                        172\\.3[0-1][m
[31m-{1}\\.\\d{1,3}\\.\\d{1,3} # regular expression matching trusted IP addr[m
[31m-server.tomcat.protocol-header=x-forwarded-[m
[31m-proto # front end proxy forward header[m
[31m-server.tomcat.port-header= # front end proxy port header[m
[31m-server.tomcat.remote-ip-header=x-forwarded-for[m
[31m-server.tomcat.basedir=/tmp # base dir (usually not needed, defaults to[m
[31m-server.tomcat.background-processor-delay=30; # in seconds[m
[31m-server.tomcat.max-http-header-[m
[31m-size= # maximum size in bytes of the HTTP message header[m
[31m-server.tomcat.max-[m
[31m-threads = 0 # number of threads in protocol handler[m
[31m-server.tomcat.uri-encoding = UTF-[m
[31m-8 # character encoding to use for URL decoding[m
[31m-server.undertow.access-log-[m
[31m-enabled=false # if access logging is enabled[m
[31m-server.undertow.access-log-[m
[31m-pattern=common # log pattern of the access log[m
[31m-server.undertow.access-log-dir=logs # access logs directory[m
[31m-server.undertow.buffer-size= # size of each buffer in bytes[m
[31m-server.undertow.buffers-per-[m
[31m-region= # number of buffer per region[m
[31m-server.undertow.direct-[m
[31m-buffers=false # allocate buffers outside the Java heap[m
[31m-server.undertow.io-[m
[31m-threads= # number of I/O threads to create for the worker[m
[31m-server.undertow.worker-threads= # number of worker threads[m
[31m-[m
[31m-# SPRING MVC (WebMvcProperties[m
[31m-[m
[31m-)[m
[31m-spring.mvc.locale= # set fixed locale, e.g. en_UK[m
[31m-spring.mvc.date-[m
[31m-format= # set fixed date format, e.g. dd/MM/yyyy[m
[31m-spring.mvc.favicon.enabled=true[m
[31m-spring.mvc.message-codes-resolver-[m
[31m-format= # PREFIX_ERROR_CODE / POSTFIX_ERROR_CODE[m
[31m-spring.mvc.ignore-default-model-on-[m
[31m-redirect=true # If the the content of the "default" model should be ign[m
[31m-spring.view.prefix= # MVC view prefix[m
[31m-spring.view.suffix= # ... and suffix[m
[31m-[m
[31m-# SPRING RESOURCES HANDLING (ResourceProperties[m
[31m-[m
[31m-)[m
[31m-spring.resources.cache-[m
[31m-period= # cache timeouts in headers sent to browser[m
[31m-spring.resources.add-[m
[31m-mappings=true # if default mappings should be added[m
[31m-# MULTIPART (MultipartProperties[m
[31m-[m
[31m-)[m
[31m-multipart.enabled=true[m
[31m-multipart.file-size-[m
[31m-threshold=0 # Threshold after which files will be written to disk.[m
[31m-multipart.location= # Intermediate location of uploaded files.[m
[31m-multipart.max-file-size=1Mb # Max file size.[m
[31m-multipart.max-request-size=10Mb # Max request size.[m
[31m-# SPRING HATEOAS (HateoasProperties[m
[31m-[m
[31m-)[m
[31m-spring.hateoas.apply-to-primary-object-[m
[31m-mapper=true # if the primary mapper should also be configured[m
[31m-# HTTP encoding (HttpEncodingProperties[m
[31m-[m
[31m-)[m
[31m-spring.http.encoding.charset=UTF-[m
[31m-8 # the encoding of HTTP requests/responses[m
[31m-spring.http.encoding.enabled=true # enable http encoding support[m
[31m-spring.http.encoding.force=true # force the configured encoding[m
[31m-# HTTP message conversion[m
[31m-spring.http.converters.preferred-json-[m
[31m-mapper= # the preferred JSON mapper to use for HTTP message conversion.[m
[31m-# HTTP response compression (GzipFilterProperties[m
[31m-)[m
[31m-spring.http.gzip.buffer-[m
[31m-size= # size of the output buffer in bytes[m
[31m-spring.http.gzip.deflate-compression-[m
[31m-level= # the level used for deflate compression (0-9)[m
[31m-spring.http.gzip.deflate-no-[m
[31m-wrap= # noWrap setting for deflate compression (true or false)[m
[31m-spring.http.gzip.enabled=true # enable gzip filter support[m
[31m-spring.http.gzip.excluded-agents= # comma-[m
[31m-separated list of user agents to exclude from compression[m
[31m-spring.http.gzip.exclude-agent-patterns= # comma-[m
[31m-separated list of regular expression patterns to control user agents ex[m
[31m-spring.http.gzip.exclude-paths= # comma-[m
[31m-separated list of paths to exclude from compression[m
[31m-spring.http.gzip.exclude-path-patterns= # comma-[m
[31m-separated list of regular expression patterns to control the paths that[m
[31m-spring.http.gzip.methods= # comma-[m
[31m-separated list of HTTP methods for which compression is enabled[m
[31m-spring.http.gzip.mime-types= # comma-[m
[31m-separated list of MIME types which should be compressed[m
[31m-spring.http.gzip.excluded-mime-types= # comma-[m
[31m-separated list of MIME types to exclude from compression[m
[31m-spring.http.gzip.min-gzip-[m
[31m-size= # minimum content length required for compression to occur[m
[31m-spring.http.gzip.vary= # Vary header to be sent on responses that may b[m
[31m-[m
[31m-# JACKSON (JacksonProperties[m
[31m-[m
[31m-)[m
[31m-spring.jackson.date-format= # Date format string (e.g. yyyy-[m
[31m-MM-dd HH:mm:ss), or a fully-[m
[31m-qualified date format class name (e.g. com.fasterxml.jackson.databind.u[m
[31m-spring.jackson.property-naming-[m
[31m-strategy= # One of the constants on Jackson's PropertyNamingStrategy (e[m
[31m-qualified class name of a PropertyNamingStrategy subclass[m
[31m-spring.jackson.deserialization.*= # see Jackson's DeserializationFeatur[m
[31m-spring.jackson.generator.*= # see Jackson's JsonGenerator.Feature[m
[31m-spring.jackson.joda-date-time-[m
[31m-format= # Joda date time format string[m
[31m-spring.jackson.mapper.*= # see Jackson's MapperFeature[m
[31m-spring.jackson.parser.*= # see Jackson's JsonParser.Feature[m
[31m-spring.jackson.serialization.*= # see Jackson's SerializationFeature[m
[31m-spring.jackson.serialization-[m
[31m-inclusion= # Controls the inclusion of properties during serialization[m
[31m-[m
[31m-# THYMELEAF (ThymeleafAutoConfiguration[m
[31m-[m
[31m-)[m
[31m-spring.thymeleaf.check-template-location=true[m
[31m-spring.thymeleaf.prefix=classpath:/templates/[m
[31m-spring.thymeleaf.excluded-view-names= # comma-[m
[31m-separated list of view names that should be excluded from resolution[m
[31m-spring.thymeleaf.view-names= # comma-[m
[31m-separated list of view names that can be resolved[m
[31m-spring.thymeleaf.suffix=.html[m
[31m-spring.thymeleaf.mode=HTML5[m
[31m-spring.thymeleaf.enabled=true # enable MVC view resolution[m
[31m-spring.thymeleaf.encoding=UTF-8[m
[31m-spring.thymeleaf.content-type=text/html # ;charset=[m
[31m-<encoding> is added[m
[31m-spring.thymeleaf.cache=true # set to false for hot refresh[m
[31m-[m
[31m-# FREEMARKER (FreeMarkerAutoConfiguration[m
[31m-[m
[31m-)[m
[31m-spring.freemarker.allow-request-override=false[m
[31m-spring.freemarker.cache=true[m
[31m-spring.freemarker.check-template-location=true[m
[31m-spring.freemarker.charset=UTF-8[m
[31m-spring.freemarker.content-type=text/html[m
[31m-spring.freemarker.enabled=true # enable MVC view resolution[m
[31m-spring.freemarker.expose-request-attributes=false[m
[31m-spring.freemarker.expose-session-attributes=false[m
[31m-spring.freemarker.expose-spring-macro-helpers=false[m
[31m-spring.freemarker.prefix=[m
[31m-spring.freemarker.request-context-attribute=[m
[31m-spring.freemarker.settings.*=[m
[31m-spring.freemarker.suffix=.ftl[m
[31m-spring.freemarker.template-loader-[m
[31m-path=classpath:/templates/ # comma-separated list[m
[31m-spring.freemarker.view-[m
[31m-names= # whitelist of view names that can be resolved[m
[31m-# GROOVY TEMPLATES (GroovyTemplateAutoConfiguration[m
[31m-[m
[31m-)[m
[31m-spring.groovy.template.cache=true[m
[31m-spring.groovy.template.charset=UTF-8[m
[31m-spring.groovy.template.check-template-[m
[31m-location=true # check that the templates location exists[m
[31m-spring.groovy.template.configuration.*= # See GroovyMarkupConfigurer[m
[31m-spring.groovy.template.content-type=text/html[m
[31m-spring.groovy.template.enabled=true # enable MVC view resolution[m
[31m-spring.groovy.template.prefix=classpath:/templates/[m
[31m-spring.groovy.template.suffix=.tpl[m
[31m-spring.groovy.template.view-[m
[31m-names= # whitelist of view names that can be resolved[m
[31m-[m
[31m-# VELOCITY TEMPLATES (VelocityAutoConfiguration[m
[31m-[m
[31m-)[m
[31m-spring.velocity.allow-request-override=false[m
[31m-spring.velocity.cache=true[m
[31m-spring.velocity.check-template-location=true[m
[31m-spring.velocity.charset=UTF-8[m
[31m-spring.velocity.content-type=text/html[m
[31m-spring.velocity.date-tool-attribute=[m
[31m-spring.velocity.enabled=true # enable MVC view resolution[m
[31m-spring.velocity.expose-request-attributes=false[m
[31m-spring.velocity.expose-session-attributes=false[m
[31m-spring.velocity.expose-spring-macro-helpers=false[m
[31m-spring.velocity.number-tool-attribute=[m
[31m-spring.velocity.prefer-file-system-[m
[31m-access=true # prefer file system access for template loading[m
[31m-spring.velocity.prefix=[m
[31m-spring.velocity.properties.*=[m
[31m-spring.velocity.request-context-attribute=[m
[31m-spring.velocity.resource-loader-path=classpath:/templates/[m
[31m-spring.velocity.suffix=.vm[m
[31m-spring.velocity.toolbox-config-[m
[31m-location= # velocity Toolbox config location, for example "/WEB-[m
[31m-INF/toolbox.xml"[m
[31m-spring.velocity.view-[m
[31m-names= # whitelist of view names that can be resolved[m
[31m-# MUSTACHE TEMPLATES (MustacheAutoConfiguration[m
[31m-[m
[31m-)[m
[31m-spring.mustache.cache=true[m
[31m-spring.mustache.charset=UTF-8[m
[31m-spring.mustache.check-template-location=true[m
[31m-spring.mustache.content-type=UTF-8[m
[31m-spring.mustache.enabled=true # enable MVC view resolution[m
[31m-spring.mustache.prefix=[m
[31m-spring.mustache.suffix=.html[m
[31m-spring.mustache.view-[m
[31m-names= # whitelist of view names that can be resolved[m
[31m-# JERSEY (JerseyProperties[m
[31m-[m
[31m-)[m
[31m-spring.jersey.type=servlet # servlet or filter[m
[31m-spring.jersey.init= # init params[m
[31m-spring.jersey.filter.order=[m
[31m-# INTERNATIONALIZATION (MessageSourceAutoConfiguration[m
[31m-[m
[31m-)[m
[31m-spring.messages.basename=messages[m
[31m-spring.messages.cache-seconds=-1[m
[31m-spring.messages.encoding=UTF-8[m
[31m-[m
[31m-# SECURITY (SecurityProperties[m
[31m-)[m
[31m-security.user.name=user # login username[m
[31m-security.user.password= # login password[m
[31m-security.user.role=USER # role assigned to the user[m
[31m-security.require-ssl=false # advanced settings ...[m
[31m-security.enable-csrf=false[m
[31m-security.basic.enabled=true[m
[31m-security.basic.realm=Spring[m
[31m-security.basic.path= # /**[m
[31m-security.basic.authorize-mode= # ROLE, AUTHENTICATED, NONE[m
[31m-security.filter-order=0[m
[31m-security.headers.xss=false[m
[31m-security.headers.cache=false[m
[31m-security.headers.frame=false[m
[31m-security.headers.content-type=false[m
[31m-security.headers.hsts=all # none / domain / all[m
[31m-security.sessions=stateless # always / never / if_required / stateless[m
[31m-security.ignored= # Comma-[m
[31m-separated list of paths to exclude from the default secured paths[m
[31m-[m
[31m-# OAuth2 client (OAuth2ClientProperties[m
[31m-[m
[31m-spring.oauth2.client.client-id= # OAuth2 client id[m
[31m-spring.oauth2.client.client-[m
[31m-secret= # OAuth2 client secret. A random secret is generated by default[m
[31m-[m
[31m-# OAuth2 SSO (OAuth2SsoProperties[m
[31m-[m
[31m-spring.oauth2.sso.filter-[m
[31m-order= # Filter order to apply if not providing an explicit WebSecurity[m
[31m-spring.oauth2.sso.login-[m
[31m-path= # Path to the login page, i.e. the one that triggers the redirect[m
[31m-[m
[31m-# DATASOURCE (DataSourceAutoConfiguration[m
[31m- & DataSourceProperties[m
[31m-[m
[31m-)[m
[31m-spring.datasource.name= # name of the data source[m
[31m-spring.datasource.initialize=true # populate using data.sql[m
[31m-spring.datasource.schema= # a schema (DDL) script resource reference[m
[31m-spring.datasource.data= # a data (DML) script resource reference[m
[31m-spring.datasource.sql-script-[m
[31m-encoding= # a charset for reading SQL scripts[m
[31m-spring.datasource.platform= # the platform to use in the schema resourc[m
[31m-${platform}.sql)[m
[31m-spring.datasource.continue-on-[m
[31m-error=false # continue even if can't be initialized[m
[31m-spring.datasource.separator=; # statement separator in SQL initializati[m
[31m-spring.datasource.driver-class-name= # JDBC Settings...[m
[31m-spring.datasource.url=[m
[31m-spring.datasource.username=[m
[31m-spring.datasource.password=[m
[31m-spring.datasource.jndi-[m
[31m-name= # For JNDI lookup (class, url, username & password are ignored wh[m
[31m-spring.datasource.max-[m
[31m-active=100 # Advanced configuration...[m
[31m-spring.datasource.max-idle=8[m
[31m-spring.datasource.min-idle=8[m
[31m-spring.datasource.initial-size=10[m
[31m-spring.datasource.validation-query=[m
[31m-spring.datasource.test-on-borrow=false[m
[31m-spring.datasource.test-on-return=false[m
[31m-spring.datasource.test-while-idle=[m
[31m-spring.datasource.time-between-eviction-runs-millis=[m
[31m-spring.datasource.min-evictable-idle-time-millis=[m
[31m-spring.datasource.max-wait=[m
[31m-spring.datasource.jmx-[m
[31m-enabled=false # Export JMX MBeans (if supported)[m
[31m-[m
[31m-# DAO (PersistenceExceptionTranslationAutoConfiguration[m
[31m-[m
[31m-)[m
[31m-spring.dao.exceptiontranslation.enabled=true[m
[31m-[m
[31m-# MONGODB (MongoProperties[m
[31m-[m
[31m-)[m
[31m-spring.data.mongodb.host= # the db host[m
[31m-spring.data.mongodb.port=27017 # the connection port (defaults to 27107[m
[31m-spring.data.mongodb.uri=mongodb://localhost/test # connection URL[m
[31m-spring.data.mongodb.database=[m
[31m-spring.data.mongodb.authentication-database=[m
[31m-spring.data.mongodb.grid-fs-database=[m
[31m-spring.data.mongodb.username=[m
[31m-spring.data.mongodb.password=[m
[31m-spring.data.mongodb.repositories.enabled=true # if spring data reposito[m
[31m-[m
[31m-# JPA (JpaBaseConfiguration[m
[31m-[m
[31m-, HibernateJpaAutoConfiguration[m
[31m-[m
[31m-)[m
[31m-spring.jpa.properties.*= # properties to set on the JPA connection[m
[31m-spring.jpa.open-in-view=true[m
[31m-spring.jpa.show-sql=true[m
[31m-spring.jpa.database-platform=[m
[31m-spring.jpa.database=[m
[31m-spring.jpa.generate-[m
[31m-ddl=false # ignored by Hibernate, might be useful for other vendors[m
[31m-spring.jpa.hibernate.naming-strategy= # naming classname[m
[31m-spring.jpa.hibernate.ddl-auto= # defaults to create-[m
[31m-drop for embedded dbs[m
[31m-spring.data.jpa.repositories.enabled=true # if spring data repository s[m
[31m-[m
[31m-# JTA (JtaAutoConfiguration[m
[31m-)[m
[31m-spring.jta.log-dir= # transaction log dir[m
[31m-spring.jta.*= # technology specific configuration[m
[31m-[m
[31m-# ATOMIKOS[m
[31m-spring.jta.atomikos.connectionfactory.borrow-connection-[m
[31m-timeout=30 # Timeout, in seconds, for borrowing connections from the po[m
[31m-spring.jta.atomikos.connectionfactory.ignore-session-[m
[31m-transacted-[m
[31m-flag=true # Whether or not to ignore the transacted flag when creating[m
[31m-spring.jta.atomikos.connectionfactory.local-transaction-[m
[31m-mode=false # Whether or not local transactions are desired[m
[31m-spring.jta.atomikos.connectionfactory.maintenance-[m
[31m-interval=60 # The time, in seconds, between runs of the pool's maintena[m
[31m-spring.jta.atomikos.connectionfactory.max-idle-[m
[31m-time=60 # The time, in seconds, after which connections are cleaned up[m
[31m-spring.jta.atomikos.connectionfactory.max-[m
[31m-lifetime=0 # The time, in seconds, that a connection can be pooled for[m
[31m-spring.jta.atomikos.connectionfactory.max-pool-[m
[31m-size=1 # The maximum size of the pool[m
[31m-spring.jta.atomikos.connectionfactory.min-pool-[m
[31m-size=1 # The minimum size of the pool[m
[31m-spring.jta.atomikos.connectionfactory.reap-[m
[31m-timeout=0 # The reap timeout, in seconds, for borrowed connections. 0 d[m
[31m-spring.jta.atomikos.connectionfactory.unique-resource-[m
[31m-name=jmsConnectionFactory # The unique name used to identify the resour[m
[31m-spring.jta.atomikos.datasource.borrow-connection-[m
[31m-timeout=30 # Timeout, in seconds, for borrowing connections from the po[m
[31m-spring.jta.atomikos.datasource.default-isolation-[m
[31m-level= # Default isolation level of connections provided by the pool[m
[31m-spring.jta.atomikos.datasource.login-[m
[31m-timeout= # Timeout, in seconds, for establishing a database connection[m
[31m-spring.jta.atomikos.datasource.maintenance-[m
[31m-interval=60 # The time, in seconds, between runs of the pool's maintena[m
[31m-spring.jta.atomikos.datasource.max-idle-[m
[31m-time=60 # The time, in seconds, after which connections are cleaned up[m
[31m-spring.jta.atomikos.datasource.max-[m
[31m-lifetime=0 # The time, in seconds, that a connection can be pooled for[m
[31m-spring.jta.atomikos.datasource.max-pool-[m
[31m-size=1 # The maximum size of the pool[m
[31m-spring.jta.atomikos.datasource.min-pool-[m
[31m-size=1 # The minimum size of the pool[m
[31m-spring.jta.atomikos.datasource.reap-[m
[31m-timeout=0 # The reap timeout, in seconds, for borrowed connections. 0 d[m
[31m-spring.jta.atomikos.datasource.test-[m
[31m-query= # SQL query or statement used to validate a connection before re[m
[31m-spring.jta.atomikos.datasource.unique-resource-[m
[31m-name=dataSource # The unique name used to identify the resource during[m
[31m-[m
[31m-# BITRONIX[m
[31m-spring.jta.bitronix.connectionfactory.acquire-[m
[31m-increment=1 # Number of connections to create when growing the pool[m
[31m-spring.jta.bitronix.connectionfactory.acquisition-[m
[31m-interval=1 # Time, in seconds, to wait before trying to acquire a conne[m
[31m-spring.jta.bitronix.connectionfactory.acquisition-[m
[31m-timeout=30 # Timeout, in seconds, for acquiring connections from the po[m
[31m-spring.jta.bitronix.connectionfactory.allow-local-[m
[31m-transactions=true # Whether or not the transaction manager should allow[m
[31m-XA transactions[m
[31m-spring.jta.bitronix.connectionfactory.apply-transaction-[m
[31m-timeout=false # Whether or not the transaction timeout should be set on[m
[31m-spring.jta.bitronix.connectionfactory.automatic-enlisting-[m
[31m-enabled=true # Whether or not resources should be enlisted and delisted[m
[31m-spring.jta.bitronix.connectionfactory.cache-producers-[m
[31m-consumers=true # Whether or not produces and consumers should be cached[m
[31m-spring.jta.bitronix.connectionfactory.defer-connection-[m
[31m-release=true # Whether or not the provider can run many transactions on[m
[31m-spring.jta.bitronix.connectionfactory.ignore-recovery-[m
[31m-failures=false # Whether or not recovery failures should be ignored[m
[31m-spring.jta.bitronix.connectionfactory.max-idle-[m
[31m-time=60 # The time, in seconds, after which connections are cleaned up[m
[31m-spring.jta.bitronix.connectionfactory.max-pool-[m
[31m-size=10 # The maximum size of the pool. 0 denotes no limit[m
[31m-spring.jta.bitronix.connectionfactory.min-pool-[m
[31m-size=0 # The minimum size of the pool[m
[31m-spring.jta.bitronix.connectionfactory.password= # The password to use t[m
[31m-spring.jta.bitronix.connectionfactory.share-transaction-[m
[31m-connections=false # Whether or not connections in the ACCESSIBLE state[m
[31m-spring.jta.bitronix.connectionfactory.test-[m
[31m-connections=true # Whether or not connections should be tested when acq[m
[31m-spring.jta.bitronix.connectionfactory.two-pc-ordering-[m
[31m-position=1 # The postion that this resource should take during two-[m
[31m-phase commit (always first is Integer.MIN_VALUE, always last is Integer[m
[31m-spring.jta.bitronix.connectionfactory.unique-[m
[31m-name=jmsConnectionFactory # The unique name used to identify the resour[m
[31m-spring.jta.bitronix.connectionfactory.use-tm-[m
[31m-join=true Whether or not TMJOIN should be used when starting XAResource[m
[31m-spring.jta.bitronix.connectionfactory.user= # The user to use to connec[m
[31m-spring.jta.bitronix.datasource.acquire-[m
[31m-increment=1 # Number of connections to create when growing the pool[m
[31m-spring.jta.bitronix.datasource.acquisition-[m
[31m-interval=1 # Time, in seconds, to wait before trying to acquire a conne[m
[31m-spring.jta.bitronix.datasource.acquisition-[m
[31m-timeout=30 # Timeout, in seconds, for acquiring connections from the po[m
[31m-spring.jta.bitronix.datasource.allow-local-[m
[31m-transactions=true # Whether or not the transaction manager should allow[m
[31m-XA transactions[m
[31m-spring.jta.bitronix.datasource.apply-transaction-[m
[31m-timeout=false # Whether or not the transaction timeout should be set on[m
[31m-spring.jta.bitronix.datasource.automatic-enlisting-[m
[31m-enabled=true # Whether or not resources should be enlisted and delisted[m
[31m-spring.jta.bitronix.datasource.cursor-[m
[31m-holdability= # The default cursor holdability for connections[m
[31m-spring.jta.bitronix.datasource.defer-connection-[m
[31m-release=true # Whether or not the database can run many transactions on[m
[31m-spring.jta.bitronix.datasource.enable-jdbc4-connection-[m
[31m-test # Whether or not Connection.isValid() is called when acquiring a c[m
[31m-spring.jta.bitronix.datasource.ignore-recovery-[m
[31m-failures=false # Whether or not recovery failures should be ignored[m
[31m-spring.jta.bitronix.datasource.isolation-[m
[31m-level= # The default isolation level for connections[m
[31m-spring.jta.bitronix.datasource.local-auto-[m
[31m-commit # The default auto-[m
[31m-commit mode for local transactions[m
[31m-spring.jta.bitronix.datasource.login-[m
[31m-timeout= # Timeout, in seconds, for establishing a database connection[m
[31m-spring.jta.bitronix.datasource.max-idle-[m
[31m-time=60 # The time, in seconds, after which connections are cleaned up[m
[31m-spring.jta.bitronix.datasource.max-pool-[m
[31m-size=10 # The maximum size of the pool. 0 denotes no limit[m
[31m-spring.jta.bitronix.datasource.min-pool-[m
[31m-size=0 # The minimum size of the pool[m
[31m-spring.jta.bitronix.datasource.prepared-statement-cache-[m
[31m-size=0 # The target size of the prepared statement cache. 0 disables th[m
[31m-spring.jta.bitronix.datasource.share-transaction-[m
[31m-connections=false # Whether or not connections in the ACCESSIBLE state[m
[31m-spring.jta.bitronix.datasource.test-[m
[31m-query # SQL query or statement used to validate a connection before ret[m
[31m-spring.jta.bitronix.datasource.two-pc-ordering-[m
[31m-position=1 # The position that this resource should take during two-[m
[31m-phase commit (always first is Integer.MIN_VALUE, always last is Integer[m
[31m-spring.jta.bitronix.datasource.unique-[m
[31m-name=dataSource # The unique name used to identify the resource during[m
[31m-spring.jta.bitronix.datasource.use-tm-[m
[31m-join=true Whether or not TMJOIN should be used when starting XAResource[m
[31m-[m
[31m-# SOLR ([m
[31m-SolrProperties[m
[31m-[m
[31m-)[m
[31m-spring.data.solr.host=http://127.0.0.1:8983/solr[m
[31m-spring.data.solr.zk-host=[m
[31m-spring.data.solr.repositories.enabled=true # if spring data repository[m
[31m-# ELASTICSEARCH (ElasticsearchProperties[m
[31m-[m
[31m-)[m
[31m-spring.data.elasticsearch.cluster-[m
[31m-name= # The cluster name (defaults to elasticsearch)[m
[31m-spring.data.elasticsearch.cluster-[m
[31m-nodes= # The address(es) of the server node (comma-[m
[31m-separated; if not specified starts a client node)[m
[31m-spring.data.elasticsearch.properties.*= # Additional properties used to[m
[31m-spring.data.elasticsearch.repositories.enabled=true # if spring data re[m
[31m-# DATA REST (RepositoryRestConfiguration[m
[31m-[m
[31m-)[m
[31m-spring.data.rest.base-[m
[31m-path= # base path against which the exporter should calculate its links[m
[31m-# FLYWAY (FlywayProperties[m
[31m-[m
[31m-)[m
[31m-flyway.*= # Any public property available on the auto-[m
[31m-configured `Flyway` object[m
[31m-flyway.check-[m
[31m-location=false # check that migration scripts location exists[m
[31m-flyway.locations=classpath:db/migration # locations of migrations scrip[m
[31m-flyway.schemas= # schemas to update[m
[31m-flyway.init-version= 1 # version to start migration[m
[31m-flyway.init-[m
[31m-sqls= # SQL statements to execute to initialize a connection immediatel[m
[31m-flyway.sql-migration-prefix=V[m
[31m-flyway.sql-migration-suffix=.sql[m
[31m-flyway.enabled=true[m
[31m-flyway.url= # JDBC url if you want Flyway to create its own DataSource[m
[31m-flyway.user= # JDBC username if you want Flyway to create its own DataS[m
[31m-flyway.password= # JDBC password if you want Flyway to create its own D[m
[31m-[m
[31m-# LIQUIBASE (LiquibaseProperties[m
[31m-[m
[31m-)[m
[31m-liquibase.change-log=classpath:/db/changelog/db.changelog-[m
[31m-master.yaml[m
[31m-liquibase.check-change-log-[m
[31m-location=true # check the change log location exists[m
[31m-liquibase.contexts= # runtime contexts to use[m
[31m-liquibase.default-schema= # default database schema to use[m
[31m-liquibase.drop-first=false[m
[31m-liquibase.enabled=true[m
[31m-liquibase.url= # specific JDBC url (if not set the default datasource i[m
[31m-liquibase.user= # user name for liquibase.url[m
[31m-liquibase.password= # password for liquibase.url[m
[31m-[m
[31m-# JMX[m
[31m-spring.jmx.default-domain= # JMX domain name[m
[31m-spring.jmx.enabled=true # Expose MBeans from Spring[m
[31m-spring.jmx.mbean-server=mBeanServer # MBeanServer bean name[m
[31m-[m
[31m-# RABBIT (RabbitProperties[m
[31m-[m
[31m-)[m
[31m-spring.rabbitmq.addresses= # connection addresses (e.g. myhost:9999,oth[m
[31m-spring.rabbitmq.dynamic=true # create an AmqpAdmin bean[m
[31m-spring.rabbitmq.host= # connection host[m
[31m-spring.rabbitmq.port= # connection port[m
[31m-spring.rabbitmq.password= # login password[m
[31m-spring.rabbitmq.requested-[m
[31m-heartbeat= # requested heartbeat timeout, in seconds; zero for none[m
[31m-spring.rabbitmq.ssl.enabled=false # enable SSL support[m
[31m-spring.rabbitmq.ssl.key-[m
[31m-store= # path to the key store that holds the SSL certificate[m
[31m-spring.rabbitmq.ssl.key-store-[m
[31m-password= # password used to access the key store[m
[31m-spring.rabbitmq.ssl.trust-[m
[31m-store= # trust store that holds SSL certificates[m
[31m-spring.rabbitmq.ssl.trust-store-[m
[31m-password= # password used to access the trust store[m
[31m-spring.rabbitmq.username= # login user[m
[31m-spring.rabbitmq.virtual-[m
[31m-host= # virtual host to use when connecting to the broker[m
[31m-[m
[31m-# REDIS (RedisProperties[m
[31m-[m
[31m-)[m
[31m-spring.redis.database= # database name[m
[31m-spring.redis.host=localhost # server host[m
[31m-spring.redis.password= # server password[m
[31m-spring.redis.port=6379 # connection port[m
[31m-spring.redis.pool.max-idle=8 # pool settings ...[m
[31m-spring.redis.pool.min-idle=0[m
[31m-spring.redis.pool.max-active=8[m
[31m-spring.redis.pool.max-wait=-1[m
[31m-spring.redis.sentinel.master= # name of Redis server[m
[31m-spring.redis.sentinel.nodes= # comma-[m
[31m-separated list of host:port pairs[m
[31m-spring.redis.timeout= # connection timeout in milliseconds[m
[31m-[m
[31m-# ACTIVEMQ (ActiveMQProperties[m
[31m-[m
[31m-)[m
[31m-spring.activemq.broker-[m
[31m-url=tcp://localhost:61616 # connection URL[m
[31m-spring.activemq.user=[m
[31m-spring.activemq.password=[m
[31m-spring.activemq.in-[m
[31m-memory=true # broker kind to create if no broker-[m
[31m-url is specified[m
[31m-spring.activemq.pooled=false[m
[31m-[m
[31m-# HornetQ (HornetQProperties[m
[31m-[m
[31m-)[m
[31m-spring.hornetq.mode= # connection mode (native, embedded)[m
[31m-spring.hornetq.host=localhost # hornetQ host (native mode)[m
[31m-spring.hornetq.port=5445 # hornetQ port (native mode)[m
[31m-spring.hornetq.embedded.enabled=true # if the embedded server is enable[m
[31m-jms-server.jar)[m
[31m-spring.hornetq.embedded.server-id= # auto-[m
[31m-generated id of the embedded server (integer)[m
[31m-spring.hornetq.embedded.persistent=false # message persistence[m
[31m-spring.hornetq.embedded.data-[m
[31m-directory= # location of data content (when persistence is enabled)[m
[31m-spring.hornetq.embedded.queues= # comma-[m
[31m-separated queues to create on startup[m
[31m-spring.hornetq.embedded.topics= # comma-[m
[31m-separated topics to create on startup[m
[31m-spring.hornetq.embedded.cluster-[m
[31m-password= # customer password (randomly generated by default)[m
[31m-[m
[31m-# JMS (JmsProperties[m
[31m-[m
[31m-)[m
[31m-spring.jms.jndi-[m
[31m-name= # JNDI location of a JMS ConnectionFactory[m
[31m-spring.jms.pub-sub-[m
[31m-domain= # false for queue (default), true for topic[m
[31m-[m
[31m-# Email (MailProperties[m
[31m-[m
[31m-)[m
[31m-spring.mail.host=smtp.acme.org # mail server host[m
[31m-spring.mail.port= # mail server port[m
[31m-spring.mail.username=[m
[31m-spring.mail.password=[m
[31m-spring.mail.default-encoding=UTF-[m
[31m-8 # encoding to use for MimeMessages[m
[31m-spring.mail.properties.*= # properties to set on the JavaMail session[m
[31m-spring.mail.jndi-name= # JNDI location of a Mail Session[m
[31m-[m
[31m-# SPRING BATCH (Ba[m
[31m-[m
[31m-tchProperties[m
[31m-[m
[31m-)[m
[31m-spring.batch.job.names=job1,job2[m
[31m-spring.batch.job.enabled=true[m
[31m-spring.batch.initializer.enabled=true[m
[31m-spring.batch.schema= # batch schema to load[m
[31m-spring.batch.table-[m
[31m-prefix= # table prefix for all the batch meta-data tables[m
[31m-[m
[31m-# SPRING CACHE (CacheProperties[m
[31m-[m
[31m-)[m
[31m-spring.cache.type= # generic, ehcache, hazelcast, infinispan, jcache, r[m
[31m-spring.cache.cache-[m
[31m-names= # cache names to create on startup[m
[31m-spring.cache.ehcache.config= # location of the ehcache configuration[m
[31m-spring.cache.hazelcast.config= # location of the hazelcast configuratio[m
[31m-spring.cache.infinispan.config= # location of the infinispan configurat[m
[31m-spring.cache.jcache.config= # location of jcache configuration[m
[31m-spring.cache.jcache.provider= # fully qualified name of the CachingProv[m
[31m-spring.cache.guava.spec= # guava specs[m
[31m-# AOP[m
[31m-spring.aop.auto=[m
[31m-spring.aop.proxy-target-class=[m
[31m-# FILE ENCODING (FileEncodingApplicationListener[m
[31m-[m
[31m-)[m
[31m-spring.mandatory-file-[m
[31m-encoding= # Expected character encoding the application must use[m
[31m-# SPRING SOCIAL (SocialWebAutoConfiguration[m
[31m-[m
[31m-)[m
[31m-spring.social.auto-connection-[m
[31m-views=true # Set to true for default connection views or false if you p[m
[31m-# SPRING SOCIAL FACEBOOK (FacebookAutoConfiguration[m
[31m-[m
[31m-)[m
[31m-spring.social.facebook.app-[m
[31m-id= # your application's Facebook App ID[m
[31m-spring.social.facebook.app-[m
[31m-secret= # your application's Facebook App Secret[m
[31m-# SPRING SOCIAL LINKEDIN (LinkedInAutoConfiguration[m
[31m-[m
[31m-)[m
[31m-spring.social.linkedin.app-[m
[31m-id= # your application's LinkedIn App ID[m
[31m-spring.social.linkedin.app-[m
[31m-secret= # your application's LinkedIn App Secret[m
[31m-# SPRING SOCIAL TWITTER (TwitterAutoConfiguration[m
[31m-[m
[31m-)[m
[31m-spring.social.twitter.app-[m
[31m-id= # your application's Twitter App ID[m
[31m-spring.social.twitter.app-[m
[31m-secret= # your application's Twitter App Secret[m
[31m-[m
[31m-# SPRING MOBILE SITE PREFERENCE (SitePreferenceAutoConfiguration[m
[31m-[m
[31m-)[m
[31m-spring.mobile.sitepreference.enabled=true # enabled by default[m
[31m-[m
[31m-# SPRING MOBILE DEVICE VIEWS (DeviceDelegatingViewResolverAutoConfigura[m
[31m-[m
[31m-)[m
[31m-spring.mobile.devicedelegatingviewresolver.enabled=true # disabled by d[m
[31m-spring.mobile.devicedelegatingviewresolver.enable-[m
[31m-fallback= # enable support for fallback resolution, default to false.[m
[31m-spring.mobile.devicedelegatingviewresolver.normal-prefix=[m
[31m-spring.mobile.devicedelegatingviewresolver.normal-suffix=[m
[31m-spring.mobile.devicedelegatingviewresolver.mobile-[m
[31m-prefix=mobile/[m
[31m-spring.mobile.devicedelegatingviewresolver.mobile-suffix=[m
[31m-spring.mobile.devicedelegatingviewresolver.tablet-[m
[31m-prefix=tablet/[m
[31m-spring.mobile.devicedelegatingviewresolver.tablet-suffix=[m
[31m-[m
[31m-# ----------------------------------------[m
[31m-# DEVTOOLS PROPERTIES[m
[31m-# ----------------------------------------[m
[31m-[m
[31m-# DEVTOOLS (DevToolsProperties[m
[31m-)[m
[31m-spring.devtools.restart.enabled=true # enable automatic restart[m
[31m-spring.devtools.restart.exclude= # patterns that should be excluding fo[m
[31m-spring.devtools.restart.poll-[m
[31m-interval= # amount of time (in milliseconds) to wait between polling fo[m
[31m-spring.devtools.restart.quiet-[m
[31m-period= # amount of quiet time (in milliseconds) requited without any c[m
[31m-spring.devtools.restart.trigger-[m
[31m-file= # name of a specific file that when changed will trigger the rest[m
[31m-spring.devtools.livereload.enabled=true # enable a livereload.com compa[m
[31m-spring.devtools.livereload.port=35729 # server port.[m
[31m-[m
[31m-# REMOTE DEVTOOLS (RemoteDevToolsProperties[m
[31m-[m
[31m-)[m
[31m-spring.devtools.remote.context-path=/.~~spring-[m
[31m-boot!~ # context path used to handle the remote connection[m
[31m-spring.devtools.remote.debug.enabled=true # enable remote debug support[m
[31m-spring.devtools.remote.debug.local-[m
[31m-port=8000 # local remote debug server port[m
[31m-spring.devtools.remote.restart.enabled=true # enable remote restart[m
[31m-spring.devtools.remote.secret= # a shared secret required to establish[m
[31m-spring.devtools.remote.secret-header-name=X-AUTH-[m
[31m-TOKEN # HTTP header used to transfer the shared secret[m
[31m-[m
[31m-# ----------------------------------------[m
[31m-# ACTUATOR PROPERTIES[m
[31m-# ----------------------------------------[m
[31m-[m
[31m-# MANAGEMENT HTTP SERVER (ManagementServerProperties[m
[31m-[m
[31m-)[m
[31m-management.port= # defaults to 'server.port'[m
[31m-management.address= # bind to a specific NIC[m
[31m-management.context-path= # default to '/'[m
[31m-management.add-application-context-[m
[31m-header= # default to true[m
[31m-management.security.enabled=true # enable security[m
[31m-management.security.role=ADMIN # role required to access the management[m
[31m-management.security.sessions=stateless # session creating policy to use[m
[31m-[m
[31m-# PID FILE (ApplicationPidFileWriter[m
[31m-[m
[31m-)[m
[31m-spring.pidfile= # Location of the PID file to write[m
[31m-[m
[31m-# ENDPOINTS (AbstractEndpoint[m
[31m-[m
[31m- subclasses)[m
[31m-endpoints.autoconfig.id=autoconfig[m
[31m-endpoints.autoconfig.sensitive=true[m
[31m-endpoints.autoconfig.enabled=true[m
[31m-endpoints.beans.id=beans[m
[31m-endpoints.beans.sensitive=true[m
[31m-endpoints.beans.enabled=true[m
[31m-endpoints.configprops.id=configprops[m
[31m-endpoints.configprops.sensitive=true[m
[31m-endpoints.configprops.enabled=true[m
[31m-endpoints.configprops.keys-to-[m
[31m-sanitize=password,secret,key # suffix or regex[m
[31m-endpoints.dump.id=dump[m
[31m-endpoints.dump.sensitive=true[m
[31m-endpoints.dump.enabled=true[m
[31m-endpoints.enabled=true # enable all endpoints[m
[31m-endpoints.env.id=env[m
[31m-endpoints.env.sensitive=true[m
[31m-endpoints.env.enabled=true[m
[31m-endpoints.env.keys-to-[m
[31m-sanitize=password,secret,key # suffix or regex[m
[31m-endpoints.health.id=health[m
[31m-endpoints.health.sensitive=true[m
[31m-endpoints.health.enabled=true[m
[31m-endpoints.health.mapping.*= # mapping of health statuses to HttpStatus[m
[31m-endpoints.health.time-to-live=1000[m
[31m-endpoints.info.id=info[m
[31m-endpoints.info.sensitive=false[m
[31m-endpoints.info.enabled=true[m
[31m-endpoints.mappings.enabled=true[m
[31m-endpoints.mappings.id=mappings[m
[31m-endpoints.mappings.sensitive=true[m
[31m-endpoints.metrics.id=metrics[m
[31m-endpoints.metrics.sensitive=true[m
[31m-endpoints.metrics.enabled=true[m
[31m-endpoints.shutdown.id=shutdown[m
[31m-endpoints.shutdown.sensitive=true[m
[31m-endpoints.shutdown.enabled=false[m
[31m-endpoints.trace.id=trace[m
[31m-endpoints.trace.sensitive=true[m
[31m-endpoints.trace.enabled=true[m
[31m-[m
[31m-# ENDPOINTS CORS CONFIGURATION (MvcEndpointCorsProperties[m
[31m-[m
[31m-)[m
[31m-endpoints.cors.allow-[m
[31m-credentials= # set whether user credentials are support. When not set,[m
[31m-endpoints.cors.allowed-origins= # comma-[m
[31m-separated list of origins to allow. * allows all origins. When not set,[m
[31m-endpoints.cors.allowed-methods= # comma-[m
[31m-separated list of methods to allow. * allows all methods. When not set,[m
[31m-endpoints.cors.allowed-headers= # comma-[m
[31m-separated list of headers to allow in a request. * allows all headers.[m
[31m-endpoints.cors.exposed-headers= # comma-[m
[31m-separated list of headers to include in a response.[m
[31m-endpoints.cors.max-[m
[31m-age=1800 # how long, in seconds, the response from a pre-[m
[31m-flight request can be cached by clients.[m
[31m-[m
[31m-# HEALTH INDICATORS (previously health.*)[m
[31m-[m
[31m-management.health.db.enabled=true[m
[31m-[m
[31m-management.health.elasticsearch.enabled=true[m
[31m-[m
[31m-management.health.elasticsearch.indices=        # comma-[m
[31m-[m
[31m-separated index names[m
[31m-[m
[31m-management.health.elasticsearch.response-[m
[31m-[m
[31m-timeout=100 # the time, in milliseconds, to wait for a response from th[m
[31m-[m
[31m-management.health.diskspace.enabled=true[m
[31m-[m
[31m-management.health.diskspace.path=.[m
[31m-[m
[31m-management.health.diskspace.threshold=10485760[m
[31m-[m
[31m-management.health.jms.enabled=true[m
[31m-[m
[31m-management.health.mail.enabled=true[m
[31m-[m
[31m-management.health.mongo.enabled=true[m
[31m-[m
[31m-management.health.rabbit.enabled=true[m
[31m-management.health.redis.enabled=true[m
[31m-management.health.solr.enabled=true[m
[31m-management.health.status.order=DOWN, OUT_OF_SERVICE, UNKNOWN, UP[m
[31m-[m
[31m-# MVC ONLY ENDPOINTS[m
[31m-endpoints.jolokia.path=/jolokia[m
[31m-endpoints.jolokia.sensitive=true[m
[31m-endpoints.jolokia.enabled=true # when using Jolokia[m
[31m-[m
[31m-# JMX ENDPOINT (EndpointMBeanExportProperties[m
[31m-[m
[31m-)[m
[31m-endpoints.jmx.enabled=true # enable JMX export of all endpoints[m
[31m-endpoints.jmx.domain= # the JMX domain, defaults to 'org.springboot'[m
[31m-endpoints.jmx.unique-names=false[m
[31m-endpoints.jmx.static-names=[m
[31m-[m
[31m-# JOLOKIA (JolokiaProperties[m
[31m-[m
[31m-)[m
[31m-jolokia.config.*= # See Jolokia manual[m
[31m-[m
[31m-# REMOTE SHELL[m
[31m-shell.auth=simple # jaas, key, simple, spring[m
[31m-shell.command-refresh-interval=-1[m
[31m-shell.command-path-[m
[31m-patterns= # classpath*:/commands/**, classpath*:/crash/commands/**[m
[31m-shell.config-path-patterns= # classpath*:/crash/*[m
[31m-shell.disabled-commands=jpa*,jdbc*,jndi* # comma-[m
[31m-separated list of commands to disable[m
[31m-shell.disabled-plugins=false # don't expose plugins[m
[31m-shell.ssh.enabled= # ssh settings ...[m
[31m-shell.ssh.key-path=[m
[31m-shell.ssh.port=[m
[31m-shell.telnet.enabled= # telnet settings ...[m
[31m-shell.telnet.port=[m
[31m-shell.auth.jaas.domain= # authentication settings ...[m
[31m-shell.auth.key.path=[m
[31m-shell.auth.simple.user.name=[m
[31m-shell.auth.simple.user.password=[m
[31m-shell.auth.spring.roles=[m
[31m-[m
[31m-# METRICS EXPORT (MetricExportProperties[m
[31m-[m
[31m-)[m
[31m-spring.metrics.export.enabled=true # flag to disable all metric exports[m
[31m-spring.metrics.export.delay-[m
[31m-millis=5000 # delay in milliseconds between export ticks[m
[31m-spring.metrics.export.send-[m
[31m-latest=true # flag to switch off any available optimizations based on n[m
[31m-spring.metrics.export.includes= # list of patterns for metric names to[m
[31m-spring.metrics.export.excludes= # list of patterns for metric names to[m
[31m-spring.metrics.export.redis.aggregate-key-[m
[31m-pattern= # pattern that tells the aggregator what to do with the keys f[m
[31m-spring.metrics.export.redis.prefix=spring.metrics # prefix for redis re[m
[31m-spring.metrics.export.redis.key=keys.spring.metrics # key for redis rep[m
[31m-spring.metrics.export.triggers.*= # specific trigger properties per Met[m
[31m-[m
[31m-# SENDGRID (SendGridAutoConfiguration[m
[31m-[m
[31m-)[m
[31m-spring.sendgrid.username= # SendGrid account username[m
[31m-spring.sendgrid.password= # SendGrid account password[m
[31m-spring.sendgrid.proxy.host= # SendGrid proxy host[m
[31m-spring.sendgrid.proxy.port= # SendGrid proxy port[m
[31m-[m
[31m-# GIT INFO[m
[31m-spring.git.properties= # resource ref to generated git info properties[m
[31m-              Table of Contents[m
[31m-[m
[31m-版权信息[m
[31m-[m
[31m-前言[m
[31m-[m
[31m-第一部分 点睛Spring 4.x[m
[31m-      第1章 Spring基础[m
[31m-                  1.1 Spring概述[m
[31m-                  1.2 Spring项目快速搭建[m
[31m-                  1.3 Spring基础配置[m
[31m-      第2章 Spring常用配置[m
[31m-                  2.1 Bean的Scope[m
[31m-                  2.2 Spring EL和资源调用[m
[31m-                  2.3 Bean的初始化和销毁[m
[31m-[m
[31m-                  2.4 Profile[m
[31m-                  2.5 事件（Application Event）[m
[31m-      第3章 Spring高级话题[m
[31m-[m
[31m-                  3.1 Spring Aware[m
[31m-                  3.2 多线程[m
[31m-                  3.3 计划任务[m
[31m-                  3.4 条件注解@Conditional[m
[31m-                  3.5 组合注解与元注解[m
[31m-                  3.6 @Enable*注解的工作原理[m
[31m-                  3.7 测试[m
[31m-第二部分 点睛Spring MVC 4.x[m
[31m-      第4章 Spring MVC基础[m
[31m-                  4.1 Spring MVC概述[m
[31m-                  4.2 Spring MVC项目快速搭建[m
[31m-                  4.3 Spring MVC的常用注解[m
[31m-                  4.4 Spring MVC基本配置[m
[31m-                  4.5 Spring MVC的高级配置[m
[31m-                  4.6 Spring MVC的测试[m
[31m-第三部分 实战Spring Boot[m
[31m-      第5章 Spring Boot基础[m
[31m-                  5.1 Spring Boot概述[m
[31m-                  5.2 Spring Boot快速搭建[m
[31m-第6章 Spring Boot核心[m
[31m-            6.1 基本配置[m
[31m-            6.2 外部配置[m
[31m-            6.3 日志配置[m
[31m-            6.4 Profile配置[m
[31m-            6.5 Spring Boot运行原理[m
[31m-[m
[31m-第7章 Spring Boot的Web开发[m
[31m-            7.1 Spring Boot的Web开发支持[m
[31m-            7.2 Thymeleaf模板引擎[m
[31m-            7.3 Web相关配置[m
[31m-            7.4 Tomcat配置[m
[31m-            7.5 Favicon配置[m
[31m-[m
[31m-            7.6 WebSocket[m
[31m-            7.7 基于Bootstrap和AngularJS的现代Web应用[m
[31m-第8章 Spring Boot的数据访问[m
[31m-            8.1 引入Docker[m
[31m-[m
[31m-            8.2 Spring Data JPA[m
[31m-[m
[31m-            8.3 Spring Data REST[m
[31m-            8.4 声名式事务[m
[31m-            8.5 数据缓存Cache[m
[31m-            8.6 非关系型数据库NoSQL[m
[31m-第9章 Spring Boot企业级开发[m
[31m-            9.1 安全控制Spring Security[m
[31m-            9.2 批处理Spring Batch[m
[31m-            9.3 异步消息[m
[31m-            9.4 系统集成Spring Integration[m
[31m-第10章 Spring Boot开发部署与测试[m
[31m-            10.1 开发的热部署[m
[31m-            10.2 常规部署[m
[31m-            10.3 云部署——基于Docker的部署[m
[31m-            10.4 Spring Boot的测试[m
[31m-第11章 应用监控[m
[31m-[m
[31m-            11.1 http[m
[31m-[m
[31m-            11.2 JMX[m
[31m-[m
[31m-            11.3 SSH[m
[31m-第12章 分布式系统开发[m
[31m-[m
[31m-            12.1 微服务、原生云应用[m
[31m-                  12.2 Spring Cloud快速入门[m
[31m-                  12.3 实战[m
[31m-                  12.4 基于Docker部署[m
[31m-附录A[m
[31m-      A.1 基于JHipster的代码生成[m
[31m-      A.2 常用应用属性配置列表[m
[31m-[m
\ No newline at end of file[m
